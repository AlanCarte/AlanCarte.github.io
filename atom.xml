<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alan</title>
  
  <subtitle>山山而川 人生尔尔</subtitle>
  <link href="https://blog.haodene.love/atom.xml" rel="self"/>
  
  <link href="https://blog.haodene.love/"/>
  <updated>2023-10-29T00:46:30.348Z</updated>
  <id>https://blog.haodene.love/</id>
  
  <author>
    <name>Alan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Redis</title>
    <link href="https://blog.haodene.love/2023/08/06/Redis/"/>
    <id>https://blog.haodene.love/2023/08/06/Redis/</id>
    <published>2023-08-06T08:30:00.000Z</published>
    <updated>2023-10-29T00:46:30.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="一、Redis为什么快"><a href="#一、Redis为什么快" class="headerlink" title="一、Redis为什么快"></a>一、Redis为什么快</h1><ol><li><p>（内存操作）因为Redis将所有的数据存储在内存中，可以快速读取和写入数据，而不需要像传统数据需要从磁盘读取数据。</p></li><li><p>（数据结构简单）Redis支持多种数据结构，包括字符串，哈希表、列表，集合和有序集合等。</p></li><li>（单线程模型）Redis使采用了单线程的模型，避免了多线程并发带来的竞争和线程切换的开销，提高性能。</li><li>（非阻塞I/O）Redis使用非阻塞I/O模型，可以等待I/O操作完成时处理其他请求，提高了并发的处理能力。</li><li>（持久化机制）Redis支持两种持久化的操作，RDB和AOF，可以在服务器崩溃时快速的恢复数据。</li><li>（高效的网络通信）Redis使用自己的协议进行网络通信，协议简单，高效，可以快速的传输数据。</li><li>（原子操作）Redis支持原子操作，可以确保多个操作的原子性，避免了并大的数据的不一致性的问题。</li></ol><blockquote><p>Redis之所以快是因为它采用了内存存储和非阻塞的I/O模型，避免了磁盘IO的延迟；同时，Redis使用了IO多路复用技术，通过一个线程同时处理多个客户端请求，减少了线程切换的开销，提高了并发处理能力。</p></blockquote><h1 id="二、Redis可以用来做什么"><a href="#二、Redis可以用来做什么" class="headerlink" title="二、Redis可以用来做什么"></a>二、Redis可以用来做什么</h1><ol><li><p><strong>缓存：</strong>Redis可以用作高性能的缓存存储，将热门数据存储在内存中，以提供快速的访问速度，减轻数据库的负载。</p></li><li><p><strong>数据库：</strong>Redis支持多种数据结构，包括字符串、哈希表、列表、集合和有序集合等，可以用作简单的键值存储或者更复杂的数据结构存储。</p></li><li><p><strong>消息队列：</strong>Redis的发布/订阅功能可以用于构建消息队列系统，实现异步消息传递和解耦。</p></li><li><p><strong>分布式锁：</strong>Redis提供了原子操作和事务支持，可以用来实现分布式锁，保证多个客户端之间的互斥访问。</p></li><li><p><strong>计数器和排行榜：</strong>Redis的原子操作可以用于实现计数器和排行榜功能，例如统计网站的访问量或者排名。</p></li><li><p><strong>地理位置服务：</strong>Redis的地理位置功能可以用来存储地理位置信息，并进行附近位置的搜索和查询。</p></li><li><p><strong>实时数据分析：</strong>Redis支持高速的数据读写，可以用于实时数据分析和处理，例如实时统计和监控。</p></li></ol><h1 id="三、Redis的持久化操作"><a href="#三、Redis的持久化操作" class="headerlink" title="三、Redis的持久化操作"></a>三、Redis的持久化操作</h1><p><img src="https://bu.dusays.com/2023/10/22/65353b6d3eac2.png" alt=""></p><p>在Redis 4.0之后提供了混合持久化的方式，顾名思义就是把RDB持久化和AOF持久化结合起来的一种方式。混合持久化就是快照以一定的频率执行，而在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p><strong>RDB持久化</strong></p><p>RDB又被称为<strong>快照模式</strong>，也是默认使用的策略。RDB通过把内存里的数据保存到磁盘文件上;当需要数据的时候，直接读取文件把数据回复到内存里来进行持久化的</p><p><strong>RDB在什么时候进行持久化：</strong></p><ul><li><strong>使用save命令时进行持久化</strong>，这是一种<strong>阻塞式的持久化</strong>，在RDB过程中不能去处理客户端发送来的请求。</li><li><strong>使用bgsave命令进行持久化</strong>，这是一种<strong>非阻塞式的持久化</strong>，它会fork一个子进程，让子进程去进行持久化，主进程去处理客户端发送的请求，在子进程fork期间，会把物理内存里的数据设置为<strong>read-only只读</strong>。主进程如果要进行写数据则进行copy-on-write机制，把数据拷贝一个副本，实际操作的是副本。</li><li><strong>正常关闭Redis时会进持久化</strong>；会在关闭之前先持久化保存</li><li><strong>自动触发RDB持久化</strong>save 3600 1、save 300 100、save 60 10000；数据变化的越多，保存频率就越高</li></ul><p>RDB持久化还可以对文件进行压缩，所以文件体积更小。</p><p><strong>AOF持久化</strong></p><p>AOF被称为日志模式，需要手动开起，AOF在执行写操作的时侯会把操作命令追加到磁盘文件上，当需要恢复数据时，读取文件里的命令会依次执行，相当于重构数据库。</p><p><strong>AOF什么时候进行持久化：</strong></p><p>三种刷盘机制：</p><p><strong>always：同步刷盘</strong>；每次进行写操作的命令的时候，都会把数据写道磁盘文件，这种是最安全的但是影响性能。</p><p><strong>no：不主动刷盘</strong>；每次进行写操作的命令的时候，会放到AOF缓冲区；由操作系统决定什么时候进行刷盘，这种是性能最好但是安全性较低，可能丢失数据。</p><p><strong>everySec：**</strong>每秒刷盘**；每次进行写操作的命令的时候，会放到AOF缓冲区；每秒执行一次刷盘操作。性能适中，也是默认的策略。</p><p>AOF文件体积大：AOF重写<br>手动重写：执行命令bgrewriteaof<br>自动重写：默认当文件体积达到64mb，并且体积增加100%，会自动重写</p><p><strong>RDB和AOF的对比：</strong></p><ul><li>存储内容：RDB存储的是数据；AOF存储的是写操作的命令</li><li>文件体积：RDB文件体积小；AOF文件体积大</li><li>恢复速度：RDB恢复速度快；AOF恢复速度慢</li><li>持久保存速度：一次RDB，比一次AOF 占用资源更多</li><li>数据安全：RDB可能丢失数据；AOF丢失数据的可能性更小</li><li>最终的选择：如果对数据安全性要求不高，使用RDB；否则使用AOFLLLL</li></ul><p>​    </p><h1 id="四、Redis常用的数据类型"><a href="#四、Redis常用的数据类型" class="headerlink" title="四、Redis常用的数据类型"></a>四、Redis常用的数据类型</h1><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">特征</th><th style="text-align:center">使用场景</th><th style="text-align:center">常用命令</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">存储单个值</td><td style="text-align:center">缓存、计数器、键值存储</td><td style="text-align:center">Set key value、Get key</td></tr><tr><td style="text-align:center">Hash</td><td style="text-align:center">字段-值对的无序散列</td><td style="text-align:center">存储对象、缓存、计数器</td><td style="text-align:center">Hash key filed value、HGETALL key</td></tr><tr><td style="text-align:center">List</td><td style="text-align:center">有序、可重复的字符串集合</td><td style="text-align:center">消息队列、发布/订阅系统</td><td style="text-align:center">LPUSH key value、LRANG key start stop</td></tr><tr><td style="text-align:center">Set</td><td style="text-align:center">无序、不可重复</td><td style="text-align:center">标签系统、好友关系等</td><td style="text-align:center">SADD key member、SMEMBERS key</td></tr><tr><td style="text-align:center">Sorted Set</td><td style="text-align:center">有序的字符串集合，每个成员关联一个分数</td><td style="text-align:center">排行榜、按照分数范围获取成员</td><td style="text-align:center">ZADD key score member、ZRANGE key start stop 、ZREVRANGE key start stop</td></tr></tbody></table></div><ul><li><strong>String：</strong>存储单个值，适用于键值的存储，常用的命令：Set  用于设置值，Get用于获取值。</li><li><strong>Hash：</strong> 字段-值对的无序散列，适用于存储对象、缓存和计数器，常用命令：HSET 用于设值字段的值，HGETALL 用于获取散列所有的字段和值。</li><li><strong>List：</strong>有序、可重复的字符串集合，适用于消息队列和发布/订阅系统，常用命令：LPUSH用于从列表左侧添加元素，LRANGE用于获取指定范围的元素。</li><li><strong>Set：</strong> 无序、不可重复的字符串集合，适用于标签系统和好友关系等，常用命令：SADD用于向集合添加成员，SMEMBERS用于获取集合所有成员。</li><li><strong>Sorted Set：</strong>有序的字符串集合，每个成员关联一个分数，适用于排行榜和按分数范围获取成员，常用命令：ZADD用于添加成员及其分数，ZRANGE用于获取指定范围的成员。</li></ul><h1 id="五、Redis的缓存机制（俗称：三兄弟）"><a href="#五、Redis的缓存机制（俗称：三兄弟）" class="headerlink" title="五、Redis的缓存机制（俗称：三兄弟）"></a>五、Redis的缓存机制（俗称：三兄弟）</h1><p><strong>缓存穿透：</strong>缓存穿透是指请求缓存中不存在的数据，导致所有请求都直接访问数据库，同样给数据库带来巨大的压力。</p><p>解决方案包括：</p><ul><li>对于查询结果为空的数据，也将其缓存起来，设置一个较短的过期时间，避免频繁查询数据库。</li><li>使用布隆过滤器等技术，对请求进行过滤，过滤掉不存在的数据。</li></ul><p><strong>缓存击穿：</strong>缓存击穿是指某个热点数据失效后，大量并发请求同时访问数据库，导致数据库压力过大。</p><p>解决方案包括：</p><ul><li>使用互斥锁或分布式锁，只允许一个请求访问数据库，其他请求等待结果。</li><li>使用缓存预热技术，在缓存失效之前主动加载数据到缓存中，避免缓存击穿。</li></ul><p><strong>缓存雪崩：</strong> 缓存雪崩是指缓存中的大量数据同时失效或者缓存服务器宕机，导致所有请求都直接访问数据库，给数据库带来巨大的压力，甚至导致数据库崩溃。</p><p>解决方案包括：</p><ul><li>设置合理的缓存过期时间，避免大量缓存同时失效。</li><li>使用多级缓存架构，如本地缓存和分布式缓存结合使用，提高缓存的可靠性。</li><li>实现热点数据的热加载，提前将热点数据加载到缓存中。</li></ul><h1 id="六、Redis的哨兵集群（Redis-Sentinel）"><a href="#六、Redis的哨兵集群（Redis-Sentinel）" class="headerlink" title="六、Redis的哨兵集群（Redis Sentinel）"></a>六、Redis的哨兵集群（Redis Sentinel）</h1><p>Redis的哨兵（Sentinel）机制是一种用于监控和管理Redis实例的高可用性解决方案。它由一组独立运行的Redis哨兵节点组成，用于监控主节点和从节点的状态，并在主节点故障或其他变化时进行自动切换和故障恢复。</p><p><img src="https://bu.dusays.com/2023/10/23/6536583dcff52.png" alt=""></p><p>哨兵模式：<br>    解决的问题：主从集群不能自动进行故障恢复，一旦Master节点宕机，就只能人工干预<br>    哨兵的职责：<br>    监控： 监控主从集群里所有节点的状态，通过心跳机制进行监控<br>                哨兵会默认每秒向所有的节点发心跳，如果一个哨兵向某个节点的心跳，就会认为节点是“主观下线”<br>                如果超过指定数量的哨兵，都认为一个节点是“主观下线”，就认为这个节点是“客观下线”<br>    故障恢复：重新选举一个节点成为Master，承担写操作的职责<br>            如果某个Slave与原Master断开连接的时间超过指定时间，就直接剔除选举的资格<br>            哪个Slave的priority值越小，优先级越高。如果值是0，说明不参与选举<br>            哪个Slave的offset值越大，优先级越高。<br>            哪个Slave的replid越小，优先级越高</p><p>使用哨兵机制可以提高Redis的高可用性和可靠性，确保Redis集群在节点故障或其他变化时能够自动进行故障转移和恢复。客户端可以通过连接到哨兵节点，获取正确的Redis节点信息，并保持与Redis集群的稳定连接。</p><p>需要注意的是，哨兵机制并不是分布式存储方案，它只实现了高可用性和故障转移，不提供数据分片的功能。如果需要实现数据分片和水平扩展，可以使用Redis集群（Redis Cluster）来实现。</p><blockquote><p>Redis的哨兵集群主要用于实现高可用性，监控Redis主、从节点的状态变化，并在主节点失效时自动将从节点升级为主节点。哨兵集群由多个哨兵节点组成，工作原理是哨兵节点通过相互通信，监测主节点的健康状态，当主节点失效时，选举新的主节点，并通知其他从节点进行切换，确保系统的可用性。</p></blockquote><h1 id="七、Redis的分片集群（Redis-Cluster）"><a href="#七、Redis的分片集群（Redis-Cluster）" class="headerlink" title="七、Redis的分片集群（Redis Cluster）"></a>七、Redis的分片集群（Redis Cluster）</h1><p>Redis分片集群是一种将数据分布到多个节点的解决方案，用于实现数据的水平扩展和提高系统的吞吐量。</p><p><img src="https://bu.dusays.com/2023/10/25/653926c4711f8.png" alt=""></p><p><strong>分片集群：主从+哨兵，还存在问题：</strong></p><p>高并发的问题。主从集群里只有一个 Master能够提供写的服务，写操作的并发是有限的，海量的数据存储的问题，主从集群所有的节点的数据是相同的，如果数据量过多就得使用分片集群来解决这个问题</p><p><strong>分片集群的特点：</strong></p><p>可以有多个Master,每个Master存储的数据不同，增加了数据存储量。每个Master可以有多个Slave。</p><p>Master之间互相心跳来实现健康监测，进行自动故障恢复。连接任意一个Master时，如果要存储的数据不在这个节点上，会帮我们重定向到正确的节点上再操作。</p><p><strong>数据存储的方式：散列插槽（hash插槽）</strong>    </p><p>哈希槽是一个固定数量的槽，总共槽位数量16384个，每个数据被映射到其中一个槽上。每个节点负责管理一部分槽和相应的数据。</p><p>当需要存取数据时：会根据key计算Hash值，如果key中包含{}，就根据{}里内容进行CRC16算法的计算，得到hash值。</p><p>如果key里没有{}，就根据整个key的内容进行CRC16算法的计算，得到hash值。判断一下归哪个Master管理，就重定向到哪个Master上，在对应的节点上执行操作</p><p><strong>集群的伸缩：</strong></p><p>因为所有数据都和节点不直接绑定，而是与hash插槽绑定的。所以如果增加新节点：只要把一部分hash插槽转换到新节点上即可，如果想要减少节点：先把节点上的hash插槽转移出来，再把节点从集群里剔除即可。</p><p><strong>故障恢复：</strong></p><p>自动故障恢复：某个Master节点宕机，整个集群会自动从它的Slave里挑选一个节点成为Master</p><p>手动故障恢复：执行命令 cluster failover，就可以把这个节点设置为Master节点</p><h2 id="读写数据时是如何定位哈希槽"><a href="#读写数据时是如何定位哈希槽" class="headerlink" title="读写数据时是如何定位哈希槽?"></a>读写数据时是如何定位哈希槽?</h2><p>在Redis分片集群中，确切的说法是使用CRC16算法计算Key的哈希值，而不是定位哈希槽。</p><p>CRC16算法（循环冗余校验算法）是一种广泛应用于网络通信和数据校验领域的哈希算法，用于计算Key的哈希值。</p><p><strong>举例说明：</strong></p><p>假设有一个包含三个节点的Redis分片集群，节点A、节点B和节点C。每个节点负责存储哈希槽的范围如下：</p><p>- 节点A：0-5499</p><p>- 节点B：5500-10999</p><p>- 节点C：11000-16383</p><p>现在有一个Key为”example_key”需要进行操作。</p><ol><li><p>使用CRC16算法计算”example_key”的哈希值，例如为12345。</p></li><li><p>将哈希值对16384（2^14）求余，得到计算结果为12345 % 16384 = 12345。</p></li><li><p>根据计算结果12345，确定该数据应该存储在节点C的哈希槽11000-16383范围内。</p></li><li><p>客户端将数据写入节点C，或者从节点C读取相关数据。</p></li></ol><p>通过CRC16算法计算Key的哈希值，可以得到一个范围在0到16383的整数值，然后根据这个哈希值确定数据所对应的哈希槽范围，进而确定数据的存储位置。</p><blockquote><p>总结：Redis的分片集群主要用于实现数据的横向扩展，将数据分散存储在多个节点上，提高系统的并发能力和存储能力。分片集群由多个节点组成，根据Key经过哈希算法映射到不同的节点上，每个节点负责存储和处理一部分数据，工作原理是通过一致性哈希算法将数据按照一定规则分配到不同的节点上，实现数据的均衡存储和查询。</p></blockquote><h1 id="八、Redis分布式锁命令使用"><a href="#八、Redis分布式锁命令使用" class="headerlink" title="八、Redis分布式锁命令使用"></a>八、Redis分布式锁命令使用</h1><p>可以使用分布式锁来实现多个客户端之间的协调和同步，以避免并发操作引起的数据冲突。下面是使用Redis实现分布式锁的一般步骤：</p><p><strong>1.获取锁：</strong></p><ul><li>使用SET命令尝试在指定的键上设置一个唯一的值作为锁。</li><li>设置键的超时时间，以防止获取锁后出现异常导致锁一直被占用（避免死锁）。</li></ul><p>SET命令常用的选项是：</p><ul><li>NX：仅在键不存在时设置键的值，用于确保只有一个客户端能够成功设置锁。</li><li>PX：设置键的过期时间，用于防止锁被长时间占用。</li></ul><blockquote><p>注意：SETNX命令也可以获取锁，但还得执行其他命令设置过期时间，不如SET一条命令搞定：<br>例如，SET lock_key value PX 10000 NX 会将名为lock_key的锁设置为在10秒后过期。</p></blockquote><p><strong>2.释放锁：</strong></p><ul><li>使用DEL命令删除键来释放锁。</li><li>确保只有锁的持有者能够释放锁，可通过比较锁的值来进行验证。</li></ul><h2 id="示例演示："><a href="#示例演示：" class="headerlink" title="示例演示："></a>示例演示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            stock--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;秒杀失败！存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    placeOrder();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会导致：请看下图（￣︶￣）↗　</p><p><img src="https://bu.dusays.com/2023/10/26/653a8977e3867.png" alt=""></p><p>错了！为什么会这样呢？你猜！</p><ol><li><p>线程不安全：多个线程同时访问<code>placeOrder()</code>方法时，可能会出现竞态条件，导致库存数量不正确。例如，多个线程同时判断<code>stock &gt; 0</code>为true，然后都进入if语句块，最终导致库存减少了超过1个。</p></li><li><p>缺乏同步机制：没有使用任何同步机制来保证多个线程之间的互斥访问。因此，可能会出现多个线程同时修改库存的情况。</p></li><li><p>缺乏线程安全的库存操作：在<code>stock--</code>操作中，没有使用任何同步机制来保证原子性。多个线程可能同时执行<code>stock--</code>操作，导致库存减少超过1个。</p></li></ol><p>为了解决这些问题，李华又进行了改造，请看下回讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//加入同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (stock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                stock--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;秒杀失败！存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    placeOrder();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会导致：请看下图（￣︶￣）↗　</p><p><img src="https://bu.dusays.com/2023/10/26/653a8977ee877.png" alt=""></p><blockquote><p>哦~成功了，加了同步锁，可以保证安全了，但是随着用户量的提升，服务器的压力越来越大，你会怎么样怎么解决呢？</p><p>对！！！正是你想的那样可以通过Nginx的负载均衡将服务器进行水平扩展通过Nginx进行分布式集群部署，吞吐量确实上去了。</p><p>你以为解决了？错了，你会发现尽然又出现超卖了。</p><p>为什么会这样呢？其实是同步锁的问题，因为同步锁是JVM级别的，它只能锁住单个线程，但是经过分布式服务后，只能锁住一个线程。</p></blockquote><p>可以同过分布式锁进行结局：常见的分布式所有Redis和zookeeper，因为我之前署使用了Redis,可以采用Redis实现分布式锁。</p><p>通过Redis的setNX实现分布式锁：当A线程进来通过setNX的往某个键存储值，在这个键没有值的时候会返回一个true，当B线程进来的时候，会发现这个键已经存在值了，会返回一个false,通过这个特性就可以实现分布式锁，在此需要注意：</p><p>通过setNX进行上锁的时候需要设置一个过期时间，如果不设置会怎么样呢？</p><p>不设置用户在请求的时候这台服务器挂掉了，其他的服务器在发起请求时会发现一个阻塞的情况，因为其他服务器通过setNX进行上锁的时候会发现这键会一直存在值。这样就会造成<strong>死锁</strong>。</p><p>虽然这个问题解决了，但是其中还隐藏一些隐患，就是当处理这个业务的时间超过了这个锁的过期的时间，当这个锁失效以后，其他的线程会”趁虚而入”，当线程A处理完之后释放的可能是线程B的锁，那么其他的线程会在线程B的锁失效候继续”趁虚而入”，以此类推，又会出现超卖。</p><p><strong>上述情况中存在的两个问题：</strong></p><ol><li>当锁过期时线程还在处理业务</li><li>当处理完业务后释放的是其他线程的锁。</li></ol><p><strong>解决方案：</strong></p><ol><li>加长时间，并添加子线程每十秒确认线程是否在线，在线则将过期时间进行重置。</li><li>给锁加唯一的ID(UUID)</li></ol><p>此时Redisson出现了</p><p><img src="https://bu.dusays.com/2023/10/26/653a8978a9605.png" alt=""></p><p>这里会有一个面试题：如果使用了主从的集群模式，如果你主节点挂掉了会发生什么，怎么解决？</p><p>因为Redis是一个AP模式，只保证了高可用和高性能，并不能保证高一致性，当设置锁的时候，它只会往一个节点设置一个锁，设置完后立马返回并告诉你设置成功，内部会进行一个同步，此时如果你的主节点挂了，从节点没有进行同步，没办法获得该锁，依然会出现超卖的现象。</p><p>可以通过Redisson提供的RedLock来解决，RedLock会同步Redis当中所有的主从节点，它在保证所有的节点都存储完毕才会给你进行相应，这样就保证了强一致性。</p><h1 id="九、-Redis（或ElasticSearch）和MySQL如何保持数据一致性"><a href="#九、-Redis（或ElasticSearch）和MySQL如何保持数据一致性" class="headerlink" title="九、 Redis（或ElasticSearch）和MySQL如何保持数据一致性"></a>九、 Redis（或ElasticSearch）和MySQL如何保持数据一致性</h1><p>Redis（或ElasticSearch）和MySQL如何保持数据一致性，以及它们的具体实现和优缺点如下：</p><ol><li><strong>同步双写方案：</strong></li></ol><ul><li>实现方式：在应用程序中，将数据同时写入Redis（或ElasticSearch）和MySQL，确保两个写操作要么同时成功，要么同时失败。</li><li>优点：简单直接，实时性较高，不依赖额外组件。</li><li>缺点：增加了系统复杂性，需要处理并发写冲突，可能导致写入延迟增加。</li></ul><ol><li><strong>异步队列方案</strong>：</li></ol><ul><li>实现方式：将数据更新操作以消息的方式发送到消息队列中，并在消费者程序中分别更新Redis（或ElasticSearch）和MySQL。</li><li>优点：实现了数据解耦和异步处理，提高了系统的可伸缩性和稳定性。</li><li>缺点：增加了系统复杂性，引入了消息队列系统，可能会有一定的延迟，需要确保消息消费的可靠性。</li></ul><ol><li>Canal方案：</li></ol><ul><li>实现方式：使用Canal工具监听MySQL的binlog，将数据变更事件发送到Redis（或ElasticSearch）来更新数据。</li><li>优点：实时性较高，不需要修改应用程序代码，可以实现MySQL的逻辑解耦和数据的多重同步。</li><li>缺点：增加了系统复杂性，需要额外的Canal工具和客户端程序来处理数据同步，可能额外占用资源。</li></ul><p>双写模式简单直接，适用于数据实时性要求较高的场景。异步队列适用于要求解耦和异步处理的场景，但可能增加了系统复杂性和引入延迟。Canal方案适用于希望实现MySQL的逻辑解耦和多重数据同步的场景，但需要额外维护Canal工具和客户端程序。</p><blockquote><p>Elasticsearch和MySQL的数据一致性可以通过以下三种方案实现：</p><ol><li><p>双写：每次写入操作同时将数据写入Elasticsearch和MySQL，确保数据一致性，但可能增加写延迟和复杂性。</p></li><li><p>异步队列：将写入操作请求放入队列中，后台任务异步地将数据写入Elasticsearch和MySQL，提高写入性能，但可能导致一定的数据不一致性。</p></li><li>Canal方案：使用Canal工具订阅MySQL的binlog日志，实时将数据同步到Elasticsearch，实现数据的实时增量同步，但需要额外的工具和配置。</li></ol></blockquote><h1 id="十、Redisson是什么，怎么用"><a href="#十、Redisson是什么，怎么用" class="headerlink" title="十、Redisson是什么，怎么用"></a>十、Redisson是什么，怎么用</h1><p>Redisson是一个用于Java的简单易用的Redis客户端，它封装了常见的分布式操作和并发控制的功能，提供了丰富的API和功能，使得开发人员可以轻松地与Redis进行交互。</p><p>在Spring Boot中使用Redisson，需要进行以下步骤：</p><ol><li><strong>添加Redisson的依赖：</strong>在项目的构建文件（如pom.xml）中添加Redisson的依赖。可以通过Maven引入相应的依赖。</li></ol><ol><li><strong>配置Redisson连接信息：</strong>在Spring Boot的配置文件（如application.properties或application.yml）中配置Redisson的连接信息，包括Redis的主机地址、端口号、密码等。</li></ol><ol><li><strong>创建RedissonClient对象：</strong>可以通过自动注入或手动创建RedissonClient对象。如果使用自动注入，可以在配置类中添加@Bean注解将RedissonClient注入为Spring的Bean；如果手动创建，可以在需要的地方创建RedissonClient对象。</li></ol><ol><li><strong>使用Redisson功能：</strong>通过RedissonClient对象，可以使用Redisson提供的各种功能，如分布式锁、分布式集合、分布式队列等。根据具体需求，调用相应的方法来操作Redis。</li></ol><p>例如，使用Redisson的分布式锁，可以注入RedissonClient对象后调用getLock方法来获取锁对象，然后使用lock方法加锁，并在需要时执行相应的操作，最后使用unlock方法释放锁。</p><blockquote><p>总结：Redisson是一个Java的Redis客户端，提供丰富的API和功能，用于封装分布式操作和并发控制。在Spring Boot中使用Redisson，首先添加Redisson的依赖，然后在配置文件中配置Redisson连接信息，接着通过@Autowired注解或手动创建RedissonClient对象。最后，利用RedissonClient对象可以使用各种功能，如分布式锁、分布式集合等，与Redis进行交互。</p></blockquote><h1 id="十一、Redisson看门狗机制的原理"><a href="#十一、Redisson看门狗机制的原理" class="headerlink" title="十一、Redisson看门狗机制的原理"></a>十一、Redisson看门狗机制的原理</h1><ul><li>Redisson的看门狗机制是为了解决分布式环境下使用分布式锁时的问题。它通过周期性地对锁进行心跳续期，保证在业务执行期间锁不会被自动释放，防止因执行时间过长或节点宕机而导致锁提前释放的情况发生。</li><li>实现原理是在获取锁时，Redisson会使用一个独立的线程启动一个定时任务，定时更新锁的过期时间。同时，每个Redisson实例都会在Redis中生成一个唯一ID作为锁的标识，以避免其他实例错误地释放锁。</li><li>看门狗机制的目的是防止锁过期时间超时，而业务执行仍在进行中的情况发生。通过定时地续期锁的过期时间，确保锁在业务执行期间一直有效。这样可以避免获得锁的实例因为处理时间过长而导致锁过期被其他实例获取，保证分布式环境下的锁的可靠性。</li><li>续期与看门狗机制相关，通过定时续期，锁的过期时间会在业务执行期间不断更新，从而避免锁过期。一旦锁的续期失败，即续期任务运行失败或锁的标识不匹配，Redisson会立即释放该锁，以避免业务不再持有锁而导致的问题。</li><li>总结来说，Redisson的看门狗机制通过定时续期锁的过期时间，保证在业务执行期间锁不会被自动释放，解决了在分布式环境下使用分布式锁时锁过期的问题，提高了锁的可靠性和使用效果。</li></ul><blockquote><p>总结：Redisson的看门狗机制通过定时续期锁的过期时间，保证在业务执行期间锁不会被自动释放。它解决了分布式环境下锁过期导致的资源竞争问题，确保业务能够完成。续期是看门狗机制的核心，它通过定时更新锁的过期时间来实现锁的持久性，以防止锁过期并被其他实例获得。</p></blockquote><h1 id="注：Java如何使用Redis"><a href="#注：Java如何使用Redis" class="headerlink" title="注：Java如何使用Redis"></a>注：Java如何使用Redis</h1><p>第一步、引入Jedis依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>示例：写一个测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="string">&quot;192.168.200.128&quot;</span>,<span class="number">6379</span>);<span class="comment">//创建连接池</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();<span class="comment">//从连接池获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ping</span> <span class="operator">=</span> jedis.ping();<span class="comment">//测试链接</span></span><br><span class="line">        System.out.println(ping);<span class="comment">//如果成功连接上了Redis服务，此处将会输出PONG</span></span><br><span class="line">        jedis.close();<span class="comment">//释放资源，进行归还线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>();</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">        jedis.set(<span class="string">&quot;token&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;token&quot;</span> + jedis.get(<span class="string">&quot;token&quot;</span>));</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>假设当你在与Redis交互的时候，发生了异常，不论是你自身业务的异常，或者Redis服务器宕机了。这时候程序抛出异常，无法执行到归还连接的代码。久而久之，连接池中的连接数都被占用了，没有归还。当还有新的请求进来，而又没有连接可以使用了，这时候程序就会阻塞，直至卡死。</p><p>为了避免这种情况的发生，最直接的想法那便是加上<code>try-catch-final</code>，将<code>jedis.close()</code>释放资源的方法放到<code>final</code>的语句块内，这样子便可以在发生异常的情况下保证Jedis连接的归还。</p><p>下面演示了Java8的<code>try-with-resource</code>语法，它与<code>try-catch-final</code>语法相比较更简洁，但本质上其实是语法糖，实际在解析成字节码过程中，它依然会被还原成<code>try-catch-final</code>的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>();</span><br><span class="line">     <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource())&#123;</span><br><span class="line">         <span class="comment">//Redis相关业务...</span></span><br><span class="line">         jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Johnny&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>虽然这样使用Redis，避免了连接数耗光的风险，但是在所有需要使用Redis的地方都要加上这样的语法限制，显然这存在着大量的重复，同时你需要依靠人为的规范限制来保护程序并不太靠谱。考虑当你的开发团队进来一个新人，可能就会在某个地方忘记使用<code>try-with-resource</code>，而这样就存在问题的隐患。</p><p>我们需要从程序上就形成使用规范上的限制。</p><h2 id="规范的使用姿势"><a href="#规范的使用姿势" class="headerlink" title="规范的使用姿势"></a><strong>规范的使用姿势</strong></h2><p>我们需要一个接口和自己封装的连接池使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallJedis</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Jedis jedis)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//自己封装一个可以安全使用的连接池</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedisPool</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line">     <span class="comment">//实例化连接池</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">MyRedisPool</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取Redis连接资源，并确保在使用后归还</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(CallJedis caller)</span>&#123;</span><br><span class="line">         <span class="keyword">try</span>(<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource())&#123;</span><br><span class="line">             caller.call(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//这样子我们就可以安全的使用Redis啦</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//实例化连接池</span></span><br><span class="line">     <span class="type">MyRedisPool</span> <span class="variable">myRedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRedisPool</span>();</span><br><span class="line">     <span class="comment">//获取Redis连接资源，并确保在使用后归还</span></span><br><span class="line">     myRedisPool.execute(<span class="keyword">new</span> <span class="title class_">CallJedis</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">             <span class="comment">//执行Redis相关业务...</span></span><br><span class="line">             jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Johnny&quot;</span>);</span><br><span class="line">             System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">这样子，我们通过自己封装的Jedis连接池来获取并归还连接，避免了自己获取连接然后忘记归还的情况。但是每次使用都需要提供一个回调类来执行Redis代码，略显麻烦。这同样可以使用Java8提供的新特性Lambda表达式来简化代码，如下</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">MyRedisPool</span> <span class="variable">myRedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRedisPool</span>();</span><br><span class="line">     myRedisPool.execute(jedis -&gt; &#123;</span><br><span class="line">         <span class="comment">//Redis相关业务...</span></span><br><span class="line">         jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Johnny&quot;</span>);</span><br><span class="line">         Systrem.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="操作String数据类型"><a href="#操作String数据类型" class="headerlink" title="操作String数据类型"></a><strong>操作String数据类型</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除当前选择数据库中的所有key</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 redis 字符串数据</span></span><br><span class="line">    <span class="comment">//新增&lt;&#x27;name&#x27;,&#x27;yixin&#x27;&gt;的键值对</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;huhu&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">    System.out.println(<span class="string">&quot;redis 存储的字符串为: &quot;</span>+ jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断某个键是否存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;redis 存储的字符串是否存在：&quot;</span> + jedis.exists(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统中所有的键</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    System.out.println(keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按索引查询</span></span><br><span class="line">    System.out.println(<span class="string">&quot;按索引查询:&quot;</span>+ jedis.select(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看键name所存储的值的类型</span></span><br><span class="line">    System.out.println(jedis.type(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机返回key空间的一个</span></span><br><span class="line">    System.out.println(jedis.randomKey());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重命名key</span></span><br><span class="line">    System.out.println(jedis.rename(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;取出改后的name:&quot;</span> + jedis.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除键username</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除username:&quot;</span> + jedis.del(<span class="string">&quot;username&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除当前选择数据库中的所有key</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当前库中所有的key的数目</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据库中的所有key</span></span><br><span class="line">    <span class="comment">//System.out.println(&quot;删除数据库中的所有key:&quot; + jedis.flushAll());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作List数据类型"><a href="#操作List数据类型" class="headerlink" title="操作List数据类型"></a>操作List数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//List实例</span></span><br><span class="line">        <span class="comment">//存储数据到列表中</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;list&quot;</span>, <span class="string">&quot;num1&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list&quot;</span>, <span class="string">&quot;num2&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list&quot;</span>, <span class="string">&quot;num3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取存储的数据并输出</span></span><br><span class="line">        List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;list&quot;</span>, <span class="number">0</span> ,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;列表项为: &quot;</span>+list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>操作事务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//连接本地的 Redis 服务</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//事务测试</span></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;yixin&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 代码抛出异常事务，执行失败！</span></span><br><span class="line">            multi.exec(); <span class="comment">// 执行事务！</span></span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();<span class="comment">// 放弃事务</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、SpringBoot集成Redis"><a href="#二、SpringBoot集成Redis" class="headerlink" title="二、SpringBoot集成Redis"></a>二、SpringBoot集成Redis</h2><p><strong>介绍</strong></p><blockquote><p>这次我们并不使用jedis来进行连接，而是使用lettuce来进行连接，jedis和lettuce的对比如下：</p><p>jedis：采用的直连，多个线程操作的话，是不安全的；想要避免不安全，使用jedis pool连接池。更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况；可以减少线程数量。更像NIO模式</p></blockquote><h3 id="2-1-创建SpringBoot-项目"><a href="#2-1-创建SpringBoot-项目" class="headerlink" title="2.1 创建SpringBoot 项目"></a>2.1 创建SpringBoot 项目</h3><h3 id="2-1-1导入依赖"><a href="#2-1-1导入依赖" class="headerlink" title="2.1.1导入依赖"></a>2.1.1导入依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-编写配置文件"><a href="#2-2-编写配置文件" class="headerlink" title="2.2 编写配置文件"></a>2.2 <strong>编写配置文件</strong></h3><p><strong>application.properties:</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置redis</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379  </span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接 默认 8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接 默认 0</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>application.yml:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># redis数据库索引(默认为0)，我们使用索引为3的数据库，避免和其他数据库冲突</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># redis服务器地址（默认为loaclhost）</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">loaclhost</span></span><br><span class="line">    <span class="comment"># redis端口（默认为6379）</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># redis访问密码（默认为空）</span></span><br><span class="line">    <span class="comment">#  password:</span></span><br><span class="line">    <span class="comment"># redis连接超时时间（单位毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># redis连接池配置</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="comment"># 最大可用连接数（默认为8，负数表示无限）</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">      <span class="comment"># 最大空闲连接数（默认为8，负数表示无限）</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">      <span class="comment"># 最小空闲连接数（默认为0，该值只有为正数才有用）</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># 从连接池中获取连接最大等待时间（默认为-1，单位为毫秒，负数表示无限）</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="3-1编写测试"><a href="#3-1编写测试" class="headerlink" title="3.1编写测试"></a>3.1编写测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">       redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;huhu&quot;</span>);</span><br><span class="line">       System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种连接方式中，redisTemplate操作着不同的数据类型，api和我们的指令是一样的。</p><p>opsForValue：操作字符串 类似String</p><p>opsForList：操作List 类似List</p><p>opsForSet：操作Set，类似Set</p><p>opsForHash：操作Hash</p><p>opsForZSet：操作ZSet</p><p>opsForGeo：操作Geospatial</p><p>opsForHyperLogLog:操作HyperLogLog</p><p>除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD。</p></blockquote><p>3.2 保存对象</p><p>（1）<strong>编写实体类</strong></p><blockquote><p><strong>注意：要实现序列号Serializable</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（2）编写RedsTemplate配置</strong></p><p><font color=#ffff>Tip:</font>在开发当中，我们可以直接把这个模板拿去使用。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存储对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;huhu&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解决以下两个问题：</p><ol><li>如何增加Redis重试机制，有时候当网络波动时，并不是每条Redis指令都能确保执行成功。当遇到执行失败的Redis命令，如何让他再执行一次呢？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">在Java中可以通过使用Redisson库来增加Redis重试机制。Redisson是一个基于Redis的Java驻留内存数据网格（In-Memory Data Grid）和分布式锁服务。它提供了一种简单的方式来处理Redis命令的重试。</span><br><span class="line"></span><br><span class="line">下面是一个使用Redisson实现Redis重试机制的示例代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RFuture;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RMap;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisRetryExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redisson客户端</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Redis Map对象</span></span><br><span class="line">        RMap&lt;String, String&gt; map = redisson.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置重试次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRetries</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行Redis命令</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxRetries; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RFuture&lt;Boolean&gt; future = map.fastPutAsync(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">                success = future.await();</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Redisson客户端</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理执行结果</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Redis命令已成功执行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重试后 Redis 命令失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在上述示例中，我们使用Redisson创建了一个RedissonClient对象，并通过它来执行Redis命令。在执行命令时，我们使用了`fastPutAsync`方法来异步执行Redis的`SET`命令，并使用`await`方法等待命令执行结果。</span><br><span class="line"></span><br><span class="line">如果命令执行成功，则跳出循环；如果命令执行失败，则继续进行重试。在重试过程中，可以根据实际需求进行异常处理或者记录日志。最后，根据重试结果来处理执行成功或失败的情况。</span><br><span class="line"></span><br><span class="line">需要注意的是，重试机制并不能保证<span class="number">100</span>%的命令执行成功，但可以提高命令执行成功的概率。在实际应用中，可以根据具体情况来设置重试次数和重试间隔，以达到最佳的重试效果。</span><br></pre></td></tr></table></figure><ol><li>我们知道Lambda表达式内是闭包的，而这意味着无法在里面修改闭包外面的变量，假设当我们需要在闭包外获取Redis中某个List的长度，而当我们在闭包内执行完Redis获取List长度的命令后，并无法将这个变量传递到闭包外，这时候该怎么办？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在Java中，Lambda表达式内是可以访问外部的<span class="keyword">final</span>或effectively <span class="keyword">final</span>变量的，但是无法修改它们的值。如果需要在闭包外部获取Redis中某个List的长度，可以使用一个包装类或者数组来存储这个长度值，并将它声明为<span class="keyword">final</span>或effectively <span class="keyword">final</span>变量。</span><br><span class="line"></span><br><span class="line">例如，可以创建一个长度为<span class="number">1</span>的数组来存储List的长度值：</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] length = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在闭包内获取Redis中List的长度，并将结果存储到数组中</span></span><br><span class="line">redisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">    length[<span class="number">0</span>] = connection.lLen(<span class="string">&quot;listKey&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在闭包外部可以访问length[0]获取List的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">listLength</span> <span class="operator">=</span> length[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">另外，如果使用的是Java <span class="number">8</span>及以上版本，也可以使用AtomicInteger类来存储长度值，它提供了原子操作保证线程安全：</span><br><span class="line"></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">length</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在闭包内获取Redis中List的长度，并将结果存储到AtomicInteger中</span></span><br><span class="line">redisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">    length.set(connection.lLen(<span class="string">&quot;listKey&quot;</span>).intValue());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在闭包外部可以通过length.get()获取List的长度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">listLength</span> <span class="operator">=</span> length.get();</span><br><span class="line"></span><br><span class="line">通过以上方式，可以在闭包外部获取到Redis中List的长度值。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h1 id=&quot;一、Redis为什么快&quot;&gt;&lt;a href=&quot;#一、Redis为什么快&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="面试题" scheme="https://blog.haodene.love/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://blog.haodene.love/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.haodene.love/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-28T08:30:00.000Z</published>
    <updated>2023-10-19T15:11:40.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="一、单例模式的几种写法"><a href="#一、单例模式的几种写法" class="headerlink" title="一、单例模式的几种写法"></a>一、单例模式的几种写法</h2><p>懒加载-懒汉模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singletoninstance; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>) &#123; <span class="comment">//第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="literal">null</span>) &#123; <span class="comment">//第二次检查</span></span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，使用<font color=red>双重检查锁</font>实现了线程安全的单例模式。getInstance()方法首先检查instance是否为null，如果为null，则进入同步块。在同步块内部，再次检查instance是否为null，这是为了防止多个线程同时通过了第一次检查，然后一个线程创建了实例，而另一个线程又创建了一个实例的情况发生。使用双重检查锁可以在保证线程安全的前提下，减少锁的竞争，提高性能。但需要注意的是，使用双重检查锁需要将instance声明为volatile类型，以确保多线程环境下的可见性。</p></blockquote><h2 id="二、预加载-饿汉模式"><a href="#二、预加载-饿汉模式" class="headerlink" title="二、预加载-饿汉模式"></a>二、预加载-饿汉模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、静态内部类模式"><a href="#三、静态内部类模式" class="headerlink" title="三、静态内部类模式"></a>三、静态内部类模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static Singleton instance=new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 枚举模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 单例实例</span><br><span class="line">     */</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void doSomeThing()&#123;</span><br><span class="line">        System.out.println(&quot;done&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单元素的枚举类型是实现 Singleton 的最佳方法</p></blockquote><h1 id="二、Spring中的设计模式有哪些"><a href="#二、Spring中的设计模式有哪些" class="headerlink" title="二、Spring中的设计模式有哪些"></a>二、Spring中的设计模式有哪些</h1><ul><li><strong>工厂模式：</strong> Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对 象。</li><li><strong>单例模式：</strong> Spring中的bean默认都是单例的。</li><li><strong>代理模式：</strong>Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li></ul><h2 id="三、MyBatis中有哪些设计模式"><a href="#三、MyBatis中有哪些设计模式" class="headerlink" title="三、MyBatis中有哪些设计模式"></a>三、MyBatis中有哪些设计模式</h2><ul><li>工厂模式：例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式：例如ErrorContext和LogFactory；</li><li>代理模式：Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;一、单例模式的几种写法&quot;&gt;&lt;a href=&quot;#一、单例模式的几种写法&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="面试题" scheme="https://blog.haodene.love/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程和锁</title>
    <link href="https://blog.haodene.love/2023/07/25/%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/"/>
    <id>https://blog.haodene.love/2023/07/25/%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81/</id>
    <published>2023-07-25T08:30:00.000Z</published>
    <updated>2023-10-19T15:09:59.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h1><h1 id="一、线程的状态"><a href="#一、线程的状态" class="headerlink" title="一、线程的状态"></a>一、线程的状态</h1><p>在java中，线程的状态可以通过Tread类中getState()方法进行获取。以下是Java开发中常见的线程状态：</p><p><strong>1、New（新建）:</strong> 线程创建但未被启动。</p><p><strong>2、RUNNABLE（可运行）：</strong>线程可以在任意时刻运行。处于这个状态的线程可能正在运行，也可能正在等待CPU分配时间片。</p><p><strong>3、BLOCKED（阻塞）：</strong>线程被阻止执行，因为它正在等待监视器锁定。其他线程正在占用所需的锁定，因此线程被阻塞。</p><p><strong>4、WAITING（等待）：</strong>线程进入等待状态，直到其他线程显式地唤醒它。线程可以调用Object类的wait()方法、join()方法或Lock类的条件等待方法进入此状态。</p><p><strong>5、TIMED_WAITING（计时等待）：</strong>线程进入计时等待状态，等待一段指定的时间。线程可以调用Thread.sleep()方法、Object类的wait()方法、join()方法或Lock类的计时等待方法进入此状态。</p><p><strong>6、TERMINATED（终止）：</strong>线程完成了其任务，或者因为异常或其他原因而终止运行。</p><p>以上是Java开发中线程的常见状态。线程可以根据业务逻辑和操作系统的调度来在不同状态之间转换。了解线程状态对于编写并发程序和调试多线程应用程序非常重要。</p><p class="note note-info">总结：线程的状态包括：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、等待（Waiting）、超时等待（Timed Waiting）、终止（Terminated）。</p><h1 id="二、创建线程的方式"><a href="#二、创建线程的方式" class="headerlink" title="二、创建线程的方式"></a>二、创建线程的方式</h1><p>在Java中，创建线程有以下几种方式：</p><ol><li><strong>继承Thread类:</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个继承自Thread类的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程实例，并启动线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>实现Runnable接口：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个实现Runnable接口的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程实例，并启动线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用匿名内部类：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 线程执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用Lambda表达式:</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; System.out.println(&quot;Thread running&quot;));</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是Java中创建线程的常见方式，你可以根据具体需求选择合适的方式来创建线程。</p><h1 id="三、线程池的核心线程数"><a href="#三、线程池的核心线程数" class="headerlink" title="三、线程池的核心线程数"></a>三、线程池的核心线程数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                        TimeUnit unit,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                        RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong> =&gt; 线程池核心线程数量</li><li><strong>maximumPoolSize</strong> =&gt; 线程池最大数量（包含核心线程数量）</li><li><strong>keepAliveTime</strong> =&gt; 当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li><strong>unit</strong> =&gt; keepAliveTime 的单位</li><li><strong>workQueue</strong> =&gt; 线程池所使用的缓冲队列，被提交但尚未被执行的任务</li><li><strong>threadFactory</strong> =&gt; 线程工厂，用于创建线程，一般用默认的即可</li><li><strong>handler</strong> =&gt; 拒绝策略，当任务太多来不及处理，如何拒绝任务</li></ul><h1 id="四、如何创建线程池"><a href="#四、如何创建线程池" class="headerlink" title="四、如何创建线程池"></a>四、如何创建线程池</h1><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下： </p><ol><li><strong>FixedThreadPool 和 SingleThreadPool：</strong> 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool：</strong> 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ol><ul><li><strong>创建线程的方式一：</strong>new TreadPoolExecutor 方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>, TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    executorService.execute(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始办理业务了。。。。。。&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>创建线程池方式二：</strong>spring的ThreadPoolTaskExecutor方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecturConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(&quot;taskExector&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Executor <span class="title function_">taskExector</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line"></span><br><span class="line">    executor.setCorePoolSize(<span class="number">3</span>);<span class="comment">//核心池大小</span></span><br><span class="line"></span><br><span class="line">    executor.setMaxPoolSize(<span class="number">5</span>);<span class="comment">//最大线程数</span></span><br><span class="line"></span><br><span class="line">    executor.setQueueCapacity(<span class="number">3</span>);<span class="comment">//队列长度</span></span><br><span class="line"></span><br><span class="line">    executor.setKeepAliveSeconds(<span class="number">10</span>);<span class="comment">//线程空闲时间</span></span><br><span class="line"></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;tsak-asyn&quot;</span>);<span class="comment">//线程前缀名称</span></span><br><span class="line"></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="comment">//配置拒绝策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程池的注意事项"><a href="#创建线程池的注意事项" class="headerlink" title="创建线程池的注意事项:"></a>创建线程池的注意事项:</h2><p><strong>1.</strong> <strong>线程池的大小：</strong>线程池的大小应根据任务的类型和系统资源进行合理的配置。如果线程池的大小过小，可能会导致任务排队等待执行，影响系统的响应性能；如果线程池的大小过大，可能会占用过多的系统资源，导致系统负载过重。可以通过监控和调整线程池的大小来优化性能。</p><p><strong>2.</strong> <strong>任务队列的选择：</strong>线程池通常会使用一个任务队列来保存待执行的任务。任务队列的选择应根据任务的特性进行合理的选择。如果任务较多且执行时间较短，可以选择无界队列（如LinkedBlockingQueue）；如果任务较少且执行时间较长，可以选择有界队列（如ArrayBlockingQueue）或者优先级队列（如PriorityBlockingQueue）。</p><p><strong>3.</strong> <strong>线程池的拒绝策略：</strong>当任务无法被线程池接收执行时，需要定义适当的拒绝策略。常见的拒绝策略有：抛出异常（AbortPolicy）、丢弃任务（DiscardPolicy）、丢弃最早的任务（DiscardOldestPolicy）和调用者运行任务（CallerRunsPolicy）。根据业务需求选择合适的拒绝策略。</p><p><strong>4.</strong> <strong>线程池的生命周期管理：</strong>线程池的生命周期包括初始化、执行任务和关闭。在初始化时，需要设置线程池的参数；在执行任务时，需要提交任务到线程池；在关闭时，需要调用线程池的shutdown()或shutdownNow()方法来关闭线程池，并等待所有任务完成。正确地管理线程池的生命周期可以避免资源泄漏和线程阻塞的问题。</p><p><strong>5.</strong> <strong>线程安全性：</strong>在自定义线程池时，需要考虑线程安全性。多个任务并发执行时，可能会涉及到共享资源的访问，需要使用合适的同步机制来保证线程安全。</p><p>总之，自定义线程池需要合理配置线程池的大小、选择适当的任务队列和拒绝策略，正确管理线程池的生命周期，并考虑线程安全性。这些注意事项可以帮助我们设计高效、可靠的线程池。</p><h1 id="五、线程池的工作原理"><a href="#五、线程池的工作原理" class="headerlink" title="五、线程池的工作原理"></a>五、线程池的工作原理</h1><p>线程池在刚创建的时候并没有线程，任务队列是通过作为参数传进来的，不过，就算队列里有任务也立马去执行任务。</p><p>当调用execute()方法添加一个任务的时候，线程池会做出如下判断：</p><ul><li>如果正在运行线程的数量小于corePoolSize，那么马上创建线程池来运行这个任务；</li><li>如果正在运行的线程池数量大于或等于corePoolSize，那么将会放入任务队列；</li><li>如果这个时候队列满了，而且正在运行的线程数量小于maximumPooSize，那么还是要创建非核心线程来立刻执行这个任务；</li><li>如果队列满了，而且正在执行的线程数量大于或等于maximumPoolSize 那么线程池会抛出异常 RejectException</li></ul><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h1 id="六、线程池大小如何设定"><a href="#六、线程池大小如何设定" class="headerlink" title="六、线程池大小如何设定"></a>六、线程池大小如何设定</h1><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。线程池的数量应该综合考虑CPU核心数、并发请求数量、任务类型和任务队列容量等因素。根据具体情况进行调试和压测，逐步调整线程池大小，以找到最佳配置，以提高系统性能和资源利用率。</p><p><strong>有一个简单并且适用面比较广的公式：</strong></p><p><strong>CPU 密集型任务(N+1)：</strong>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><p>如果是 CPU 密集型的，可以把核心线程数设置为核心数+1。</p><p>如果是 IO 密集型的，可以把核心线程数设置 2*CPU 核心数</p><p class="note note-info">   总结： 生产环境中，Java线程池大小的设定与硬件资源和并发需求密切相关。通常可以考虑CPU核心数、内存容量、网络带宽等硬件资源，并结合预估的并发请求量来确定线程池大小，以充分利用资源并保持合理的并发处理能力。较多的硬件资源和高并发通常需要更大的线程池来提高并发处理效率。</p><h1 id="七、线程池的拒绝策略"><a href="#七、线程池的拒绝策略" class="headerlink" title="七、线程池的拒绝策略"></a>七、线程池的拒绝策略</h1><div class="table-container"><table><thead><tr><th></th><th>默认(AbortPollcy)</th><th>丢弃任务</th><th>丢弃最早的任务</th><th>抛出异常</th><th>调用者运行</th></tr></thead><tbody><tr><td>特点</td><td>默认拒绝，直接抛出RejectExecutionExeception异常</td><td>直接丢弃无法处理的问题</td><td>丢弃线程池中最早的任务</td><td>抛出RejectedExecutionException异常</td><td>由提交任务的线程执行任务</td></tr><tr><td>适用场景</td><td>默认选项，适用于大部分情况</td><td>不必关心无法处理的任务</td><td>对新任务优先级不高,且无法处理时，可以丢弃一部分旧的任务</td><td>需要明确的知道任务被拒绝的情况</td><td>可以处理任务线程较快，任务不会对线程造成太大的影响</td></tr><tr><td>示例代码</td><td>ThreadPoolExceutor. AborPolicy</td><td>ThreadPoolExcecutor. DiscardOldesPolicy</td><td>ThreadPoolExcecutor. AbortPolicy</td><td>ThreadPoolExcecutor. AbortPolicy</td><td>ThreadPoolExcecutor. CallerRunsPolicy</td></tr></tbody></table></div><p>以上列出的是Java线程池中常见的拒绝策略，具体可以根据实际情况选择合适的拒绝策略，也可以自定义实现RejectedExecutionHandler接口来定义自己的拒绝策略。默认的拒绝策略是AbortPolicy，即直接抛出异常。</p><blockquote><p>线程池的拒绝策略有四种：AbortPolicy（默认方式，中止并抛出RejectedExecutionException异常）、CallerRunsPolicy（使用调用线程来执行被拒绝的任务）、DiscardPolicy（默默地丢弃被拒绝的任务）以及DiscardOldestPolicy（丢弃最早被添加到队列的任务，然后尝试重新提交新任务）。。如果希望快速失败并将异常传递给调用者，则选择AbortPolicy。如果希望尽可能保证任务的执行而不堆积在队列中，则选择CallerRunsPolicy。如果对任务的丢失情况不敏感，则选择DiscardPolicy。而如果希望尽可能保留最新的任务而不是旧的任务，则选择DiscardOldestPolicy。</p></blockquote><h1 id="八、synchronized-和-lock-的区别"><a href="#八、synchronized-和-lock-的区别" class="headerlink" title="八、synchronized 和 lock 的区别"></a>八、synchronized 和 lock 的区别</h1><div class="table-container"><table><thead><tr><th></th><th>synchronized</th><th>lock</th></tr></thead><tbody><tr><td>机制和灵活性</td><td>是Java内置的关键字，是内置语言的同步机制</td><td>接口，提供了更多的灵活的同步机制</td></tr><tr><td>范围</td><td>修饰的方法或代码块，可以实现整个方法或代码时自动获取锁</td><td>通过lock()和unlock()方法手动夺取锁和释放后锁</td></tr><tr><td>底层实现原理</td><td>基于Jvm的内置监视锁机(monitor)制实现的</td><td>可以有多种底层实现，如ReentrantLock,StampedLock等</td></tr><tr><td>获取锁的方式</td><td>隐式的获取锁，在synchronized方法或代码块时自动获取锁</td><td>显式获取锁，需要手动调用lock()方法获取锁，然后在合适的时候进行释放锁</td></tr><tr><td>性能</td><td>在低竞争环境下性能较好，有底层优化机制（偏向锁等）</td><td>在该竞争的环境下性能较好,提供了更多的选项</td></tr></tbody></table></div><blockquote><p>总结：<strong>synchronized</strong>的是Java提供的关键字，是内置的同步机制，能够修饰方法和代码块，底层实现原理是基于Jvm的内置监锁机制；而lock是一个接口，提供了更加灵活的同步机制,可以手动的获取锁和释放锁，底层实现可以是ReentrantLock等，性能在高竞争环境下通常较好。</p></blockquote><h1 id="九、什么情况下会产生死锁、如何解决"><a href="#九、什么情况下会产生死锁、如何解决" class="headerlink" title="九、什么情况下会产生死锁、如何解决"></a>九、什么情况下会产生死锁、如何解决</h1><p>死锁是多线程编程中常见的问题，当多个线程相互等待对方释放资源时，就可能导致死锁的发生。通常情况下，死锁发生的四个必要条件是：互斥条件、请求与保持条件、不可剥夺条件和循环等待条件。</p><p>产生死锁的情况：</p><ul><li>互斥条件：如果多个线程按照不同的顺序释放锁，并且互相依赖对方释放的锁，就可能造成死锁；</li><li>资源竞争问题：当多个线程同时竞争有限的资源，例如共享的数据库连接、文件等，在资源分配不当的情况下，可能导致死锁；</li><li>不可剥夺条件：资源只有由占有它的线程进行主动释放，不能被其他线程强行的剥夺；</li><li>循环等待条件：存在一个进程或线程的资源等待链，使得每个进程或线程都在等待下一个资源。</li></ul><p><strong><em>\</em>解决死锁方法：**</strong></p><p>\1. 避免使用嵌套锁：尽量避免在一个锁内部再次申请其他锁资源，减少死锁可能性。</p><ol><li><p>统一锁申请顺序：对于需要多个锁的场景，确保所有线程以相同的顺序请求锁，避免出现循环等待的情况。</p></li><li><p>加锁超时或自动释放：在申请锁时，设置一个等待时间或使用可重入锁，并且设置超时时间，避免线程长时间等待而导致死锁。同时，在使用完锁后，及时释放资源，避免持有锁时间过长。</p></li><li><p>死锁检测和恢复：通过死锁检测算法，定期检测系统中的死锁情况，并尝试解决死锁，然后恢复运行。</p></li><li><p>资源分配策略优化：评估和优化资源的分配策略，避免资源竞争和瓶颈情况的发生。</p></li><li><p>避免长时间持有锁：在代码设计中，尽量减少需要锁的代码块，避免长时间持有锁，减少死锁的机会。可以使用并发集合或并发算法来减少对锁的需求。</p></li></ol><p>总的来说，解决死锁问题需要注意锁的申请顺序、资源分配策略、超时设置等，通过优化设计和避免资源竞争，可以减少死锁的可能性。在发生死锁时，通过死锁检测和恢复等方法解决死锁问题。</p><blockquote><p>总结：产生死锁的情况是在多线程程序中，每个线程都持有一些资源，并且等待其他线程释放它所需的资源。解决死锁可采取以下方法：避免死锁的发生，通过破坏死锁产生的四个必要条件之一来预防；检测死锁，使用算法检测出是否存在死锁，并采取相应的措施解除死锁；恢复死锁，即进行资源的强制抢占或进行回滚操作，将进程回退到安全状态以解除死锁。</p></blockquote><h1 id="十、ThreadLocal是一个什么样的技术"><a href="#十、ThreadLocal是一个什么样的技术" class="headerlink" title="十、ThreadLocal是一个什么样的技术"></a>十、ThreadLocal是一个什么样的技术</h1><p><strong>ThreadLocal的实现原理：</strong></p><p>ThreadLocal通过在每个线程中维护一个ThreadLocalMap对象来实现线程隔离。ThreadLocalMap以ThreadLocal对象作为键，线程私有的变量副本作为值。每个线程都有自己的ThreadLocalMap，线程可以通过ThreadLocal的get()和set()方法来获取和设置自己线程的ThreadLocal变量的值。</p><p><strong>应用场景：</strong></p><ol><li><p>多线程环境下需要独立存储和获取数据的场景，例如线程池中的任务需要使用各自独立的数据库连接、计数器等。</p></li><li><p>线程上下文传递，例如Web框架中将请求信息或用户登录信息存储在ThreadLocal中，方便各层次方法调用时获取，避免了传递参数的麻烦。</p></li></ol><p><strong>坑与解决方法：</strong></p><ol><li><p><strong>内存泄漏问题：</strong>由于ThreadLocal的生命周期和线程的生命周期绑定，使用完ThreadLocal后，需要调用remove()方法进行清理，避免内存泄漏。</p><p><strong>解决方法：</strong>在使用完ThreadLocal后，在合适的地方调用remove()方法清理资源，可以使用try-finally语句块确保清理操作的执行，或者使用ThreadLocal的initialValue()方法设置初始值，这样在线程结束后会自动清理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;Object&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">    return &quot;initial value&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 使用完ThreadLocal后，调用remove()方法清理</span><br><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure><ol><li><p><strong>共享资源问题：</strong>如果多个线程共享了同一个ThredLocal变量，可能会导致数据错误或不确定的结果。每个线程应持有自己的ThreadLocal变量实例。</p><p>解决方法：对于需要在多个线程之间共享变量的情况，应该创建多个ThreadLocal实例，每个线程持有自己的实例。</p></li><li><p><strong>线程池使用时注意：</strong>在使用线程池时，需要特别小心ThreadLocal的使用，避免由于线程的重用而导致ThreadLocal数据的混乱。</p><p>解决方法：使用线程池时，应避免使用ThreadLocal变量或者在使用前后显式清理ThreadLocal变量，确保每次任务执行时ThreadLocal的状态是干净的。</p></li></ol></li></ol><pre><code>  总的来说，使用ThreadLocal时需要注意其生命周期、清理和共享的问题，合理使用并及时清理ThreadLocal，可以避免潜在的问题发生。</code></pre><blockquote><p>总结：ThreadLocal是一种Java技术，它允许在多线程环境中维护线程私有的变量副本。底层实现会使用一个类似于Map的结构来存储每个线程的变量副本。ThreadLocal并不是强引用或弱引用，它使用弱引用作为键来维护各个线程的变量副本，但变量本身由线程强引用。在使用ThreadLocal时，可能会出现内存泄漏的问题。如果线程结束了，但ThreadLocal中的变量没有被手动清理，那么该变量会一直存在于ThreadLocal的Map中，导致内存泄漏。解决这个问题的常见方式是在使用完ThreadLocal后调用remove()方法将变量从ThreadLocal中移除，或者使用Java 8中的ThreadLocal的InitialValue方法来提供默认值。另外，也可以使用ThreadLocal的弱引用方式来解决内存泄漏问题，例如使用InheritableThreadLocal。</p></blockquote><h1 id="十一、悲观锁和乐观锁的区别"><a href="#十一、悲观锁和乐观锁的区别" class="headerlink" title="十一、悲观锁和乐观锁的区别"></a>十一、悲观锁和乐观锁的区别</h1><p><font color=red>悲观锁</font>：认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><font color=yellow>锁实现</font>：可以使用关键字synchronized、接口Lock的实现类</p><p><font color=green>适用的场景：</font>写操作较多的，先加锁可以保证写操作时数据正确</p><p><font color=red>乐观锁</font>：认为自己使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据</p><p><font color=yellow>锁实现1</font>：CAS算法， CAS即Compare And Swap，是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则返回false，不进行任何操作；例如ActomicInteger类的原子自增是通过CAS自选实现。</p><p><font color=yellow>锁实现2</font>：版本号控制：数据表中加上版本号字段 version，表示数据被修改的次数。当数据被修改时，这个字段值会加1，提交必须满足“ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略</p><p><font color=green>适用场景</font>：读操作较多，不加锁的特点能够使其读操作的性能大幅提升</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程和锁&quot;&gt;&lt;a href=&quot;#线程和锁&quot; class=&quot;headerlink&quot; title=&quot;线程和锁&quot;&gt;&lt;/a&gt;线程和锁&lt;/h1&gt;&lt;h1 id=&quot;一、线程的状态&quot;&gt;&lt;a href=&quot;#一、线程的状态&quot; class=&quot;headerlink&quot; title=&quot;一、线</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="面试题" scheme="https://blog.haodene.love/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Map集合</title>
    <link href="https://blog.haodene.love/2023/07/20/Map%E9%9B%86%E5%90%88/"/>
    <id>https://blog.haodene.love/2023/07/20/Map%E9%9B%86%E5%90%88/</id>
    <published>2023-07-20T08:30:00.000Z</published>
    <updated>2023-10-19T15:08:59.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java常用的集合、分类、涉及到的接口"><a href="#一、Java常用的集合、分类、涉及到的接口" class="headerlink" title="一、Java常用的集合、分类、涉及到的接口"></a>一、Java常用的集合、分类、涉及到的接口</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">List</th><th style="text-align:center">Set</th><th style="text-align:center">Map</th><th style="text-align:center">Queue</th></tr></thead><tbody><tr><td style="text-align:center"><strong>定义</strong></td><td style="text-align:center">一个有序集合，允许重复元素</td><td style="text-align:center">一个无序集合，不允许重复的元素</td><td style="text-align:center">由键值对组成的集合，键和值可以都是任意对象</td><td style="text-align:center">一种特殊的集合，按照特定规则进行元素插入和明除</td></tr><tr><td style="text-align:center"><strong>存储</strong></td><td style="text-align:center">以索引方式维护元素顺序</td><td style="text-align:center">不维护元素顺序</td><td style="text-align:center">使用键值唯一标识和访问值</td><td style="text-align:center">依据某种策略保持元素顺字</td></tr><tr><td style="text-align:center"><strong>可重复性</strong></td><td style="text-align:center">允许重复元素</td><td style="text-align:center">不允许重复元素</td><td style="text-align:center">键不允许重复，值允许重复</td><td style="text-align:center">允许重复元素</td></tr><tr><td style="text-align:center"><strong>实现类</strong></td><td style="text-align:center">ArrayList、LinkedList、Vetcor等</td><td style="text-align:center">HashSet、LinkedHashSet、TreeSet等</td><td style="text-align:center">HashMap、LinkedHashMap、TreeMap等</td><td style="text-align:center">LinkedList、PriorityQueue等</td></tr><tr><td style="text-align:center"><strong>遍历</strong></td><td style="text-align:center">可使用索遍历或者使用迭代器遍历</td><td style="text-align:center">可以使用迭代器遍历</td><td style="text-align:center">可以通过键或Entry遍历</td><td style="text-align:center">通常按照特定顺序遍历</td></tr><tr><td style="text-align:center"><strong>查找</strong></td><td style="text-align:center">根据索引位置或具体元素进行查找</td><td style="text-align:center">根据元素进行查找</td><td style="text-align:center">通过键查找值，可以使用containsKey和containsValue方法</td><td style="text-align:center">通常按照某种策略进行查找</td></tr><tr><td style="text-align:center"><strong>应用场景</strong></td><td style="text-align:center">需要按照顺序存储元素，可能存在重复元素的情况</td><td style="text-align:center">需要保证元素的唯一性，不关心元素顺序</td><td style="text-align:center">需要通过键值对来存储和访问数据</td><td style="text-align:center">需要按照特定规则进行元素插入和删除，如任务调度等</td></tr></tbody></table></div><ol><li>Collection接口： Collection 是集合 List、 Set、 Queue 的最基本的接口。</li></ol><ul><li>List（列表）：按照元素插入的顺序保存元素，允许重复元素。常见的有ArrayList、LinkedList等。</li><li>Set（集合）：不允许重复元素的无序集合。常见的有HashSet、TreeSet等。</li><li>Queue（队列）：按照先进先出（FIFO）的原则进行元素操作的集合。常见的有ArrayDeque、PriorityQueue等。</li></ul><ol><li>Map接口：是映射表的基础接口</li></ol><ul><li>Map（映射）：存储键值对（key-value）的集合，根据唯一的键来查找和访问值。常见的有HashMap、TreeMap等。</li></ul><ol><li>Iterator接口：迭代器，可以通过迭代器遍历集合中的数据</li></ol><ul><li>Java中的所有集合类都实现了Iterator接口。Iterator接口是Java集合框架提供的一种用于遍历集合元素的通用方式。它定义了一系列用于访问集合元素的方法，包括判断是否还有下一个元素、获取下一个元素、删除当前元素等操作</li></ul><h1 id="二、-HashMap底层原理"><a href="#二、-HashMap底层原理" class="headerlink" title="二、 HashMap底层原理"></a>二、 <strong>HashMap底层原理</strong></h1><h2 id="1-JDK1-8之前"><a href="#1-JDK1-8之前" class="headerlink" title="1. JDK1.8之前"></a>1. JDK1.8之前</h2><ul><li><code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</li><li><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></li></ul><h2 id="2-JDK1-8及以后"><a href="#2-JDK1-8及以后" class="headerlink" title="2.  JDK1.8及以后**"></a>2.  JDK1.8及以后*<em>*</em></h2><ul><li>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li><li>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</li></ul><p class="note note-info">总结：HashMap在JDK1.7使用的是数组+链表的结构，在哈希冲突时通过链表进行解决；而JDK1.8引入了红黑树的概念，当链表长度超过一定阈值时，链表会转换成红黑树，以提高查询效率。</p><h1 id="三、HashMap为什么用红黑树不用B树"><a href="#三、HashMap为什么用红黑树不用B树" class="headerlink" title="三、HashMap为什么用红黑树不用B树"></a>三、HashMap为什么用红黑树不用B树</h1><p>HashMap 使用红黑树（Red-Black Tree）而不是 B 树的主要原因是效率和复杂度。</p><ul><li><strong>效率</strong>：红黑树相对于 B 树，在插入、删除和查找操作上具有更好的平均性能。红黑树的平衡性质可以保证树的高度相对较小，从而减少了搜索的路径长度，提高了操作的效率。</li><li><strong>复杂度</strong>：B 树是一种多路搜索树，节点可以包含多个关键字和指针，适合用于磁盘存储等场景，可优化磁盘 IO 操作。然而，在内存中的数据结构中，红黑树的实现更为简单，代码的复杂度较低。同时，红黑树的性能在典型的 HashMap 使用场景中通常表现出良好的性能。</li></ul><p>另外，HashMap 维护了一个哈希表和一个链表或红黑树的混合结构（JDK8 之后），当发生哈希冲突时，会使用链表或红黑树来处理冲突。链表适合处理冲突较少的情况，而红黑树则适合处理冲突较多的情况。红黑树相对于链表具有更高的查找效率，因此在冲突较多的情况下能够提供更好的性能。</p><p>总之，HashMap 使用红黑树而不是 B 树主要是出于对效率和复杂度的考虑。红黑树在内存中的实现更简单，对于典型的 HashMap 使用场景能够提供良好的性能，且适用于处理冲突较多的情况。</p><p class="note note-info">总结HashMap使用红黑树而不是B树，是因为红黑树相对于B树在插入、删除和查找等操作上的平衡性能更好，且红黑树的节点比B树的节点更小，占用的内存更少，适合存储在内存中的数据结构。</p><h1 id="四、、HashMap什么时候扩容"><a href="#四、、HashMap什么时候扩容" class="headerlink" title="四、、HashMap什么时候扩容"></a>四、、HashMap什么时候扩容</h1><ol><li>在JDK1.7中，当HashMap中元素数量超过当前容量与负载因子（默认为0.75）的乘积时，会触发扩容操作，扩容后的容量为当前容量的两倍。例如，初始容量为16，当元素数量达到12时会触发扩容，扩容后的容量为32。</li><li>在JDK 1.8中，HashMap的扩容和红黑树转换是两个独立的操作，且顺序是先扩容，然后再进行红黑树的转换。当HashMap中的元素数量超过负载因子（默认为0.75）与数组容量的乘积时，会触发扩容操作。扩容会重新调整数组的大小，并将原来数组中的元素重新分配到新的数组位置上。扩容操作会导致原本哈希冲突较多的链表长度变长，因此当链表长度超过阈值（默认为8）时，会将链表转化为红黑树。综上所述，在JDK 1.8中，HashMap的操作顺序是先扩容，然后再进行红黑树的转换。扩容是为了减少哈希冲突，提高HashMap的性能和效率，而链表转红黑树的操作则是为了在特定情况下提供更好的查找、插入和删除元素的性能。</li></ol><h1 id="五、HashMap的长度为什么是-2的-N-次方"><a href="#五、HashMap的长度为什么是-2的-N-次方" class="headerlink" title="五、HashMap的长度为什么是 2的 N 次方"></a>五、HashMap的长度为什么是 2的 N 次方</h1><p>为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数</p><p>据能均匀的分配，每个链表或者红黑树长度尽量相等。我们首先可能会想到 % 取模的操作来实现。</p><font color=blue>**下面是回答的重点哟：**</font><p><strong>取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说hash % length == hash &amp;(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 &amp; ，相对于 % 能够提高运算效率。</strong></p><p><strong>这就是为什么 HashMap 的长度需要 2 的 N 次方了</strong></p><p class="note note-info">总结：HashMap的长度选择为2的N次方是为了提高散列算法的效率和分布均匀性，通过使用2的幂次方作为长度，可以确保哈希码的高位和低位可以均匀参与到散列计算中，减少哈希冲突的发生，并提高散列算法的效率和性能。</p><h1 id="六、HashMap和HashTable区别"><a href="#六、HashMap和HashTable区别" class="headerlink" title="六、HashMap和HashTable区别"></a>六、HashMap和HashTable区别</h1><div class="table-container"><table><thead><tr><th></th><th>HashMap</th><th>HanhTable</th></tr></thead><tbody><tr><td>线程安全性</td><td>非线程安全</td><td>线程安全</td></tr><tr><td>空键和空值</td><td>允许空键和空值</td><td>不允许空键和空值</td></tr><tr><td>底层实现</td><td>数组+链表/红黑树（JDK1.8+）</td><td>数组+链表</td></tr></tbody></table></div><p> <strong>线程是否安全：</strong> HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用ConcurrentHashMap 吧！）；</p><p><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</p><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</p><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p><p class="note note-info">总结：HashMap是非线程安全的、允许空键和空值，并使用数组+链表/红黑树底层实现；HashTable是线程安全的、不允许空键和空值，并使用数组+链表底层实现。</p><h1 id="七、ConcurrentHashMap和HashMap的区别"><a href="#七、ConcurrentHashMap和HashMap的区别" class="headerlink" title="七、ConcurrentHashMap和HashMap的区别"></a>七、ConcurrentHashMap和HashMap的区别</h1><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">ConcurrentHashMap</th><th style="text-align:center">HashMap</th></tr></thead><tbody><tr><td style="text-align:center">线程安全</td><td style="text-align:center">高度线程安全，支持并发读写操作</td><td style="text-align:center">非线程安全，不支持并发读写慢作</td></tr><tr><td style="text-align:center">锁策略</td><td style="text-align:center">分段锁机制(Segment)</td><td style="text-align:center">无锁</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">在高并发环境下，读写操作性能较好</td><td style="text-align:center">在单线程或低并发情况下性能较好</td></tr><tr><td style="text-align:center">扩容机制</td><td style="text-align:center">动志扩容，可以同时进行读写操作</td><td style="text-align:center">扩容时需要暂停所有操作</td></tr><tr><td style="text-align:center">允许null键值</td><td style="text-align:center">允许存储null键和null值</td><td style="text-align:center">允许存储一个null键和多个null值</td></tr><tr><td style="text-align:center">迭代器致性</td><td style="text-align:center">提供弱一致性保证，允许迭代器在遍历过程中可能看到插入、更新和删除操作后的结果</td><td style="text-align:center">提供强一致性保证，确保迭代器在遍历过程中不会抛出ConcurrentModificationException异常</td></tr><tr><td style="text-align:center">继承关系</td><td style="text-align:center">实现了ConcurrentMap接门，并继承自AbstractMap</td><td style="text-align:center">继承自AbstractMap</td></tr></tbody></table></div><p><strong>ConcurrentHashMap和HashMap是Java中常用的两种Map实现，它们之间有以下几个区别：</strong></p><p><strong>1.</strong> <strong>线程安全性：</strong>ConcurrentHashMap是线程安全的，多个线程可以同时对其进行读写操作而不需要额外的同步措施；而HashMap是非线程安全的，如果多个线程同时对其进行读写操作，可能会导致数据不一致或抛出异常。</p><p><strong>2.</strong> <strong>锁粒度：</strong>ConcurrentHashMap通过分段锁（Segment）实现并发访问的高效性。相比之下，HashMap只能通过全局锁来保证线程安全性，因此在并发场景下性能较低。</p><p><strong>3.</strong> <strong>迭代器弱一致性：</strong>ConcurrentHashMap的迭代器是弱一致的，即在迭代过程中可以容忍在迭代开始时已有的修改和在迭代期间的新增修改。HashMap的迭代器在迭代过程中如果发生结构性修改（例如增加或删除元素），会抛出ConcurrentModificationException异常。</p><p><strong>4.</strong> <strong>初始容量和扩容机制：</strong>ConcurrentHashMap在初始化时可以指定并发级别和初始容量，可以通过合理设置参数来提高并发访问的效率。而HashMap默认的初始容量较小，加载因子较大，在元素数量达到一定阈值时会触发扩容操作，而扩容操作比较耗时。</p><p><strong>5.**</strong>null值和null键：**ConcurrentHashMap中既不允许存储null值，也不允许存储null键；而HashMap允许存储一个null值和多个null键。</p><p>总体来说，ConcurrentHashMap适用于高并发的场景，能够提供更好的性能和线程安全性；而HashMap适用于单线程环境或者在已知不存在并发访问的情况下。选择使用哪种Map实现要根据具体的需求和场景进行权衡。</p><p class="note note-info">总结：ConcurrentHashMap是线程安全的并发哈希表，支持高效地并发访问，而HashMap是非线程安全的哈希表，适用于单线程环境下的使用。</p><h1 id="八、ConcurrentHashMap和HashTable区别，他们如何保证线程安全"><a href="#八、ConcurrentHashMap和HashTable区别，他们如何保证线程安全" class="headerlink" title="八、ConcurrentHashMap和HashTable区别，他们如何保证线程安全"></a>八、ConcurrentHashMap和HashTable区别，他们如何保证线程安全</h1><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">ConcurrentHashMap</th><th style="text-align:center">HashTable</th></tr></thead><tbody><tr><td style="text-align:center">线程安全</td><td style="text-align:center">高度线程安全，支持并发读与操作</td><td style="text-align:center">线程安全，支持并发读与操作</td></tr><tr><td style="text-align:center">锁策略</td><td style="text-align:center">分段锁机制 (Segment)</td><td style="text-align:center">互斥锁 (synchronized)</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">在高并发环境下，读写操作性能较好</td><td style="text-align:center">在低并发或无并发的情况下性能较好</td></tr><tr><td style="text-align:center">扩容机制</td><td style="text-align:center">动态扩容，可以同时进行读写操作</td><td style="text-align:center">扩容时需要暂停所有操作</td></tr><tr><td style="text-align:center">允许null键值</td><td style="text-align:center">允许存储null过和null值</td><td style="text-align:center">不允许存储nult和null值</td></tr><tr><td style="text-align:center">迭代器弱一致性保证</td><td style="text-align:center">提供弱一致性保证，允许选代器在遍历过程中可能石到插入、更新和删除操作后的结果</td><td style="text-align:center">提供强一致性保证，确保选代器在遍历过程中不会抛出ConcurrentModificationException异常</td></tr><tr><td style="text-align:center">继承关系</td><td style="text-align:center">实现了ConcurrentMap接口，并继承自AbstractMap</td><td style="text-align:center">继承自Dictionary类，已被推荐使用ConourrentHashMap替代</td></tr></tbody></table></div><p><strong>底层数据结构：</strong></p><p>JDK1.7 的 ConcurrentHashMap 底层采用<strong>分段的数组+链表</strong>实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。</p><p>Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是<strong>采用数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><p><strong>实现线程安全的方式（重要）：</strong></p><p>在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><p><strong>Hashtable(同一把锁) :</strong> 使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p><p class="note note-info">总结：ConcurrentHashMap和HashTable的区别在于并发性和线程安全性，ConcurrentHashMap利用分段锁（Segment）实现高效的并发访问和更新，而HashTable使用全局锁（synchronized）来保证线程安全。</p><h1 id="九、ArrayList与LinkedList区别"><a href="#九、ArrayList与LinkedList区别" class="headerlink" title="九、ArrayList与LinkedList区别"></a>九、ArrayList与LinkedList区别</h1><div class="table-container"><table><thead><tr><th>特性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>底层数据结构</td><td>数组</td><td>链表</td></tr><tr><td>查询时间复杂度</td><td>O(1)</td><td>O(n)</td></tr><tr><td>插入/删除时间复杂度</td><td>在未尾: 平均O(1)，最坏O(n)</td><td>在任意位置: O(1)</td></tr><tr><td>内存占用</td><td>相对较少</td><td>相对较多</td></tr><tr><td>随机访问</td><td>优化较好</td><td>不支持</td></tr><tr><td>迭代器遍历</td><td>高效</td><td>比较低效</td></tr><tr><td>数据元素顺序</td><td>按插入顺序保存</td><td>按插入顺序保存</td></tr></tbody></table></div><p><strong>是否保证线程安全：</strong> ArrayList 和LinkedList 都是不同步的，也就是不保证线程安全；</p><p><strong>底层数据结构：</strong> <strong>Arraylist</strong> 底层使用的是Object 数组；LinkedList 底层使用的是<strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行add(E e)方法的时候，ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li>LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li></ul><p><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p><p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p><p><strong>时间复杂度：</strong></p><p><strong>对于ArrayList：</strong>查询单个元素的时间复杂度为O(1)，即常数时间。由于ArrayList使用了数组来存储元素，每个元素都可以通过索引直接访问，因此根据索引获取元素的操作非常高效。</p><p><strong>对于LinkedList：</strong>查询单个元素的时间复杂度为O(n)，即线性时间。由于LinkedList是基于链表实现的，每个元素只能通过遍历链表来找到目标元素，因此随着链表长度的增加，查询操作需要遍历更多的元素，导致时间复杂度增加。</p><p class="note note-info">总结：ArrayList基于数组实现，适合随机访问但插入/删除效率低；LinkedList基于链表实现，适合频繁的插入/删除操作但访问元素效率较低。</p><h1 id="十、遍历LIST有哪些方式"><a href="#十、遍历LIST有哪些方式" class="headerlink" title="十、遍历LIST有哪些方式"></a>十、遍历LIST有哪些方式</h1><ul><li>普通遍历：for(int i=0; i&lt; arrays.size(); i++)</li><li>增强for遍历：for(String str : arrays)</li><li>foreach遍历：list.forEach((str) -&gt; xxxxx)</li><li>使用Iterator迭代器遍历</li><li>java8 stream遍历</li></ul><h1 id="十一、数组-Array-和列表-ArrayList-区别"><a href="#十一、数组-Array-和列表-ArrayList-区别" class="headerlink" title="十一、数组 (Array) 和列表 (ArrayList) 区别"></a>十一、数组 (Array) 和列表 (ArrayList) 区别</h1><ul><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li></ul><p>ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢</p><h1 id="十二、线程安全的集合类和有序的集合类"><a href="#十二、线程安全的集合类和有序的集合类" class="headerlink" title="十二、线程安全的集合类和有序的集合类"></a>十二、线程安全的集合类和有序的集合类</h1><p><strong>有序的集合类包括：</strong></p><ul><li>TreeMap - 基于红黑树实现的有序Map。</li><li>LinkedHashMap - 基于哈希表和双向链表实现的有序Map。</li><li>TreeSet - 基于红黑树实现的有序Set。</li><li>LinkedHashSet - 基于哈希表和双向链表实现的有序Set。</li></ul><p><strong>示例：</strong></p><ul><li>有序Map：TreeMap</li><li>有序List：LinkedList</li><li>有序Set：LinkedHashSet</li></ul><p>ArrayList虽然是一个有序集合，但它是按添加顺序进行排序而不是根据元素的值进行排序。如果需要根据元素的值进行排序，应该使用TreeSet或TreeMap。</p><p><strong>线程安全的集合类有以下几种：</strong></p><ul><li>ConcurrentHashMap - 线程安全的哈希表实现的Map。</li><li>CopyOnWriteArrayList - 线程安全的数组列表实现的List。</li><li>ConcurrentSkipListSet - 线程安全的跳表实现的有序Set。</li></ul><p><strong>示例</strong>：</p><ul><li>Map的例子：ConcurrentHashMap</li><li>List的例子：CopyOnWriteArrayList</li><li>Set的例子：ConcurrentSkipListSet</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java常用的集合、分类、涉及到的接口&quot;&gt;&lt;a href=&quot;#一、Java常用的集合、分类、涉及到的接口&quot; class=&quot;headerlink&quot; title=&quot;一、Java常用的集合、分类、涉及到的接口&quot;&gt;&lt;/a&gt;一、Java常用的集合、分类、涉及到的接口&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="面试题" scheme="https://blog.haodene.love/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题基础</title>
    <link href="https://blog.haodene.love/2023/07/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"/>
    <id>https://blog.haodene.love/2023/07/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-15T08:30:00.000Z</published>
    <updated>2023-10-19T15:08:34.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面试题基础"><a href="#Java面试题基础" class="headerlink" title="Java面试题基础"></a>Java面试题基础</h1><h2 id="1-String-StringBuffer-StringBuilder区别"><a href="#1-String-StringBuffer-StringBuilder区别" class="headerlink" title="1. String/StringBuffer/StringBuilder区别"></a>1. <strong>String/StringBuffer/StringBuilder区别</strong></h2><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:left">String</th><th style="text-align:left">StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td style="text-align:center">可变性</td><td style="text-align:left">不可变</td><td style="text-align:left">可变</td><td>可变</td></tr><tr><td style="text-align:center">线程安全</td><td style="text-align:left">线程安全</td><td style="text-align:left">线程安全</td><td>非线程安全</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:left">低效，每次操作都会创建新的字符串对象</td><td style="text-align:left">中等效率，操作时候不会创建新的字符串对象</td><td>高效，操作时候不会创建新的字符串对象</td></tr><tr><td style="text-align:center">内存占用</td><td style="text-align:left">每次拼接字符串会创建新的对象，占用更多内存</td><td style="text-align:left">内部使用字等数组实现，占用较少内存</td><td>内部使用字符数组实现，占用较少内存</td></tr><tr><td style="text-align:center">适用场景</td><td style="text-align:left">字符串不经常被修改、拼接较少的情况</td><td style="text-align:left">多线程环境下或频繁拼接字符串的场景</td><td>单线程环境下频繁拼接字符串的场景</td></tr></tbody></table></div><ul><li>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</li><li><p>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p><p>总结：</p></li><li><p>操作少量的数据 = String</p></li><li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li></ul><p class="note note-info">总结：String是不可变的字符串，每次修改都会创建新的对象，适用于不经常修改的字符串操作；StringBuffer是可变的字符串，线程安全，适用于多线程环境；StringBuilder也是可变的字符串，但不是线程安全的，适用于单线程频繁修改字符串的场景。</p><h2 id="2-反射机制及主要用到的方法"><a href="#2-反射机制及主要用到的方法" class="headerlink" title="2.反射机制及主要用到的方法"></a>2.<strong>反射机制及主要用到的方法</strong></h2><p>在 Java 中的反射机制是指在<strong>运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；</strong>这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。通过反射机制使我们所写的代码更具有「通用性」和「灵活性」，比如Spring/Spring Boot、MyBatis 等框架大量用到了反射机制。比如类上加上@Component注解，Spring就帮你创建对象，比如约定大于配置。</p><p>以下是反射常用到的方法：</p><ul><li><code>Class.forName(String className)</code>：根据类名获取对应的Class对象。</li><li><code>getClass()</code>：获取对象的运行时类型。</li><li><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：获取指定方法名和参数类型的方法。</li><li><code>getField(String name)</code>：获取指定名称的字段。</li><li><code>newInstance()</code>：使用默认的构造函数创建实例。</li><li><code>newInstance(Object... initargs)</code>：使用指定参数类型和值的构造函数创建实例。</li><li><code>invoke(Object obj, Object... args)</code>：调用指定对象的方法。</li></ul><p>以上只是反射中常用的一些方法，还有其他更多的方法可根据具体需求来使用。反射功能强大，但也要慎用，因为它可能会降低性能，且破坏了面向对象的封装性。在使用反射时应该知道自己的需求，并权衡利弊。</p><p class="note note-info">总结：Java的反射机制是指在运行时动态地获取类的信息并操作类或对象的能力。通过反射，我们可以在编译时无法确定的情况下，通过类名获取类的实例、获取类的字段、方法、构造函数等信息，并且可以在运行时调用这些方法或访问这些字段。</p><h2 id="3-JVM内存结构"><a href="#3-JVM内存结构" class="headerlink" title="3. JVM内存结构"></a>3. <strong>JVM内存结构</strong></h2><p><img src="https://bu.dusays.com/2023/10/13/65294014a6081.png" alt="https://bu.dusays.com/2023/10/13/65294014a6081.png"></p><p>运行时数据区域被划分为5个主要组件：</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>所有类级别数据将被存储在这里，包括静态变量。每个JVM只有一个方法区，它是一个<strong>共享的资源</strong>。</p><h3 id="堆区（Heap-Area）"><a href="#堆区（Heap-Area）" class="headerlink" title="堆区（Heap Area）"></a>堆区（Heap Area）</h3><p>所有的对象和它们相应的实例变量以及数组将被存储在这里。每个JVM同样只有一个堆区。由于方法区和堆区的内存由多个<strong>线程共享</strong>，所以存储的数据不是线程安全的。</p><h3 id="栈区（Stack-Area）"><a href="#栈区（Stack-Area）" class="headerlink" title="栈区（Stack Area）"></a>栈区（Stack Area）</h3><p>对每个线程会单独创建一个运行时栈。对每个函数呼叫会在栈内存生成一个栈帧(Stack Frame)。所有的局部变量将在栈内存中创建。栈区是线程安全的，因为它不是一个共享资源。栈帧被分为三个子实体：</p><ul><li>局部变量数组 – 包含多少个与方法相关的局部变量并且相应的值将被存储在这里。</li><li>操作数栈 – 如果需要执行任何中间操作，操作数栈作为运行时工作区去执行指令。</li><li>帧数据 – 方法的所有符号都保存在这里。在任意异常的情况下，catch块的信息将会被保存在帧数据里面。</li></ul><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>每个线程都有一个单独的PC寄存器来保存当前执行指令的地址，一旦该指令被执行，pc寄存器会被更新至下条指令的地址。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈保存本地方法信息。对每一个线程，将创建一个单独的本地方法栈。</p><p class="note note-info">总结：Java的内存结构主要包括方法区、堆、虚拟机栈、本地方法栈和程序计数器。方法区用于存储类信息，堆用于存储对象实例，虚拟机栈用于存储方法调用和局部变量，本地方法栈用于存储非Java方法信息，程序计数器用于记录当前线程执行的指令地址。</p><h2 id="4-与equals区别"><a href="#4-与equals区别" class="headerlink" title="4. ==与equals区别"></a>4. <strong>==与equals区别</strong></h2><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">“==”</th><th style="text-align:center">equals方法</th></tr></thead><tbody><tr><td style="text-align:center">比较对象类型</td><td style="text-align:center">可以比较任意类型的对象，包括基本类型和引用类型</td><td style="text-align:center">通常用于比较两个引用类型对象</td></tr><tr><td style="text-align:center">比较结果</td><td style="text-align:center">比较的是对象的引用值，判断两个对象是否指向同一内存地址</td><td style="text-align:center">比较的是对象的内容，根据实现方式可能有不同结果</td></tr><tr><td style="text-align:center">重写方式</td><td style="text-align:center">不可重写</td><td style="text-align:center">可以根据需要重写equals方法来自定义比较逻辑</td></tr><tr><td style="text-align:center">默认实现</td><td style="text-align:center">对于基本类型，比较的是值</td><td style="text-align:center">对于引用类型，默认实现与”==”相同</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">适用于比较基本类型的值或判断两个对象是否指向同一内存地址</td><td style="text-align:center">适用于比较引用类型对象的内容或自定义比较逻辑</td></tr></tbody></table></div><h3 id="区别1-是一个运算符-equals是Object类的方法"><a href="#区别1-是一个运算符-equals是Object类的方法" class="headerlink" title="区别1. ==是一个运算符 equals是Object类的方法"></a>区别1. ==是一个运算符 equals是Object类的方法</h3><h3 id="区别2-比较时的区别"><a href="#区别2-比较时的区别" class="headerlink" title="区别2. 比较时的区别"></a>区别2. 比较时的区别</h3><ul><li>用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。</li><li>用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。</li></ul><p class="note note-info">总结："==" 用于比较对象的引用或基本类型的值是否相等，而equals方法用于比较对象的内容是否相等。换句话说， "=="比较的是身份，equals比较的是内容。</p><h2 id="5-接口和抽象类的区别"><a href="#5-接口和抽象类的区别" class="headerlink" title="5. 接口和抽象类的区别"></a>5. 接口和抽象类的区别</h2><div class="table-container"><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>定义</td><td>定义了一组方法，不包含具体实现</td><td>定义了一组方法，可以包含具体实现</td></tr><tr><td>继承关系</td><td>接口之间支持多重继承</td><td>类之间只能单继承</td></tr><tr><td>成员变量</td><td>只能定义常量，默认为public、static、final</td><td>可以定义实例变量，并且可以有不同的访问权限</td></tr><tr><td>构造函数</td><td>不能定义构造函数</td><td>可以定义构造函数</td></tr><tr><td>方法实现</td><td>所有的方法都需要实现</td><td>可以包含已经实现的方法，但也可以包含抽象方法</td></tr><tr><td>实例化场景</td><td>不能直接实例化接口</td><td>不能直接实例化抽象类</td></tr><tr><td>使用场景</td><td>用于描述一组相关的行为和能力</td><td>用于定义一组相关的类，提供默认的行为和共享的属性</td></tr></tbody></table></div><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final 类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li></ul><p class="note note-info">总结：接口是一种规范，它定义了一组方法的签名，而不包含具体实现。一个类可以实现多个接口。抽象类是一种可以包含具体方法和抽象方法的类，它可以被继承，但不能被实例化。一个类只能继承一个抽象类。简而言之，接口关注的是行为的规范，而抽象类关注的是共享的功能。</p><h2 id="6-重写（override）和重载（overload）的区别"><a href="#6-重写（override）和重载（overload）的区别" class="headerlink" title="6.重写（override）和重载（overload）的区别"></a>6.重写（override）和重载（overload）的区别</h2><ol><li>重载就是同一个类中，有多个方法名相同，但参数列表不同（包括参数个数和参数类型），与返回值无关，与权限修饰符也无关。调用重载的方法时通过传递给它们不同的参数个数和参数类型来决定具体使用哪个方法，这叫多态。 </li><li>重写就是子类重写基类的方法，方法名，参数列表和返回值都必须相同，否则就不是重写而是重载。权限修饰符不能小于被重写方法的修饰符。重写方法不能抛出新的异常或者是比被重写方法声明更加宽泛的检查型异常。</li></ol><p class="note note-info">总结：重写（override）指的是子类重新实现了父类中已有的方法，子类的方法具有相同的名称、参数列表和返回类型。重载（overload）指的是在同一个类中定义了多个方法，它们具有相同的名称但参数列表不同。重写主要涉及继承和多态性，而重载则是在同一个类中的方法之间进行区分。简而言之，重写是对已有方法的重新实现，而重载是创建具有相同名称但不同参数的多个方法。</p><h2 id="7-sleep和wait的区别"><a href="#7-sleep和wait的区别" class="headerlink" title="7.sleep和wait的区别"></a>7.sleep和wait的区别</h2><ul><li>sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。</li><li>wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li></ul><p class="note note-info">总结：sleep是线程休眠一段时间后继续执行，期间保持对象锁不释放；wait是线程等待并释放对象锁，直到其他线程通知后才继续执行。</p><h2 id="8-String类的常用方法"><a href="#8-String类的常用方法" class="headerlink" title="8.String类的常用方法"></a>8.String类的常用方法</h2><ul><li>length()；返回字符串长度。</li><li>getBytes()；返回字符串byte类型数组。</li><li>indexof(); 返回指定字符的的索引。</li><li>split()；字符串分割，返回分割后的字符串数组。</li><li>replace(); 字符串替换。</li><li>substring(); 字符串截取。</li><li>trim(); 去除字符串两端空格。</li><li>toLowerCase(); 将字符串转换为小写字母。 </li><li>toUpperCase();将字符串转换为大写字母。</li></ul><h2 id="9-类加载器加载过程"><a href="#9-类加载器加载过程" class="headerlink" title="9. 类加载器加载过程"></a>9. <strong>类加载器加载过程</strong></h2><p>Java类加载器的加载过程可以分为以下几个步骤：</p><ol><li><p>加载：通过类的全限定名获取字节码文件，并将其转换为方法区内的运行时数据结构。</p></li><li><p>验证：对字节码进行校验，确保符合Java虚拟机规范。</p></li><li><p>准备：为类的静态变量分配内存，并设置默认初始值。</p></li><li><p>解析：将符号引用转换为直接引用，即将类、方法、字段等解析为具体的内存地址。</p></li><li><p>初始化：执行类的初始化代码，包括静态变量赋值和静态代码块的执行。</p></li></ol><h2 id="10-双亲委派机制"><a href="#10-双亲委派机制" class="headerlink" title="10. 双亲委派机制"></a>10. <strong>双亲委派机制</strong></h2><p>Java双亲委派机制是指在类加载过程中，类加载器会按照一定的顺序委派给父类加载器来尝试加载类。这个机制可以确保类的加载安全和防止类的重复加载。下面是一个简要解答核心知识的表格：</p><div class="table-container"><table><thead><tr><th>核心知识</th><th>解答</th></tr></thead><tbody><tr><td>定义</td><td>Java双亲委派机制是一种类加载机制，在类加载时按照一定的层次关系逐级委托给父类加载器进行加载</td></tr><tr><td>加载顺序</td><td>类加载器首先检查自己是否已经加载了该类，如果是，则直接返回;否则，将该请求委诉给父类加载器</td></tr><tr><td>父类加载器</td><td>父类加载器在尝试加载类之前，也会先检查自己是否已经加载了该类，若加载了则直接返回，否则继绩向上委派给其父类加载器</td></tr><tr><td>最终委派给Bootstrap  Classlcader</td><td>Bootstrap ClassLoader是Java虚拟机内置的ClassLoader，它是所有Java类加载器的最顶层加载器</td></tr><tr><td>安全性和避免重复加载</td><td>双享委派机制可以确保类的加载安全性，避免了恶意类的加载和类的重复加载</td></tr><tr><td>自定义ClassLoader</td><td>开发者可以通过自定义ClassLoader来扩展Jva的类加载能力，并在一定程座上打破双亲委派机制</td></tr></tbody></table></div><p>通过Java双亲委派机制，可以实现类加载的安全性和避免重复加载，同时也允许开发者自定义ClassLoader来实现特定需求的类加载行为。</p><p class="note note-info">总结：双亲委派机制是指类加载器在加载类时，首先将加载请求委托给父类加载器，只有当父类加载器无法加载时，才自己尝试加载。从而确保类的加载安全和防止类的重复加载。</p><h2 id="11-VM的GC垃圾回收机制"><a href="#11-VM的GC垃圾回收机制" class="headerlink" title="11.VM的GC垃圾回收机制"></a>11.VM的GC垃圾回收机制</h2><p>JVM的垃圾回收（Garbage Collection）机制是自动管理内存的一种机制，它可以识别和回收不再使用的对象，释放其占用的内存空间。以下是垃圾回收机制的介绍以及一些常见的垃圾回收算法：</p><p><strong>1.</strong> <strong>垃圾回收机制介绍：</strong></p><ul><li>垃圾回收器负责自动检测和回收不再使用的对象。</li><li>它通过标记-清除、复制、标记-整理等算法来回收垃圾对象。</li><li>垃圾回收过程包括标记、清除、整理和压缩等阶段。</li></ul><p><strong>2.</strong> <strong>常见的垃圾回收算法：</strong></p><ul><li>标记-清除算法（Mark and Sweep）：首先标记出所有活动对象，然后清除未标记的对象。</li><li>复制算法（Copying）：将可用内存分为两块，每次只使用其中一块，将存活对象复制到另一块中，然后清除当前使用的块。</li><li>标记-整理算法（Mark and Compact）：标记出所有活动对象，然后将活动对象向一端移动，之后清理边界外的内存。</li><li>分代收集算法（Generational Collection）：将堆内存分为新生代和老年代，并使用不同的回收算法。新生代通常使用复制算法，老年代使用标记-清除或标记-整理算法。</li></ul><p><strong>3.</strong> <strong>默认的垃圾回收算法：</strong></p><ul><li>默认情况下，HotSpot JVM使用分代收集算法。</li><li>新生代使用复制算法，其中的Eden区和Survivor区各占一部分，并且采用了对象晋升机制。</li><li>老年代使用标记-清除或标记-整理算法来回收内存。</li></ul><p class="note note-info">总结：GC垃圾回收机制是指Java虚拟机自动管理内存的机制，通过自动识别和回收不再使用的对象，释放对应的内存资源，以避免内存泄漏和提高程序性能。</p><h2 id="12-JVM如何调优（调优参数）"><a href="#12-JVM如何调优（调优参数）" class="headerlink" title="12.JVM如何调优（调优参数）"></a>12.JVM如何调优（调优参数）</h2><p>一般调优，通常优先对堆内存空间进行调整，-Xms表示初始堆内存大小（默认为物理内存的1/64），-Xmx表示最大分配对内存大小（默认为物理内存的1/4）</p><p><img src="https://bu.dusays.com/2023/10/13/6529474712c29.png" alt=""></p><p>举例，物理内存4G，运行JAR包时可指定堆内存参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3.2g -Xms1g -jar xxx.jar</span><br></pre></td></tr></table></figure><h2 id="13-项目是否出现过OOM问题？怎么排查的？可能原因-如何复现一个内存溢出场景？内存溢出和内存泄露的区别？"><a href="#13-项目是否出现过OOM问题？怎么排查的？可能原因-如何复现一个内存溢出场景？内存溢出和内存泄露的区别？" class="headerlink" title="13.项目是否出现过OOM问题？怎么排查的？可能原因?如何复现一个内存溢出场景？内存溢出和内存泄露的区别？"></a>13.项目是否出现过OOM问题？怎么排查的？可能原因?如何复现一个内存溢出场景？内存溢出和内存泄露的区别？</h2><ol><li><p>项目中的内存溢出出现过，是比较常见的问题。</p></li><li><p>如何排查OOM问题？对于OOM问题的排查，可以采取以下步骤：</p></li></ol><ul><li>检查日志文件：查看错误日志或异常信息，定位到具体的异常堆栈信息。</li><li>使用内存分析工具：如Java的jmap、jstack、VisualVM等工具，分析内存快照以定位内存泄漏。</li><li>进行代码审查：检查可能引起内存泄漏的代码，如长时间持有对象、未关闭资源等。</li><li>增加日志和监控：使用合适的日志和监控工具，记录系统的内存使用情况及峰值。</li></ul><ol><li>可能的原因：</li></ol><ul><li>对象过多：创建了大量对象并占用了大量内存。</li><li>内存泄漏：某些对象被错误地保持引用，使得其无法被垃圾回收器回收。</li><li>不合理的内存设置：如分配给应用程序的内存不足导致OOM。</li></ul><ol><li>如何复现一个内存溢出场景？复现内存溢出的场景可以通过以下方法：</li></ol><ul><li>增加测试数据量：模拟大量数据的输入，使得应用程序需要占用更多的内存。</li><li>重复执行某些操作：如循环读取文件或者对对象进行不断修改等。</li><li>设置小的堆大小：通过设置较小的堆大小，可以更容易地触发OOM异常。</li></ul><ol><li>内存溢出和内存泄露的区别：</li></ol><ul><li>内存溢出：指应用程序在申请内存时，无法获得足够的内存空间，造成异常终止。常见原因是使用了过多的对象并且没有妥善释放。</li><li>内存泄漏：指应用程序中存在无用的对象占用内存，并且这些对象无法被垃圾回收器回收。随着时间的推移，内存资源逐渐耗尽，最终导致内存溢出</li></ul><h2 id="14-JDK1-8的新特性"><a href="#14-JDK1-8的新特性" class="headerlink" title="14.JDK1.8的新特性"></a>14.JDK1.8的新特性</h2><p>好的，以下是除去CompletableFuture、重复注解和接口默认方法之外的JDK 1.8的新特性，并附上一些参考代码案例：</p><ol><li><strong>Lambda表达式</strong>：Lambda允许在Java中更简洁地使用函数式编程风格。它提供了一种简洁的方式来表示匿名函数，并使代码更易读、易写。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现Runnable接口</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure><ol><li><strong>Stream API</strong>：Stream API提供了一种用于处理集合和数组的声明性编程模型。它使得可以更直观地操作数据集合，如过滤、映射、排序等操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Stream API过滤集合中的元素</span></span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">   List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                       .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                       .collect(Collectors.toList());</span><br><span class="line">   System.out.println(evenNumbers);  <span class="comment">// 输出：[2, 4]</span></span><br></pre></td></tr></table></figure><ol><li><strong>新的日期与时间API</strong>：JDK 1.8引入了全新的日期和时间API（java.time包）。它提供了更好的处理日期、时间和时间间隔的方式，并且修复了旧API中存在的许多问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用新的日期与时间API获取当前日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">currentDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(currentDate);  <span class="comment">// 输出当前日期（例如：2023-07-21）</span></span><br></pre></td></tr></table></figure><ol><li><strong>方法引用</strong>：方法引用允许通过方法的名称来引用已存在的方法。这种方式常用于Lambda表达式中，使得代码更简洁、易读。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法引用调用静态方法</span></span><br><span class="line">  List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">  names.forEach(System.out::println);  <span class="comment">// 输出列表中的每个元素</span></span><br></pre></td></tr></table></figure><p>这些示例代码展示了JDK 1.8中的一些新特性的使用。请注意，这只是一部分特性，还有更多特性可供探索和学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java面试题基础&quot;&gt;&lt;a href=&quot;#Java面试题基础&quot; class=&quot;headerlink&quot; title=&quot;Java面试题基础&quot;&gt;&lt;/a&gt;Java面试题基础&lt;/h1&gt;&lt;h2 id=&quot;1-String-StringBuffer-StringBuilder区别</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="面试题" scheme="https://blog.haodene.love/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令--上</title>
    <link href="https://blog.haodene.love/2023/07/01/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8--%E4%B8%8A/"/>
    <id>https://blog.haodene.love/2023/07/01/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8--%E4%B8%8A/</id>
    <published>2023-07-01T04:30:00.000Z</published>
    <updated>2023-10-17T03:33:16.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h1><p><code>which</code>命令用于标识在终端提示符下键入可执行文件名称或命令时执行的给定可执行文件的位置，该命令在<code>PATH</code>环境变量中列出的目录中搜索作为参数指定的可执行文件。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [options]  COMMAND</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--version, -[vV]</code>: 输出版本信息。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--skip-dot</code>: 跳过<code>PATH</code>中以<code>.</code>开头的目录。</li><li><code>--skip-tilde</code>: 跳过<code>PATH</code>中以<code>~</code>开头的目录。</li><li><code>--show-dot</code>: 不要在输出中将<code>.</code>扩展到当前目录。</li><li><code>--show-tilde</code>: 为非<code>root</code>用户输出<code>HOME</code>目录的波浪号。</li><li><code>--tty-only</code>: 如果不在<code>tty</code>上，则停止处理右侧的选项。</li><li><code>--all, -a</code>: 打印<code>PATH</code>中的所有匹配项，而不仅仅是第一个。</li><li><code>--read-alias, -i</code>: 从标准输入中读取别名列表。</li><li><code>--skip-alias</code>: 忽略选项<code>--read-alias</code>，不要读标准输入。</li><li><code>--read-functions</code>: 从标准输入读取<code>shell</code>函数。</li><li><code>--skip-functions</code>: 忽略选项<code>--read-functions</code>，不要读标准输入。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>查看指令<code>bash</code>的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/bin/bash</span></span><br></pre></td></tr></table></figure><p>查看多个命令的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which ping touch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/bin/ping</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/bin/touch</span></span><br></pre></td></tr></table></figure><p>输出所有在环境变量中的匹配项的绝对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which -a python</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/anaconda3/bin/python</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/bin/python</span></span><br></pre></td></tr></table></figure><h1 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h1><p><code>whereis</code>命令用于查找文件，该指令会在特定目录中查找符合条件的文件，该指令只能用于查找二进制文件、源代码文件和<code>man</code>手册页，一般文件的定位需使用<code>locate</code>或<code>find</code>命令。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [options] file</span><br></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b</code>: 仅搜索二进制文件。</li><li><code>-B &lt;dirs&gt;</code>: 更改或限制<code>whereis</code>搜索二进制文件的位置。</li><li><code>-m</code>: 仅搜索源。</li><li><code>-M &lt;dirs&gt;</code>: 更改或限制<code>whereis</code>搜索手册部分的位置。</li><li><code>-s</code>: 仅搜索源。</li><li><code>-S &lt;dirs&gt;</code>: 更改或限制<code>whereis</code>搜索源的位置。</li><li><code>-f</code>: 不显示文件名前的路径名称。</li><li><code>-u</code>: 搜索不寻常的条目，如果文件没有每种请求类型的一个条目，则该文件被认为是不寻常的，即查找不包含指定类型的文件。</li><li><code>-l</code>: 输出有效的查找路径。</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>列出<code>whereis</code>命令搜索的目录，默认情况下<code>whereis</code>在环境变量中列出的硬编码路径和目录中搜索命令的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">whereis -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin: /usr/bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin: /usr/sbin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bin: /usr/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>获取有关<code>bash</code>命令的信息，输出的<code>bash</code>是要获取其信息的命令，<code>/bin/bash</code>是二进制文件的路径，<code>/etc/bash.bashrc</code>源文件以及<code>/usr/share/man/man1/bash.1.gz</code>手册页，如果要搜索的命令不存在，<code>whereis</code>将仅打印命令名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz</span></span><br></pre></td></tr></table></figure><p>为<code>whereis</code>命令同时查询<code>netcat</code>与<code>uptime</code>，输出将包含有关<code>netcat</code>和<code>uptime</code>命令的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis netcat uptime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netcat: /bin/netcat /usr/share/man/man1/netcat.1.gz</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">uptime</span>: /usr/bin/uptime /usr/share/man/man1/uptime.1.gz</span></span><br></pre></td></tr></table></figure><h1 id="updatedb命令"><a href="#updatedb命令" class="headerlink" title="updatedb命令"></a>updatedb命令</h1><p><code>updatedb</code>创建或更新<code>locate</code>命令使用的数据库，如果数据库已经存在，则重用其数据以避免重新读取未更改的目录，<code>updatedb</code>通常由<code>cron</code>每天运行以更新默认数据库。</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb [OPTION]...</span><br></pre></td></tr></table></figure><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-f, --add-prunefs FS</code>: 将空格分隔的列表<code>FS</code>中的条目添加到<code>PRUNEFS</code>。</li><li><code>-n, --add-prunenames NAMES</code>:  将空格分隔的列表名称中的条目添加到<code>pruneName</code>。</li><li><code>-e, --add-prunepaths PATHS</code>: 将以空格分隔的列表<code>PATHS</code>中的条目添加到<code>PRUNEPATHS</code>。</li><li><code>-U, --database-root PATH</code>: 仅存储扫描以生成的数据库路径为根的文件系统子树的结果，默认情况下会扫描整个文件系统即<code>/</code>，<code>locate</code>输出的条目作为绝对路径名，不包含符号链接，无论<code>PATH</code>的形式如何。</li><li><code>-h, --help</code>: 显示帮助信息。</li><li><code>-o, --output FILE</code>: 将数据库写入文件，而不是使用默认数据库，数据库默认位置为<code>/var/lib/mlocate/mlocate.db</code>。</li><li><code>--prune-bind-mounts FLAG</code>: 将<code>PRUNE_BIND_MOUNTS</code>设置为<code>FLAG</code>，覆盖配置文件，默认为<code>no</code>。</li><li><code>--prunefs FS</code>: 将<code>PRUNEFS</code>设置为<code>FS</code>，以覆盖配置文件。</li><li><code>--prunenames NAMES</code>: 将<code>PRUNENAMES</code>设置为<code>NAMES</code>，以覆盖配置文件。</li><li><code>--prunepaths PATHS</code>: 将<code>PRUNEPATHS</code>设置为<code>PATHS</code>，以覆盖配置文件。</li><li><code>-l, --require-visibility FLAG</code>: 将生成的数据库中的”报告之前要求文件可见性”标志设置为<code>FLAG</code>，默认值为<code>yes</code>。如果<code>FLAG</code>为<code>0</code>或<code>no</code>，或者数据库文件可被<code>others</code>读取或不属于<code>slocate</code>，那么<code>locate</code>将输出数据库项，运行<code>locate</code>的用户无法读取所需的目录以找到数据库项所描述的文件。如果<code>FLAG</code>为<code>1</code>或<code>yes</code>，则<code>locate</code>在将每个条目的父目录报告给调用用户之前，先检查其父目录的权限。为了使文件的存在真正被其他用户隐藏，数据库组设置为<code>slocate</code>，并且数据库权限禁止用户使用<code>locate set-gid slocate</code>以外的其他方式读取用户的数据库。注意，仅当数据库由<code>slocate</code>拥有并且<code>others</code>不可读时，才检查可见性标志。</li><li><code>-v, --verbose</code>: 将文件的输出路径名输出到标准输出。</li><li><code>-V, --version</code>: 输出版本信息。</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>更新<code>locate</code>命令所使用的数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br></pre></td></tr></table></figure><p>更新<code>locate</code>命令所使用的数据库，并输出找到的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb -v</span><br></pre></td></tr></table></figure><p>指定更新<code>locate</code>命令所使用的数据库的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb -U /home</span><br></pre></td></tr></table></figure><h1 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h1><p>在<code>Linux</code>和其他类<code>Unix</code>的操作系统上，将使用一组默认权限创建新文件，具体来说，可以通过应用称为<code>umask</code>的权限掩码，以特定方式限制新文件的权限，<code>umask</code>命令指定在建立文件时预设的权限掩码，或者展示当前的权限掩码值。</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [-S] [mask]</span><br></pre></td></tr></table></figure><h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-S</code>: 以文字的方式来表示权限掩码。</li><li><code>mask</code>: 果指定了有效的掩码，则将<code>umask</code>设置为此值，如果未指定掩码，则返回当前的<code>umask</code>值。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>使用<code>ll</code>命令查看文件与文件夹相关信息，对于其权限信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 12 linuxize users 4.0K Apr  8 20:51 dirname</span><br><span class="line">|[-][-][-]    [------] [---]</span><br><span class="line">| |  |  |        |       |       </span><br><span class="line">| |  |  |        |       +-----------&gt; Group</span><br><span class="line">| |  |  |        +-------------------&gt; Owner</span><br><span class="line">| |  |  +----------------------------&gt; Others Permissions</span><br><span class="line">| |  +-------------------------------&gt; Group Permissions</span><br><span class="line">| +----------------------------------&gt; Owner Permissions</span><br><span class="line">+------------------------------------&gt; File Type</span><br></pre></td></tr></table></figure><ul><li>首符号为<code>-</code>代表该文件为普通文件，为<code>d</code>则代表目录。</li><li>紧接着三个字符<code>rw-</code>代表用户<code>u</code>权限属性。</li><li>接下来三个字符<code>r--</code>代表用户组<code>g</code>权限属性。</li><li>最后三个字符<code>r--</code>代表其他人<code>o</code>权限属性。</li></ul><p>权限可以使用字符表示，同样也可以使用八进制表示信息：</p><ul><li><code>r</code>: 读取属性，值为<code>4</code>。</li><li><code>w</code>: 写入属性，值为<code>2</code>。</li><li><code>x</code>: 执行属性，值为<code>1</code>。</li></ul><p>关于操作权限的操作符：</p><ul><li><code>+</code>: 为指定的用户类增加指定的文件权限。</li><li><code>-</code>：为指定的用户类去除指定的文件权限。</li><li><code>=</code>: 为指定的用户类设定指定的文件权限。</li></ul><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>本质上，<code>umask</code>的每个数字都从操作系统的默认值中减去，以获得定义的默认值，这不是真正的减法，从技术上讲是将掩码按位取反，然后使用逻辑<code>AND</code>操作将此值应用于默认权限，例如<code>umask</code>值为<code>0022</code>：</p><ul><li>在<code>Linux</code>系统上，默认的创建文件权限是<code>666</code>，默认创建文件夹的权限为<code>777</code>。</li><li>即文件默认权限<code>666 - 022 = 644</code>即现在创建的新文件的权限为<code>644</code>。</li><li>创建文件夹则为<code>777 - 022 = 755</code>即现在创建的新文件夹的权限为<code>755</code>。</li></ul><p>此外，第一个零是特殊的权限数字，可以忽略，就当前的目的而言，<code>0002</code>与<code>002</code>相同。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>查看系统当前<code>umask</code>值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0022</span> </span><br></pre></td></tr></table></figure><p>以符号表示形式表示当前系统权限掩码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask -S</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u=rwx,g=rx,o=rx <span class="comment"># 实际上表达的是在所有者或者组以及其他人中的哪些权限已经被取消</span></span></span><br></pre></td></tr></table></figure><p>将系统<code>umask</code>值设置为<code>022</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 022</span><br></pre></td></tr></table></figure><h1 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h1><p><code>tr</code>命令用于转换或删除文件中的字符，可以读文件也可以从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [OPTION]... SET1 [SET2]</span><br></pre></td></tr></table></figure><h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-c, -C, --complement</code>: 使用<code>SET1</code>的补码。</li><li><code>-d, --delete</code>: 删除<code>SET1</code>中的字符，不翻译。</li><li><code>-s, --squeeze-repeats</code>: 用一次出现的字符替换<code>SET1</code>中列出的重复字符的每个输入序列。</li><li><code>-t, --truncate-set1</code>: 首先将<code>SET1</code>截断为<code>SET2</code>的长度。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="解释序列"><a href="#解释序列" class="headerlink" title="解释序列"></a>解释序列</h2><ul><li><code>\NNN</code>: 八进制值为<code>NNN</code>的字符(<code>1</code>到<code>3</code>个八进制数字)。</li><li><code>\\</code>: 反斜杠。</li><li><code>\a</code>: 可闻的<code>BEL</code>。</li><li><code>\b</code>: 退格键。</li><li><code>\f</code>: 换页。</li><li><code>\n</code>: 新行。</li><li><code>\r</code>: 返回。</li><li><code>\t</code>: 水平制表符。</li><li><code>\v</code>: 垂直制表符。</li><li><code>CHAR1-CHAR2</code>: 从<code>CHAR1</code>到<code>CHAR2</code>的所有字符按升序排列。</li><li><code>[CHAR*]</code>: 在<code>SET2</code>中，复制<code>CHAR</code>直到<code>SET1</code>的长度。</li><li><code>[CHAR*REPEAT]</code>: 重复<code>CHAR</code>的副本，如果以<code>0</code>开头，则重复八进制。</li><li><code>[:alnum:]</code>: 所有字母和数字。</li><li><code>[:alpha:]</code>: 所有字母。</li><li><code>[:blank:]</code>: 所有水平空白。</li><li><code>[:cntrl:]</code>: 所有控制字符。</li><li><code>[:digit:]</code>: 所有数字。</li><li><code>[:graph:]</code>: 所有可打印字符，不包括空格。</li><li><code>[:lower:]</code>: 所有小写字母。</li><li><code>[:print:]</code>: 所有可打印字符，包括空格。</li><li><code>[:punct:]</code>: 所有标点符号。</li><li><code>[:space:]</code>: 所有水平或垂直空白。</li><li><code>[:upper:]</code>: 所有大写字母。</li><li><code>[:xdigit:]</code>: 所有十六进制数字。</li><li><code>[=CHAR=]</code>: 等同于<code>CHAR</code>的所有字符。</li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p><code>file.txt</code>文件内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>将文件中的字母全部转换为大写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | tr [a-z] [A-Z]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELLO WORLD</span></span><br></pre></td></tr></table></figure><p>同样可以使用<code>[:lower]</code>与<code>[:upper]</code>参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | tr [:lower:] [:upper:]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HELLO WORLD</span></span><br></pre></td></tr></table></figure><p>将水平空白符转换为<code>\t</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | tr [:space:] &quot;\t&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello   World</span>   </span><br></pre></td></tr></table></figure><p>删除所有<code>o</code>字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | tr -d &quot;o&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hell Wrld</span></span><br></pre></td></tr></table></figure><p>删除所有数字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;My ID is 73535&quot; | tr -d [:digit:]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">My ID is</span></span><br></pre></td></tr></table></figure><p>取出字符串中的数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;My ID is 73535&quot; | tr -cd [:digit:]</span><br><span class="line"># 73535</span><br></pre></td></tr></table></figure><h1 id="traceroute命令"><a href="#traceroute命令" class="headerlink" title="traceroute命令"></a>traceroute命令</h1><p><code>traceroute</code>命令尝试跟踪<code>IP</code>数据包到某个<code>Internet</code>主机的路由，方法是使用一个小<code>ttl</code>(生存时间)启动探测数据包，然后侦听来自网关的<code>ICMP</code>超时回复，它以<code>ttl</code>为<code>1</code>开始探测，并将其增加<code>1</code>，直到获得<code>ICMP port unreachable</code>或<code>TCP reset</code>，这意味着我们到达了<code>host</code>，或达到了最大值(默认为<code>30</code>跳)，在每个<code>ttl</code>设置处发送三个探测(默认)，并打印一行，显示<code>ttl</code>、网关地址和每个探测的往返时间，在请求时，地址后面可以有附加信息，如果探测结果来自不同的网关，则会打印每个响应系统的地址，如果在<code>5.0</code>秒内(默认值)没有响应，则会为该探测器打印一个<code>*</code>。</p><h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">traceroute [-46dFITUnreAV] [-f first_ttl] [-g gate,...] [-i device] </span><br><span class="line">           [-m max_ttl] [-p port] [-s src_addr] [-q nqueries] </span><br><span class="line">           [-N squeries] [-t tos] [-l flow_label] [-w waittime] </span><br><span class="line">           [-z sendwait] [-UL] [-D] [-P proto] [--sport=port] [-M method] </span><br><span class="line">           [-O mod_options] [--mtu] [--back] host [packet_len]</span><br></pre></td></tr></table></figure><h2 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-4, -6</code>: 显式强制<code>IPv4</code>或<code>IPv6</code>跟踪路由，默认情况下，程序将尝试解析给定的名称，并自动选择适当的协议，如果解析主机名同时返回<code>IPv4</code>和<code>IPv6</code>地址，则<code>traceroute</code>将使用<code>IPv4</code>。</li><li><code>-I, --icmp</code>: 使用<code>ICMP ECHO</code>进行探测。</li><li><code>-T, --tcp</code>: 使用<code>TCP SYN</code>进行探测。</li><li><code>-d, --debug</code>: 启用套接字级调试，如果内核支持的话。</li><li><code>-F, --dont-fragment</code>: 不要对探测数据包进行分段，对于<code>IPv4</code>它还会设置<code>DF</code>位，该位告诉中间路由器也不要进行远程分段。通过<code>packet_len</code>命令参数更改探测数据包的大小，可以手动获取有关单个网络跃点的<code>MTU</code>的信息。从<code>Linux</code>内核<code>2.6.22</code>开始，非碎片化功能(例如<code>-F</code>或<code>--mtu</code>)才能正常工作，在该版本之前，<code>IPv6</code>始终是零散的，<code>IPv4</code>只能使用一次(从路由缓存中)发现的最终<code>mtu</code>，它可能小于设备的实际<code>mtu</code>。</li><li><code>-f first_ttl, --first=first_ttl</code>: 指定要启动的<code>TTL</code>，默认为<code>1</code>。</li><li><code>-g gate,..., --gateway=gate,...</code>: 告诉<code>traceroute</code>向传出数据包添加<code>IP</code>源路由选项，该选项告诉网络通过指定网关路由数据包(出于安全原因，大多数路由器已禁用源路由)，通常允许指定多个网关(以逗号分隔的列表)。对于<code>IPv6</code>允许使用<code>num</code>、<code>addr</code>、<code>addr</code>、<code>...</code>的形式，其中<code>num</code>是路由报头类型(默认为类型<code>2</code>)，注意，根据<code>rfc 5095</code>，现在不赞成使用<code>0</code>型路由头。</li><li><code>-i device, --interface=device</code>: 指定<code>traceroute</code>应该通过其发送数据包的接口，缺省情况下，接口是根据路由表选择的。</li><li><code>-m max_ttl, --max-hops=max_ttl</code>: 指定<code>traceroute</code>探测的最大跳数(最大生存时间值)，默认值为<code>30</code>。</li><li><code>-N squeries, --sim-queries=squeries</code>: 指定同时发送的探测报文数，同时发送多个探针可以大大提高跟踪路由的速度，默认值为<code>16</code>，注意某些路由器和主机可以使用<code>ICMP</code>速率限制，在这种情况下，指定太大的数字可能会导致某些响应丢失。</li><li><code>-n</code>: 在显示<code>IP</code>地址时不要尝试将它们映射到主机名。</li><li><code>-p port, --port=port</code>: 对于<code>UDP</code>跟踪，指定<code>traceroute</code>将使用的目的端口号，目标端口号将随每个探针递增，对于<code>ICMP</code>跟踪，指定初始<code>ICMP</code>序列值(每个探针也增加)，对于<code>TCP</code>和其他协议，仅指定要连接的(恒定)目标端口，使用<code>tcptraceroute</code>包装程序时，<code>-p</code>指定源端口。</li><li><code>-t tos, --tos=tos</code>: 对于<code>IPv4</code>，设置服务类型<code>TOS</code>和优先级值，有用的值是<code>16</code>低延迟和<code>8</code>高吞吐量，要使用某些<code>TOS</code>优先级值，必须是超级用户，对于<code>IPv6</code>，设置流量控制值。</li><li><code>-l flow_label, --flowlabel=flow_label</code>: 对<code>IPv6</code>数据包使用指定的<code>flow_label</code>。</li><li><code>-w MAX,HERE,NEAR, --wait=MAX,HERE,NEAR</code>: 设置等待探测响应的时间，以秒为单位，默认为<code>5.0</code>。</li><li><code>-q nqueries, --queries=nqueries</code>: 设置每个跃点的探测数据包数，默认值为<code>3</code>。</li><li><code>-r</code>: 绕过常规路由表，并直接发送到连接的网络上的主机，如果主机不在直接连接的网络上，则返回错误，此选项可用于通过没有路由的接口对本地主机执行<code>ping</code>操作。</li><li><code>-s src_addr, --source=src_addr</code>: 选择一个备用源地址，请注意必须选择一个接口的地址，默认情况下使用传出接口的地址。</li><li><code>-z sendwait, --sendwait=sendwait</code>: 探测之间的最小时间间隔，默认值为<code>0</code>，如果该值大于<code>10</code>，则以毫秒为单位指定一个数字，否则为秒数，也允许使用浮点值，当某些路由器对<code>ICMP</code>消息使用速率限制时非常有用。</li><li><code>-e, --extensions</code>: 显示<code>ICMP</code>扩展名，通用格式为<code>CLASS / TYPE</code>即后跟十六进制转储，所示的<code>MPLS</code>多协议标签交换数据已解析，格式为<code>MPLS:L=label,E=exp_use,S=stack_bottom,T=TTL (with any further objects separated by a slash (&quot;/&quot;))</code>。</li><li><code>-A, --as-path-lookups</code>: 在路由注册表中执行<code>AS</code>路径查找，并在相应地址后直接打印结果。</li><li><code>-M name  --module=name</code>: 使用指定的模块(内置或外部)用于<code>traceroute</code>操作，大多数方法都有其快捷方式，例如<code>-I</code>表示<code>-M icmp</code>等。</li><li><code>-O OPTS,..., --options=OPTS,...</code>: 将特定于模块的选项<code>OPTS</code>用于<code>traceroute</code>模块，允许几个<code>OPTS</code>，以逗号分隔，例如如果<code>OPTS</code>是<code>help</code>，则打印帮助信息。             </li><li><code>--sport=num</code>: 将源端口号用于传出数据包，表示为<code>-N 1</code>。 </li><li><code>--fwmark=num</code>： 为传出数据包设置防火墙标记。</li><li><code>-U  --udp</code>: 使用<code>UDP</code>到特定端口进行路由，而不是每个探针增加端口，默认端口为<code>53</code>。</li><li><code>-UL</code>: 使用<code>UDP LITE</code>进行路由，默认目标端口为<code>53</code>。</li><li><code>-D  --dccp</code>: 使用<code>DCCP</code>请求进行路由，默认端口为<code>33434</code>。</li><li><code>-P prot  --protocol=prot</code>: 使用协议保护的原始数据包进行路由。</li><li><code>--mtu</code>: 沿着被追踪的路径发现<code>MTU</code>，表示为<code>-F-N 1</code>。</li><li><code>--back</code>: 推断后向路径中的跳数，如果不同则打印。</li><li><code>-V</code>: 输出版本信息。</li><li><code>--help</code>: 输出帮助信息。</li></ul><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>使用<code>traceroute</code>查看路由信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.google.com</span><br></pre></td></tr></table></figure><p>指定<code>IPv4</code>查看路由信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -4 www.google.com</span><br></pre></td></tr></table></figure><p>指定要启动的<code>TTL</code>，默认为<code>1</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -f 3 www.google.com</span><br></pre></td></tr></table></figure><p>不将<code>IP</code>地址解析为其域名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -n www.google.com</span><br></pre></td></tr></table></figure><p>设置每个跃点的探测数，默认为<code>3</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -q 1 www.google.com</span><br></pre></td></tr></table></figure><p>指定完整的数据包长度，默认是<code>60</code>字节的数据包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.google.com 100</span><br></pre></td></tr></table></figure><p>设置要使用的目标端口，默认为<code>33434</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -p 20292 www.google.com</span><br></pre></td></tr></table></figure><h1 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h1><p><code>touch</code>命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。</p><h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [OPTION]... FILE...</span><br></pre></td></tr></table></figure><h2 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a</code>: 仅更改访问时间。</li><li><code>-c, --no-create</code>: 不创建任何文件。</li><li><code>-d, --date=STRING</code>: 解析<code>STRING</code>并使用其作为访问和修改时间。</li><li><code>-f</code>: 该参数被忽略。</li><li><code>-h, --no-dereference</code>: 影响每个符号链接，而不影响任何引用的文件，仅在可以更改符号链接时间戳的系统上有用。</li><li><code>-m</code>: 仅更改修改时间。</li><li><code>-r, --reference=FILE</code>: 使用此文件的时间而不是当前时间。</li><li><code>-t STAMP</code>: 使用<code>[[CC]YY]MMDDhhmm[.ss]</code>而不是当前时间。</li><li><code>--time=WORD</code>: 更改指定的时间，<code>WORD</code>是<code>access</code>、<code>atime</code>或<code>use</code>则等效于<code>-a</code>，<code>WORD</code>是<code>Modify</code>或<code>mtime</code>则等效于<code>-m</code>。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>创建一个空白文件，如果文件已经存在，它将更改文件的访问时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file.txt</span><br></pre></td></tr></table></figure><p>创建多个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /tmp/file1.txt /tmp/file2.txt /tmp/file3.txt</span><br></pre></td></tr></table></figure><p>模板文件名创建文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch -am 30 –nodirs /tmp/</span><br></pre></td></tr></table></figure><p>修改文件的访问时间并查看文件属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -a /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><p>修改文件的修改时间并查看文件属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -m /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><p>同时修改访问时间和修改时间并设置一个特定的访问与修改时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -am -t 202007010000.00 /tmp/file.txt &amp;&amp; stat /tmp/file.txt</span><br></pre></td></tr></table></figure><h1 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h1><p><code>top</code>命令提供运行系统的动态实时视图，其可以显示系统摘要信息，以及当前由内核管理的进程或线程的列表，显示的系统摘要信息的类型以及为任务显示的信息的类型、顺序和大小都是用户可配置的。</p><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -hv | -bcHisS -d delay -n limit -u|U user | -p pid -w [cols]</span><br></pre></td></tr></table></figure><h2 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-h</code>: 输出帮助信息。</li><li><code>-v</code>: 输出版本信息。</li><li><code>-b</code>: 以批处理模式启动<code>top</code>，这对于从<code>top</code>向其他程序或文件发送输出很有用，在这种模式下，<code>top</code>将不接受输入并运行，直到您使用’<code>-n</code>‘命令行选项设置了迭代次数限制或终止为止。</li><li><code>-c</code>: 以倒转最后一个记忆中的<code>c</code>状态开始，因此如果<code>top</code>显示命令行，那么现在该字段将显示程序名，反之亦然。</li><li><code>-d interval</code>: 指定屏幕更新之间的延迟，并覆盖个人配置文件中的相应值或启动默认值，启动后也可以使用<code>d</code>或<code>s</code>交互命令更改。</li><li><code>-H</code>: 指示<code>top</code>显示各个线程，如果没有此命令行选项，则显示每个进程中所有线程的总和，启动后可以使用<code>H</code>交互命令更改。</li><li><code>-i</code>: 空闲进程切换，以倒转最后一个记忆中的<code>i</code>状态开始，关闭此切换时，将不显示自上次更新以来未使用任何<code>CPU</code>的任务。</li><li><code>-n limit</code>: 指定<code>top</code>在结束前应产生的最大迭代次数或帧数。</li><li><code>-o</code>: 指定将对任务进行排序的字段的名称，与配置文件中反映的内容无关，您可以在字段名前面加上<code>+</code>或<code>-</code>，以覆盖排序方向，前导<code>+</code>将强制从高到低排序，而<code>-</code>将确保从低到高排序，此选项主要用于支持自动脚本化批处理模式操作。</li><li><code>-O</code>: 此选项作为上述<code>-o</code>选项的帮助形式，它将使<code>top</code>在单独的一行中打印每个可用的字段名，然后退出。</li><li><code>-p pid</code>: 仅监视具有指定进程<code>ID</code>的进程，此选项最多可以给予<code>20</code>次，也可以提供一个逗号分隔的列表，其中最多包含<code>20</code>个<code>PID</code>，允许两种方法混合使用，<code>pid</code>值为零将被视为<code>top</code>程序运行时的进程<code>id</code>，这只是一个命令行选项，如果您希望返回正常操作，则无需退出并重新启动<code>top</code>，只需发出以下任何交互式命令<code>=</code>、<code>u</code>或<code>U</code>，对于<code>p</code>、<code>u</code>和<code>U</code>命令行选项是互斥的。</li><li><code>-s</code>: 安全模式操作，以强制的安全模式启动<code>top</code>，即使对于<code>root</code>也是如此，通过系统配置文件可以更好地控制此模式。</li><li><code>-S</code>: 累计时间切换，以倒转最后一个记忆中的<code>S</code>状态开始，当累计时间模式打开时，每个进程都会列出它及其子进程使用的<code>cpu</code>时间。</li><li><code>-u user-id-or-name, -U user-id-or-name</code>: 仅显示用户<code>id</code>或用户名与给定进程匹配的进程，<code>-u</code>选项匹配有效用户，而<code>-U</code>选项匹配任何用户<code>real</code>、<code>effective</code>、<code>saved</code>或<code>filesystem</code>，在感叹号<code>!</code>前面加上前缀用户<code>id</code>或名称指示<code>top</code>仅显示用户与提供的进程不匹配的进程，<code>p</code>、<code>u</code>和<code>U</code>命令行选项是互斥的。</li><li><code>-w number</code>: 在批处理模式下，如果没有参数，<code>top</code>将使用<code>COLUMNS=</code>和<code>LINES=</code>环境变量(如果设置)格式化输出，否则，宽度将固定在最大<code>512</code>列，通过一个参数，可以减少或增加输出宽度(最多<code>512</code>行)，但行数被认为是无限的，在正常显示模式下，如果没有参数，<code>top</code>将尝试使用<code>COLUMNS=</code>和<code>LINES=</code>环境变量(如果设置)格式化输出，对于参数，输出宽度只能减小，不能增大，无论是使用环境变量还是带有<code>-w</code>的参数，当不处于批处理模式时，都不能超过实际的终端维度，注意如果不使用此命令行选项，输出宽度始终基于调用<code>top</code>的终端，无论是否处于批处理模式。</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>以下启动默认值操作假定没有相关配置文件，即没有用户自定义，此外带星号<code>*</code>的项目可以通过命令行覆盖。</p><ul><li><code>^Z</code>: 挂起。</li><li><code>fg</code>: 恢复挂起的命令。</li><li><code>&lt;Left&gt;</code>: 强制屏幕重绘。</li><li><code>A</code>: 交叉显示，默认全屏显示。</li><li><code>d</code>: <code>*</code>延迟时间，默认为<code>3s</code>。</li><li><code>H</code>: <code>*</code>线程模式，默认关闭。</li><li><code>I</code>: <code>Irix</code>模式，默认开启。</li><li><code>p</code>: <code>*</code>监控<code>PID</code>，默认显示所有进程。</li><li><code>1</code>: 查看服务器的<code>cpu</code>逻辑数。</li><li><code>M</code>: 根据驻留内存大小进行排序。</li><li><code>P</code>: 根据<code>CPU</code>使用百分比大小进行排序。</li><li><code>T</code>: 根据时间<code>/</code>累计时间进行排序。</li><li><code>c</code>: 切换显示命令名称和完整命令行。</li><li><code>t</code>: 切换显示进程和<code>CPU</code>信息。</li><li><code>m</code>: 切换显示内存信息。</li><li><code>l</code>: 切换显示平均负载和启动时间信息 。</li><li><code>o</code>: 改变显示项目的顺序。</li><li><code>f</code>: 从当前显示中添加或删除列项目。</li><li><code>S</code>: 切换到累计模式。</li><li><code>s</code>: 改变两次刷新之间的延迟时间，系统将提示用户输入新的时间，单位为<code>s</code>，如果有小数，就换算成<code>ms</code>。</li><li><code>q</code>: 退出<code>top</code>命令。 </li><li><code>i</code>: 忽略闲置和僵尸进程。</li><li><code>k</code>: 终止一个进程。</li></ul><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><code>total</code>: 进程总数。</li><li><code>running</code>: 正在运行的进程数。</li><li><code>sleeping</code>: 睡眠的进程数。</li><li><code>stopped</code>: 停止的进程数。</li><li><code>zombie</code>: 僵尸进程数。</li></ul><h3 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h3><ul><li><code>us</code>: 用户空间占用<code>CPU</code>百分比。</li><li><code>sy</code>: 内核空间占用<code>CPU</code>百分比。</li><li><code>ni</code>: 用户进程空间内改变过优先级的进程占用<code>CPU</code>百分比。</li><li><code>id</code>: 空闲<code>CPU</code>百分比。</li><li><code>wa</code>: 等待输入输出的<code>CPU</code>时间百分比。</li><li><code>hi</code>: 硬件<code>CPU</code>中断占用百分比。</li><li><code>si</code>: 软中断占用百分比。</li><li><code>st:</code>虚拟机占用百分比。</li></ul><h3 id="列字段"><a href="#列字段" class="headerlink" title="列字段"></a>列字段</h3><p>可以使用<code>f</code>交互命令自定义列的位置及其是否可显示。</p><ul><li><code>%CPU</code>: <code>CPU Usage</code>，<code>CPU</code>使用率，任务自上次屏幕更新以来占用的<code>CPU</code>时间份额，表示为总<code>CPU</code>时间的百分比，在真正的<code>SMP</code>环境中，如果一个进程是多线程的，并且<code>top</code>不是以线程模式运行的，那么可能会报告大于<code>100%</code>的数量，您可以使用<code>H</code>交互命令切换线程模式，同样对于多处理器环境，如果<code>Irixmode</code>处于关闭状态，<code>top</code>将在<code>Solarismode</code>下运行，其中任务的<code>cpu</code>使用量将除以<code>cpu</code>总数，您可以使用<code>I</code>交互命令切换<code>Irix/Solaris</code>模式。</li><li><code>%MEM</code>: <code>Memory Usage (RES)</code>，内存使用情况，任务当前使用的可用物理内存共享。</li><li><code>CGROUPS</code>: <code>Control Groups</code>，控制组，流程所属的控制组的名称，如果不适用于该流程，则为<code>-</code>，控制组用于在安装定义的进程组之间分配资源(<code>cpu</code>、内存、网络带宽等)，它们支持对这些资源的分配、拒绝、优先排序、管理和监视进行细粒度控制，一个系统上可以同时存在许多不同的<code>cgroup</code>层次结构，并且每个层次结构都连接到一个或多个子系统，子系统表示单个资源，注意<code>: CGROUPS</code>字段与大多数列不同，不是固定宽度的，显示时，它加上任何其他可变宽度列将分配所有剩余屏幕宽度(最多<code>512</code>个字符)，即便如此，这种可变宽度的字段仍然会受到截断。</li><li><code>CODE</code>: <code>Code Size (KiB)</code>，代码大小<code>KiB</code>，用于可执行代码的物理内存量，也称为文本驻留集大小或<code>TRS</code>。</li><li><code>COMMAND</code>: <code>Command Name or Command Line</code>，命令名或命令行，显示用于启动任务的命令行或关联程序的名称，您可以使用<code>c</code>在命令行和名称之间切换，这既是一个命令行选项，也是一个交互式命令，当您选择显示命令行时，没有命令行的进程(如内核线程)将只显示程序名，此字段也可能受视图显示模式的影响，注意<code>COMMAND</code>字段与大多数列不同，不是固定宽度的，显示时，它加上任何其他可变宽度列将分配所有剩余屏幕宽度(最多<code>512</code>个字符)，即便如此，这种可变宽度的字段仍然会受到截断，当显示命令行时，此字段尤其如此。</li><li><code>DATA</code>: <code>Data + Stack Size (KiB)</code>，用于可执行代码以外的物理内存量，也称为数据驻留集大小或<code>DRS</code>。</li><li><code>ENVIRON</code>: <code>Environment variables</code>，显示各个进程看到的所有环境变量(如果有)，这些变量将以原始的本机顺序显示，而不是您习惯于用非限定的<code>set</code>看到的排序顺序，注意<code>ENVIRON</code>字段与大多数列不同，不是固定宽度的，显示时，它加上任何其他可变宽度列将分配所有剩余屏幕宽度(最多<code>512</code>个字符)，即便如此，这种可变宽度的字段仍然会受到截断。</li><li><code>Flags</code>: <code>Task Flags</code>，此列表示任务的当前调度标志，这些标志以十六进制表示，并且不包含零，这些标志正式记录在<code>&lt;linux/sched.h&gt;</code>中。</li><li><code>GID</code>: <code>Group Id</code>，有效组<code>ID</code>。</li><li><code>GROUP</code>: <code>Group Name</code>，有效组名。</li><li><code>NI</code>: <code>Nice Value</code>，负的<code>nice</code>值意味着更高的优先级，而正的<code>nice</code>值意味着更低的优先级，此字段中的零表示在确定任务的调度能力时不会调整优先级。</li><li><code>P</code>: <code>Last used CPU (SMP)</code>，表示最后使用的处理器的数字，在真正的<code>SMP</code>环境中，这可能会频繁更改，因为内核有意使用弱关联，另外，运行<code>top</code>的行为可能会破坏这种弱关联，并导致更多进程更频繁地更改<code>cpu</code>(因为对<code>cpu</code>时间的额外需求)。</li><li><code>PGRP</code>: <code>Process Group Id</code>，每个进程都是唯一进程组的成员，该进程组用于分配信号，并由终端对其输入和输出请求进行仲裁，创建(<code>fork</code>)流程时，它将成为其父流程组的成员，按照约定，该值等于流程组的第一个成员(称为流程组长)的流程<code>ID</code>。</li><li><code>PID</code>: <code>Process Id</code>，任务的唯一进程<code>ID</code>，它定期包装，但从不在零重新启动，在内核中，它是一个由<code>task_struct</code>定义的可调度实体，此值还可用作<code>:</code>进程组<code>ID</code>、会话负责人的会话<code>ID</code>、线程组负责人的线程组<code>ID</code>、进程组负责人的<code>TTY</code>进程组<code>ID</code>。</li><li><code>PPID</code>: <code>Parent Process Id</code>，任务父进程的进程<code>ID</code>(<code>pid</code>)。</li><li><code>PR</code>: <code>Priority</code>，任务的调度优先级，如果在该字段中看到<code>rt</code>，则表示任务正在实时调度优先级下运行，在<code>linux</code>下，实时优先级有些误导，因为传统上操作本身是不可抢占的，虽然<code>2.6</code>内核可以被大部分抢占，但并不总是这样。</li><li><code>RES</code>: <code>Resident Memory Size (KiB)</code>，任务使用的非交换物理内存。</li><li><code>RUID</code>: <code>Real User Id</code>，真实用户<code>ID</code>。</li><li><code>RUSER</code>: <code>Real User Name</code>，真实的用户名。</li><li><code>S</code>: <code>Process Status</code>，任务的状态，可以是: <code>D</code>不间断睡眠、<code>R</code>运行、<code>S</code>睡眠、<code>T</code>跟踪或停止、<code>Z</code>僵尸，显示为正在运行的任务应该更恰当地被认为是准备运行的——它们的任务结构只在<code>Linux</code>运行队列中表示，即使没有真正的<code>SMP</code>机器，根据<code>top</code>的延迟间隔和<code>nice</code>值，也可能会看到许多处于这种状态的任务。</li><li><code>SHR</code>: <code>Shared Memory Size (KiB)</code>，一个任务可用的共享内存量，通常不是所有的内存都是驻留的，它只是反映了可能与其他进程共享的内存。</li><li><code>SID</code>: <code>Session Id</code>，会话是进程组的集合，通常由登录<code>shell</code>建立，新<code>fork</code>的进程加入其创建者的会话，按照惯例，这个值等于会话的第一个成员的进程<code>ID</code>，称为会话头，通常是登录<code>shell</code>。</li><li><code>SUID</code>: <code>Saved User Id</code>，保存的用户<code>ID</code>。</li><li><code>SUPGIDS</code>: <code>Supplementary Group IDs</code>，建立的或从任务父级继承的任何补充组的<code>ID</code>，它们以逗号分隔的列表显示，注意<code>SUPGIDS</code>字段与大多数列不同，不是固定宽度的，显示时，它加上任何其他可变宽度列将分配所有剩余屏幕宽度(最多<code>512</code>个字符)，即便如此，这种可变宽度的字段仍然会受到截断。</li><li><code>SUPGRPS</code>: <code>Supplementary Group Names</code>，登录时建立的或从任务父级继承的任何补充组的名称，它们以逗号分隔的列表显示，注意<code>: SUPGRPS</code>字段与大多数列不同，不是固定宽度的，显示时，它加上任何其他可变宽度列将分配所有剩余屏幕宽度(最多<code>512</code>个字符)，即便如此，这种可变宽度的字段仍然会受到截断。</li><li><code>SUSER</code>: <code>Saved User Name</code>，保存的用户名。</li><li><code>SWAP</code>: <code>Swapped Size (KiB)</code>，任务地址空间的非驻留部分。</li><li><code>TGID</code>: <code>Thread Group Id</code>，任务所属的线程组的<code>ID</code>，它是线程组负责人的<code>PID</code>，在内核术语中，它表示那些共享<code>mm_struct</code>的任务。</li><li><code>TIME</code>: <code>CPU Time</code>，任务自启动以来使用的总<code>CPU</code>时间，当累积模式打开时，每个进程都会列出它及其子进程使用的<code>cpu</code>时间，使用<code>S</code>切换累积模式，这既是命令行选项，也是交互式命令，有关此模式的其他信息，请参阅<code>S</code>交互命令。</li><li><code>TIME+</code>: <code>CPU Time, hundredths</code>，与<code>Time</code>相同，但通过百分之一秒反映出更多的粒度。</li><li><code>TPGID</code>: <code>Tty Process Group Id</code>，连接的<code>tty</code>的前台进程的进程组<code>ID</code>，如果进程未连接到终端，则为<code>-1</code>，按照惯例，此值等于流程组长的流程<code>ID</code>。</li><li><code>TTY</code>: <code>Controlling Tty</code>，控制终端的名称，这通常是启动进程的设备(串口、<code>pty</code>等)，并用于输入或输出，但是，任务不需要与终端相关联，在这种情况下，您将看到<code>?</code>显示。</li><li><code>UID</code>: <code>User Id</code>，任务所有者的有效用户<code>ID</code>。</li><li><code>USED</code>: <code>Memory in Use (KiB)</code>，此字段表示任务已使用的非交换物理内存(<code>RES</code>)加上其地址空间(<code>SWAP</code>)的非驻留部分。</li><li><code>USER</code>: <code>User Name</code>，任务所有者的有效用户名。</li><li><code>VIRT</code>: <code>Virtual Memory Size (KiB)</code>，任务使用的虚拟内存总量。它包括所有代码、数据和共享库，以及已调出的页面和已映射但未使用的页面。</li><li><code>WCHAN</code>: <code>Sleeping in Function</code>，取决于内核链接映射的可用性系统地图)，此字段将显示任务当前休眠的内核函数的名称或地址，正在运行的任务将在此列中显示一个破折号<code>-</code>，通过显示此字段，<code>top</code>自己的工作集可以增加<code>700Kb</code>以上，具体取决于内核版本，如果发生这种情况，减少开销的唯一方法就是停止并重新启动<code>top</code>。</li><li><code>nDRT</code>: <code>Dirty Pages Count</code>，自上次写入辅助存储器以来已修改的页数，<code>dirty pages</code>必须先写入辅助存储器，然后才能将相应的物理内存位置用于其他虚拟页。</li><li><code>nMaj</code>: <code>Major Page Fault Count</code>，任务发生的主要页错误数，当进程试图读取或写入其地址空间中当前不存在的虚拟页时，会发生页错误，一个主要的页面错误是当辅助存储访问涉及到使该页面可用时。</li><li><code>nMin</code>: <code>Minor Page Fault count</code>，任务发生的次要页面错误数，当进程试图读取或写入其地址空间中当前不存在的虚拟页时，会发生页错误，在使该页可用时，较小的页错误不涉及辅助存储器访问。</li><li><code>nTH</code>: <code>Number of Threads</code>，与进程关联的线程数。</li><li><code>nsIPC</code>: <code>IPC namespace</code>，用于隔离进程间通信(<code>IPC</code>)资源(如<code>SystemVIPC</code>对象和<code>POSIX</code>消息队列)的命名空间的<code>Inode</code>。</li><li><code>nsMNT</code>: <code>MNT namespace</code>，命名空间的<code>Inode</code>，用于隔离文件系统装入点，从而提供文件系统层次结构的不同视图。</li><li><code>nsNET</code>: <code>NET namespace</code>，命名空间的<code>Inode</code>，用于隔离网络设备、<code>IP</code>地址、<code>IP</code>路由、端口号等资源。</li><li><code>nsPID</code>: <code>PID namespace</code>，命名空间的<code>Inode</code>，用于隔离进程<code>ID</code>号，这意味着它们不必保持唯一，因此，每个这样的名称空间都可以有自己的<code>init</code>(<code>PID#1</code>)来管理各种初始化任务并获取孤立的子进程。</li><li><code>nsUSER</code>: <code>USER namespace</code>，用于隔离用户和组<code>ID</code>号的命名空间的<code>Inode</code>，因此，一个进程可以在用户名称空间外有一个普通的未授权用户<code>ID</code>，而在该名称空间内有一个具有完全根权限的用户<code>ID0</code>。</li><li><code>nsUTS</code>: <code>UTS namespace</code>，用于隔离主机名和<code>NIS</code>域名的命名空间的<code>Inode, UTS</code>的意思是<code>UNIX</code>分时系统。</li><li><code>vMj</code>: <code>Major Page Fault Count Delta</code>，自上次更新以来发生的主要页错误数。</li><li><code>vMn</code>: <code>Minor Page Fault Count Delta</code>，自上次更新以来发生的次要页面错误的数量。</li></ul><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>显示进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>显示完整命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure><p>以批处理模式显示程序信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b</span><br></pre></td></tr></table></figure><p>以累积模式显示程序信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -S</span><br></pre></td></tr></table></figure><p>设置信息更新次数，表示更新两次后终止更新显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -n 2</span><br></pre></td></tr></table></figure><p>设置信息更新时间，表示更新周期为<code>3</code>秒。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 3</span><br></pre></td></tr></table></figure><p>显示指定的进程信息，<code>CPU</code>、内存占用率等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 131</span><br></pre></td></tr></table></figure><p>不能利用交互式指令来对进程下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -s</span><br></pre></td></tr></table></figure><h1 id="tmpwatch命令"><a href="#tmpwatch命令" class="headerlink" title="tmpwatch命令"></a>tmpwatch命令</h1><p><code>tmpwatch</code>递归删除给定时间内未访问的文件，通常用于清理用于临时存放空间的目录，并可以设置文件超期时间，默认单位以小时计算。</p><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch [-u | -m | -c] [-MUadfqstvx] [--verbose] [--force] [--all] [--nodirs] [--nosymlinks] [--test] [--fuser] [--quiet] [--atime | --mtime | --ctime] [--dirmtime] [--exclude path ] [--exclude-user user ] time dirs</span><br></pre></td></tr></table></figure><h2 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --all</code>: 删除所有文件类型，而不仅仅是常规文件，符号链接和目录。</li><li><code>-c, --ctime</code>: 根据文件的<code>ctime</code>即<code>inode</code>更改时间，而不是<code>atime</code>来决定删除文件，对于目录根据<code>mtime</code>做出是否删除的决定。</li><li><code>-d, --nodirs</code>: 即使目录为空，也不要尝试删除它们。</li><li><code>-f, --force</code>: 即使<code>root</code>没有写访问权限，也删除文件类似于<code>rm -f</code>。</li><li><code>-l, --nosymlinks</code>: 不要尝试删除符号链接。</li><li><code>-m, --mtime</code>: 根据文件的<code>mtime</code>即修改时间而不是<code>atime</code>来决定删除文件。</li><li><code>-M, --dirmtime</code>: 根据目录的<code>mtime</code>即修改时间而不是<code>atime</code>来决定删除目录，完全忽略目录时间。</li><li><code>-q, --quiet</code>: 仅报告致命错误。</li><li><code>-s, --fuser</code>: 尝试使用<code>fuser</code>命令来查看文件是否已打开，然后再将其删除，默认情况下未启用，在某些情况下确实有帮助。</li><li><code>-t, --test</code>: 不要删除文件，但要执行删除它们的动作，这意味着<code>-v</code>。</li><li><code>-u, --atime</code>: 根据文件的访问时间来决定是否删除文件，这是默认值，请注意定期的<code>updatedb</code>文件系统扫描会保留最近的目录时间。</li><li><code>-U, --exclude-user=user</code>: 不要删除用户拥有的文件，该文件可以是用户名或数字用户<code>ID</code>。</li><li><code>-v, --verbose</code>: 打印详细显示，有两种详细级别可用。</li><li><code>-x, --exclude=path</code>: 跳过路径，如果<code>path</code>是目录，则包含在其中的所有文件也会被跳过，如果路径不存在，则它必须是不包含符号链接的绝对路径。</li><li><code>-X, --exclude-pattern=pattern</code>: 跳过路径匹配模式，如果目录与<code>pattern</code>匹配，其中的所有文件也将被跳过，模式必须匹配不包含符号链接的绝对路径。</li></ul><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>要从<code>/var/log/</code>日志目录中删除<code>30d</code>以上未访问的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch 30d /var/log/</span><br></pre></td></tr></table></figure><p>列出<code>/tmp/</code>缓存目录中至少<code>30</code>小时未修改的所有文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch –mtime 30 –nodirs /tmp/ –test</span><br></pre></td></tr></table></figure><p>删除<code>/tmp/</code>缓存目录中至少<code>30</code>个小时未访问的所有文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch -am 30 –nodirs /tmp/</span><br></pre></td></tr></table></figure><h2 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WindrunnerMax/EveryDay</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://linux.die.net/man/8/tmpwatch</span><br><span class="line">https://www.runoob.com/linux/linux-comm-tmpwatch.html</span><br><span class="line">https://www.interserver.net/tips/kb/tmpwatch-command-linux/</span><br></pre></td></tr></table></figure><h1 id="tmpwatch命令-1"><a href="#tmpwatch命令-1" class="headerlink" title="tmpwatch命令"></a>tmpwatch命令</h1><p><code>tmpwatch</code>递归删除给定时间内未访问的文件，通常用于清理用于临时存放空间的目录，并可以设置文件超期时间，默认单位以小时计算。</p><h2 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch [-u | -m | -c] [-MUadfqstvx] [--verbose] [--force] [--all] [--nodirs] [--nosymlinks] [--test] [--fuser] [--quiet] [--atime | --mtime | --ctime] [--dirmtime] [--exclude path ] [--exclude-user user ] time dirs</span><br></pre></td></tr></table></figure><h2 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --all</code>: 删除所有文件类型，而不仅仅是常规文件，符号链接和目录。</li><li><code>-c, --ctime</code>: 根据文件的<code>ctime</code>即<code>inode</code>更改时间，而不是<code>atime</code>来决定删除文件，对于目录根据<code>mtime</code>做出是否删除的决定。</li><li><code>-d, --nodirs</code>: 即使目录为空，也不要尝试删除它们。</li><li><code>-f, --force</code>: 即使<code>root</code>没有写访问权限，也删除文件类似于<code>rm -f</code>。</li><li><code>-l, --nosymlinks</code>: 不要尝试删除符号链接。</li><li><code>-m, --mtime</code>: 根据文件的<code>mtime</code>即修改时间而不是<code>atime</code>来决定删除文件。</li><li><code>-M, --dirmtime</code>: 根据目录的<code>mtime</code>即修改时间而不是<code>atime</code>来决定删除目录，完全忽略目录时间。</li><li><code>-q, --quiet</code>: 仅报告致命错误。</li><li><code>-s, --fuser</code>: 尝试使用<code>fuser</code>命令来查看文件是否已打开，然后再将其删除，默认情况下未启用，在某些情况下确实有帮助。</li><li><code>-t, --test</code>: 不要删除文件，但要执行删除它们的动作，这意味着<code>-v</code>。</li><li><code>-u, --atime</code>: 根据文件的访问时间来决定是否删除文件，这是默认值，请注意定期的<code>updatedb</code>文件系统扫描会保留最近的目录时间。</li><li><code>-U, --exclude-user=user</code>: 不要删除用户拥有的文件，该文件可以是用户名或数字用户<code>ID</code>。</li><li><code>-v, --verbose</code>: 打印详细显示，有两种详细级别可用。</li><li><code>-x, --exclude=path</code>: 跳过路径，如果<code>path</code>是目录，则包含在其中的所有文件也会被跳过，如果路径不存在，则它必须是不包含符号链接的绝对路径。</li><li><code>-X, --exclude-pattern=pattern</code>: 跳过路径匹配模式，如果目录与<code>pattern</code>匹配，其中的所有文件也将被跳过，模式必须匹配不包含符号链接的绝对路径。</li></ul><h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p>要从<code>/var/log/</code>日志目录中删除<code>30d</code>以上未访问的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch 30d /var/log/</span><br></pre></td></tr></table></figure><p>列出<code>/tmp/</code>缓存目录中至少<code>30</code>小时未修改的所有文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch –mtime 30 –nodirs /tmp/ –test</span><br></pre></td></tr></table></figure><p>删除<code>/tmp/</code>缓存目录中至少<code>30</code>个小时未访问的所有文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmpwatch -am 30 –nodirs /tmp/</span><br></pre></td></tr></table></figure><h1 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h1><p><code>tee</code>命令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><h2 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --append</code>: 追加到已有文件的后面，而不是覆盖文件。</li><li><code>-i, --ignore-interrupts</code>: 忽略中断信号。</li><li><code>-p</code>: 诊断写入非管道的错误。</li><li><code>--output-error[=MODE]</code>: 设置写错误时的行为。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul><li><code>warn</code>: 诊断写入任何输出的错误。</li><li><code>warn-nopipe</code>: 诊断写入任何输出而不是管道的错误。</li><li><code>exit</code>: 当错误写入任何输出时退出。</li><li><code>exit-nopipe</code>: 当写入任何输出（不是管道）时出错时退出。</li></ul><h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>将用户输入的数据同时保存到文件<code>file1.txt</code>和<code>file2.txt</code>中，输入文件信息后回车即可得到输出反馈。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee file1.txt file2.txt </span><br></pre></td></tr></table></figure><p>将用户输入的数据追加到<code>file1.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee -a file1.txt  </span><br></pre></td></tr></table></figure><p><code>ls</code>列出当前目录中所有文件扩展名为<code>.txt</code>的所有文件，每行一个文件名，将输出通过管道传输到<code>wc</code>，将行进行计数并输出数字，输出通过管道传输到<code>tee</code>，将输出写入终端，并将信息写入文件<code>count.txt</code>，即写入文件扩展名为<code>.txt</code>的所有文件的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -1 *.txt | wc -l | tee count.txt</span><br></pre></td></tr></table></figure><h1 id="tee命令-1"><a href="#tee命令-1" class="headerlink" title="tee命令"></a>tee命令</h1><p><code>tee</code>命令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><h2 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --append</code>: 追加到已有文件的后面，而不是覆盖文件。</li><li><code>-i, --ignore-interrupts</code>: 忽略中断信号。</li><li><code>-p</code>: 诊断写入非管道的错误。</li><li><code>--output-error[=MODE]</code>: 设置写错误时的行为。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息</li></ul><h2 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h2><ul><li><code>warn</code>: 诊断写入任何输出的错误。</li><li><code>warn-nopipe</code>: 诊断写入任何输出而不是管道的错误。</li><li><code>exit</code>: 当错误写入任何输出时退出。</li><li><code>exit-nopipe</code>: 当写入任何输出（不是管道）时出错时退出。</li></ul><h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>将用户输入的数据同时保存到文件<code>file1.txt</code>和<code>file2.txt</code>中，输入文件信息后回车即可得到输出反馈。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee file1.txt file2.txt </span><br></pre></td></tr></table></figure><p>将用户输入的数据追加到<code>file1.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee -a file1.txt  </span><br></pre></td></tr></table></figure><p><code>ls</code>列出当前目录中所有文件扩展名为<code>.txt</code>的所有文件，每行一个文件名，将输出通过管道传输到<code>wc</code>，将行进行计数并输出数字，输出通过管道传输到<code>tee</code>，将输出写入终端，并将信息写入文件<code>count.txt</code>，即写入文件扩展名为<code>.txt</code>的所有文件的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -1 *.txt | wc -l | tee count.txt</span><br></pre></td></tr></table></figure><h1 id="split命令"><a href="#split命令" class="headerlink" title="split命令"></a>split命令</h1><p><code>split</code>命令用于将大文件分割成较小的文件，在默认情况下将按照每<code>1000</code>行切割成一个小文件。</p><h2 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split [OPTION]... [FILE [PREFIX]]</span><br></pre></td></tr></table></figure><h2 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --suffix-length=N</code>: 使用长度为<code>N</code>的后缀，默认为<code>2</code>。</li><li><code>--additional-suffix=SUFFIX</code>: 将额外的<code>SUFFIX</code>插入文件名。</li><li><code>-b, --bytes=SIZE</code>: 每个输出文件放置<code>SIZE</code>字节，即指定每多少字节切成一个小文件。</li><li><code>-C, --line-bytes=SIZE</code>: 每个输出文件最多放入<code>SIZE</code>个字节行，与参数<code>-b</code>相似，但是在切割时将尽量维持每行的完整性。</li><li><code>-d</code>: 使用数字后缀而不是字母。</li><li><code>--numeric-suffixes[=FROM]</code>: 与<code>-d</code>相同，但允许设置起始值。</li><li><code>-e, --elide-empty-files</code>: 不使用<code>-n</code>生成空的输出文件。</li><li><code>--filter=COMMAND</code>: 写入<code>shell</code>命令<code>COMMAND</code>，文件名是<code>$FILE</code>。</li><li><code>-l, --lines=NUMBER</code>: 每个输出文件放入<code>NUMBER</code>行。</li><li><code>-n, --number=CHUNKS</code>: 生成<code>CHUNKS</code>输出文件，<code>CHUNKS</code>可以取的值有，<code>N</code>:根据输入大小分为<code>N</code>个文件，<code>K/N</code>:将<code>N</code>的第<code>K</code>个输出到标准输出，<code>l/N</code>: 分割成<code>N</code>个文件，不分割行，<code>l/K/N</code>:输出<code>K</code>的第<code>N</code>到标准输出，而不分割线，<code>r/N</code>:类似于<code>l</code>，但同样使用循环分布<code>r/K/N</code>，但仅将<code>N</code>的第<code>K</code>个输出到标准输出。</li><li><code>-t, --separator=SEP</code>: 使用<code>SEP</code>代替换行符作为记录分隔符，<code>\0</code>即<code>0</code>指定<code>NUL</code>字符。</li><li><code>-u, --unbuffered</code>: 立即使用<code>-n r/...</code>将输入复制到输出。</li><li><code>--verbose</code>: 在打开每个输出文件之前，输出详细的信息。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h2><p>将文件<code>tmp/file.txt</code>分<code>N</code>个独立的文件，分别为<code>newaa</code>、<code>newab</code>、<code>newac</code>、<code>...</code>，每个文件包含<code>2</code>个字节的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -b 2 /tmp/file.txt new</span><br></pre></td></tr></table></figure><p>将文件<code>tmp/file.txt</code>分<code>N</code>个独立的文件，分别为<code>newaa</code>、<code>newab</code>、<code>newac</code>、<code>...</code>，每个文件包含<code>2</code>行数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -l 2 /tmp/file.txt new</span><br></pre></td></tr></table></figure><p>将文件<code>tmp/file.txt</code>分<code>N</code>个独立的文件，以数字作为后缀，每个文件包含<code>2</code>行数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split -d -l 2 /tmp/file.txt new</span><br></pre></td></tr></table></figure><h1 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h1><p><code>sort</code>命令用于将文本文件内容加以排序，可针对文本文件的内容，以行为单位来排序。</p><h2 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line">sort [OPTION]... --files0-from=F</span><br></pre></td></tr></table></figure><h2 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --ignore-leading-blanks</code>: 忽略前导空格。</li><li><code>-d, --dictionary-order</code>: 只考虑空格和字母数字字符。</li><li><code>-f, --ignore-case</code>: 将小写字符转为大写字符。</li><li><code>-g, --general-numeric-sort</code>: 按一般数值进行比较。</li><li><code>-i, --ignore-nonprinting</code>: 只考虑可打印字符。</li><li><code>-M, --month-sort</code>: 比较<code>JAN &lt; ... &lt; DEC</code>。</li><li><code>-h, --human-numeric-sort</code>: 比较人类可读的数字，例如<code>2K</code>、<code>1G</code>。</li><li><code>-n, --numeric-sort</code>: 根据字符串数值进行比较。</li><li><code>-R, --random-sort</code>: 按键的随机哈希排序。</li><li><code>--random-source=FILE</code>: 从<code>FILE</code>中获取随机字节。</li><li><code>-r, --reverse</code>: 反转比较结果。</li><li><code>--sort=WORD</code>: 根据<code>WORD</code>排序：一般数字<code>-g</code>，chan数字<code>-h</code>，月份<code>-M</code>，数字<code>-n</code>，随机-<code>R</code>，版本<code>-V</code>。</li><li><code>--batch-size=NMERGE</code>: 一次最多合并<code>NMERGE</code>输入，对于更多输入，请使用临时文件。</li><li><code>-c, --check, --check=diagnose-first</code>: 检查已排序的输入，不排序。</li><li><code>-C, --check=quiet, --check=silent</code>: 类似于<code>-c</code>但不报告第一行错误。</li><li><code>--compress-program=PROG</code>: 用<code>PROG</code>压缩临时文件，用<code>PROG-d</code>解压临时文件。</li><li><code>--debug</code>: 注释行中用于排序的部分，并向<code>stderr</code>警告可疑用法。</li><li><code>--files0-from=F</code>: 从文件<code>F</code>中以<code>NUL</code>结尾的名称指定的文件读取输入，如果<code>F</code>是<code>-</code>，则从标准输入读取名称。</li><li><code>-k, --key=POS1[,POS2]</code>: 在<code>POS1</code>处开始键(原点<code>1</code>)，在<code>POS2</code>处结束键(默认行结束)。</li><li><code>-m, --merge</code>: 合并已排序的文件，不排序。</li><li><code>-o, --output=FILE</code>: 将结果写入<code>FILE</code>而不是标准输出。</li><li><code>-s, --stable</code>: 通过禁用最后的比较来稳定排序。</li><li><code>-t, --field-separator=SEP</code>: 使用<code>SEP</code>代替非空到空的转换。</li><li><code>-T, --temporary-directory=DIR</code>: 将<code>DIR</code>用于临时文件，而不是<code>$TMPDIR</code>或<code>/tmp</code>多个选项指定多个目录。</li><li><code>--parallel=N</code>: 将同时运行的排序数更改为<code>N</code>。</li><li><code>-u, --unique</code>: 对于<code>-c</code>检查严格的顺序，只输出相等运行的第一个。</li><li><code>-z, --zero-terminated</code>: 以<code>0</code>字节结束行，而不是换行。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h2><p><code>file.txt</code>、<code>file1.txt</code>、<code>file2.txt</code>文件内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># file.txt</span><br><span class="line">abhishek</span><br><span class="line">chitransh</span><br><span class="line">satish</span><br><span class="line">rajan</span><br><span class="line">naveen</span><br><span class="line">divyam</span><br><span class="line">harsh</span><br><span class="line"></span><br><span class="line"># file1.txt</span><br><span class="line">50</span><br><span class="line">39</span><br><span class="line">15</span><br><span class="line">89</span><br><span class="line">200</span><br><span class="line"></span><br><span class="line"># file2.txt</span><br><span class="line">abc</span><br><span class="line">apple</span><br><span class="line">BALL</span><br><span class="line">Abc</span><br><span class="line">bat</span><br><span class="line">bat</span><br></pre></td></tr></table></figure><p>对<code>file.txt</code>文件内容进行排序，要保存的话需要使用输出重定向。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">abhishek</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chitransh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">divyam</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">harsh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">naveen</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rajan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">satish</span></span><br><span class="line"></span><br><span class="line">sort file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">abc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Abc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apple</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BALL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bat</span></span><br></pre></td></tr></table></figure><p>可以使用<code>-r</code>标志执行逆序排序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sort -r file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">satish</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rajan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">naveen</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">harsh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">divyam</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chitransh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">abhishek</span></span><br></pre></td></tr></table></figure><p>使用<code>-n</code>对数字进行排序，不使用<code>-n</code>的话则会使用字典序排序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sort -n file1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">15</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">39</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">89</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">200</span></span><br><span class="line"></span><br><span class="line">sort file1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">15</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">200</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">39</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">89</span></span><br></pre></td></tr></table></figure><p>要对带有反向数字数据的文件进行排序，我们可以使用下面<code>-nr</code>两个选项的组合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort -nr file1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">200</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">89</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">50</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">39</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">15</span></span><br></pre></td></tr></table></figure><p>使用<code>-u</code>排序并删除重复项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort -u file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">abc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Abc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apple</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BALL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bat</span></span><br></pre></td></tr></table></figure><p>使用<code>-c</code>检查文件是否已经按照顺序排序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort -c file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sort</span>: file2.txt:4: disorder: Abc</span></span><br></pre></td></tr></table></figure><h1 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h1><p> <code>sed</code>命令是利用脚本来处理文本文件，可依照脚本的指令来处理、编辑文本文件，主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><h2 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]...</span><br></pre></td></tr></table></figure><h2 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-n, --quiet, --silent</code>: 禁止自动打印图案空间。</li><li><code>-e script, --expression=script</code>: 将脚本添加到要执行的命令中。</li><li><code>-f script-file, --file=script-file</code>: 将脚本文件的内容添加到要执行的命令中。</li><li><code>--follow-symlinks</code>: 就地处理时遵循符号链接。</li><li><code>-i[SUFFIX], --in-place[=SUFFIX]</code>:就地编辑文件，如果提供了后缀，则使用文件扩展名后缀进行备份。</li><li><code>-l N, --line-length=N</code>: 为<code>l</code>命令指定所需的换行长度<code>N</code>。</li><li><code>--POSIX</code>: 禁用所有<code>GNU</code>扩展。</li><li><code>-r, --regexp-extended</code>: 在脚本中使用扩展的正则表达式。</li><li><code>-s, --separate</code>: 将文件视为单独的文件，而不是单个连续的长文件流。</li><li><code>-u, --unbuffered</code>: 从输入文件中加载少量数据，并更频繁地刷新输出缓冲区。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h2><p><code>file.txt</code>文件内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unix is great os. unix is opensource. unix is free os.</span><br><span class="line">learn operating system.</span><br><span class="line">unix linux which one you choose.</span><br><span class="line">unix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span><br></pre></td></tr></table></figure><p>将文件中的每行的第一个单词<code>unix</code>替换为<code>linux</code>，要保存的话需要使用输出重定向。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/unix/linux/&quot; file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux is great os. unix is opensource. unix is free os.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">learn operating system.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux linux <span class="built_in">which</span> one you choose.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>替换行中模式的第<code>2</code>个匹配项，将行中出现的第二个单词<code>unix</code>替换为<code>linux</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/unix/linux/2&quot; file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix is great os. linux is opensource. unix is free os.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">learn operating system.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix linux <span class="built_in">which</span> one you choose.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix is easy to learn.linux is a multiuser os.Learn unix .unix is a powerful.</span></span><br></pre></td></tr></table></figure><p>使用替换标志<code>/g</code>全局替换指定<code>sed</code>命令来替换行中所有出现的字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/unix/linux/g&quot; file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux is great os. linux is opensource. linux is free os.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">learn operating system.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux linux <span class="built_in">which</span> one you choose.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux is easy to learn.linux is a multiuser os.Learn linux .linux is a powerful.</span></span><br></pre></td></tr></table></figure><p>指定第<code>2</code>个之后的全部匹配模式的字符进行替换。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s/unix/linux/2g&quot; file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix is great os. linux is opensource. linux is free os.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">learn operating system.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix linux <span class="built_in">which</span> one you choose.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unix is easy to learn.linux is a multiuser os.Learn linux .linux is a powerful</span></span><br></pre></td></tr></table></figure><p>用括号括住每个单词的第一个字符，在括号中打印每个单词的第一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Welcome To The World&quot; | sed &quot;s/\(\b[A-Z]\)/\(\1\)/g&quot;</span><br><span class="line"></span><br><span class="line"># (W)elcome (T)o (T)he (W)orld</span><br></pre></td></tr></table></figure><p>可以限制<code>sed</code>命令替换特定行号上的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;3 s/unix/linux/g&quot; file.txt</span><br><span class="line"></span><br><span class="line"># unix is great os. unix is opensource. unix is free os.</span><br><span class="line"># learn operating system.</span><br><span class="line"># linux linux which one you choose.</span><br><span class="line"># unix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.</span><br></pre></td></tr></table></figure><h1 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h1><p><code>scp</code>命令用于<code>Linux</code>之间复制文件和目录，<code>scp</code>是<code>secure copy</code>的缩写，是<code>Linux</code>系统下基于<code>ssh</code>登陆进行安全的远程文件拷贝命令，使用<code>scp</code>可以实现从本地系统到远程系统、从远程系统到本地系统、在本地系统的两个远程系统之间的复制传输。<code>scp</code>是加密的，<code>rcp</code>是不加密的，可以认为<code>scp</code>是<code>rcp</code>的加强版。</p><h2 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [OPTION] [user@]SRC_HOST:]file1 [user@]DEST_HOST:]file2</span><br></pre></td></tr></table></figure><h2 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-1</code>: 强制<code>scp</code>使用协议<code>1</code>，这是一个较旧的协议。</li><li><code>-2</code>: 强制<code>scp</code>使用协议<code>2</code>，这是一个较旧的协议。</li><li><code>-3</code>: 两个远程主机之间的副本通过本地主机传输，如果没有此选项，数据将直接在两个远程主机之间复制，此选项还禁用进度表。</li><li><code>-4</code>: 强制<code>scp</code>仅使用<code>IPv4</code>地址。</li><li><code>-6</code>: 强制<code>scp</code>仅使用<code>IPv6</code>地址。</li><li><code>-B</code>: 使用批处理模式，无需任何交互式键盘输入即可运行，这意味着<code>scp</code>无法通过要求用户输入密码来验证会话，此时需要使用密钥进行身份验证。</li><li><code>-C</code>: 启用压缩，该压缩将<code>-C</code>标志传递给<code>ssh</code>以启用加密连接的压缩。</li><li><code>-c cipher</code>: 选择用于加密数据传输的密码，此选项直接传递给<code>ssh</code>。</li><li><code>-F ssh_config</code>: 为<code>ssh</code>指定每个用户的备用配置文件，此选项直接传递给<code>ssh</code>。</li><li><code>-i identity_file</code>: 选择读取<code>RSA</code>身份验证的身份(私钥)的文件，这个选项直接传递给<code>ssh</code>。</li><li><code>-l limit</code>: 限制使用的带宽，以<code>Kbit/s</code>为单位。</li><li><code>-o ssh_option</code>: 可用于以<code>ssh_config</code>中使用的格式将选项传递给<code>ssh</code>，例如<code>AddressFamily</code>、<code>BatchMode</code>、<code>BindAddress</code>等等，这对于指定没有单独的<code>scp</code>命令标志的选项非常有用。</li><li><code>-P port</code>:指定远程主机上要连接到的端口，注意这个选项是用大写字母<code>P</code>写的，因为<code>-p</code>已经被保留了，用于保存<code>rcp</code>中文件的时间和模式。</li><li><code>-p</code>: 保留原始文件的修改时间、访问时间和模式。</li><li><code>-q</code>: 禁用进度表。</li><li><code>-r</code>: 递归地复制整个目录。</li><li><code>-S program</code>: 用于加密连接的程序名称，程序必须能够解析<code>ssh</code>选项。</li><li><code>-v</code>: 详细模式，使<code>scp</code>和<code>ssh</code>打印有关其进度的调试消息，这有助于调试连接，身份验证和配置问题。</li></ul><h2 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h2><p>将<code>file.txt</code>传输到远程主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt root@1.1.1.1:/tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file.txt                      100%    0     0.0KB/s   00:00</span></span><br></pre></td></tr></table></figure><p>使用私钥将<code>file.txt</code>传输到远程主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -i ./v file.txt root@1.1.1.1:/tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file.txt                      100%    0     0.0KB/s   00:00</span></span><br></pre></td></tr></table></figure><p>将远程目录中<code>file.txt</code>文件传输到本地，使用私钥验证身份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -i ./v root@1.1.1.1:/tmp/file.txt ./</span><br><span class="line"># file.txt                      100%    0     0.0KB/s   00:00</span><br></pre></td></tr></table></figure><h1 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h1><p>在计算机网络中，路由器是负责转发网络流量的设备，当数据报到达路由器时，路由器必须确定将其路由到目的地的最佳方法，<code>route</code>命令用于查看和更改内核路由表，在不同的系统上，命令语法不同，所以实际时可以查看命令的帮助来确定具体使用方法。</p><h2 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route [-CFvnee]</span><br><span class="line">route [-v] [-A family] add [-net|-host] target [netmask Nm] [gw Gw] </span><br><span class="line">      [metric N] i [mss M] [window W] [irtt m] [reject] [mod] [dyn] </span><br><span class="line">      [reinstate] [[dev] If]</span><br><span class="line">route [-v] [-A family] del [-net|-host] target [gw Gw] [netmask Nm] </span><br><span class="line">      [metric N] [[dev] If]</span><br><span class="line">route [-V] [--version] [-h] [--help]</span><br></pre></td></tr></table></figure><h2 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h2><ul><li><code>(none)</code>: 查看当前所有路由定义。</li><li><code>-A family</code>: 使用指定的地址族，可以使用<code>route --help</code>查询支持的地址族，通常支持的地址族有<code>inet (DARPA Internet)</code>、<code>inet6 (IPv6)</code>、<code>ax25 (AMPR AX.25)</code>、<code>netrom (AMPR NET/ROM)</code>、<code>ipx (Novell IPX)</code>、<code>ddp (Appletalk DDP)</code>、<code>x25 (CCITT X.25)</code>。</li><li><code>-F</code>: 对内核的<code>FIB</code>转发信息库路由表进行操作，这是默认值。</li><li><code>-C</code>: 操作内核的路由缓存。</li><li><code>-v</code>: 输出详细操作。</li><li><code>-n</code>: 显示数字地址，而不是尝试确定符号主机名，如果要确定到名称服务器的路由消失的原因，这将很有用。</li><li><code>-e</code>: 使用<code>netstat</code>格式显示路由表，<code>-ee</code>将使用路由表中的所有参数生成很长的一行。</li><li><code>del</code>: 删除路由。</li><li><code>add</code>: 添加路由。</li><li><code>target</code>: 目标网络或主机，可以用点分十进制或主机<code>/</code>网络名称提供<code>IP</code>地址。</li><li><code>-net</code>: 添加的目标是一个网络。</li><li><code>-host</code>: 添加的目标是一个主机。</li><li><code>netmask NM</code>: 添加网络路由时，要使用的网络掩码。</li><li><code>gw GW</code>: 通过网关路由数据包，必须首先可以访问指定的网关，这通常意味着必须事先设置到网关的静态路由，如果您指定本地接口之一的地址，它将用于确定数据包应路由到的接口。</li><li><code>metric M</code>: 将路由表(由路由守护程序使用)中的度量字段设置为M。</li><li><code>mss M</code>: 将通过此路由的连接的<code>TCP</code>最大段大小<code>MSS</code>设置为<code>M</code>个字节，缺省值为设备<code>MTU</code>减去标题，或在发生路径<code>mtu</code>发现时使用较低的<code>MTU</code>，当路径<code>mtu</code>发现不起作用时(通常是由于配置错误的防火墙阻止了所需的<code>ICMP</code>碎片)，此设置可用于在另一端强制使用较小的<code>TCP</code>数据包。</li><li><code>window W</code>: 将通过此路由的连接的<code>TCP</code>窗口大小设置为<code>W</code>字节，仅在<code>AX.25</code>网络上使用，并且驱动程序无法处理背靠背帧。</li><li><code>irtt m</code>: 将通过此路由的<code>TCP</code>连接的初始往返时间<code>irtt</code>设置为<code>m</code>毫秒<code>1-12000</code>，仅在<code>AX.25</code>网络上使用，如果省略，则使用<code>RFC 1122</code>默认值<code>300ms</code>。</li><li><code>reject</code>: 安装阻塞路由，这将强制路由查找失败，这可以用于在使用默认路由之前屏蔽网络，此外要注意这不是用于防火墙。</li><li><code>mod, dyn, reinstate</code>: 安装动态或修改后的路线，这些标志用于诊断目的，通常仅由路由守护程序设置。</li><li><code>dev If</code>: 强制将路由与指定设备相关联，否则内核将尝试自行确定设备(通过检查现有路由和设备规格以及添加路由的位置)，在大多数普通网络中，基本不需要此功能。如果<code>dev If</code>是命令行上的最后一个选项，则可以省略单词<code>dev</code>，因为它是默认值，否则路由修饰符的顺序<code>metric - netmask - gw - dev</code>无关紧要。</li><li><code>-h, --help</code>: 输出帮助信息。</li></ul><h2 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h2><p>显示绑定到服务器的所有<code>IP</code>的路由表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>添加默认网关，这将分配一个网关地址，所有不属于此网络的数据包都将在该网关地址上转发。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 169.213.0.0</span><br></pre></td></tr></table></figure><p>列出内核的路由缓存信息，为了更快地路由数据包，内核保留了路由缓存信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -Cn</span><br></pre></td></tr></table></figure><p>拒绝路由到特定主机或网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -host 192.168.1.51 reject</span><br></pre></td></tr></table></figure><p>删除默认网关，这可能会导致某些互联网故障，所以在继续执行该命令之前，请记下默认网关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route del default</span><br></pre></td></tr></table></figure><p>当我们连接<code>PPTP</code>后，通常我们会配置将一个网段添加路由，来指定数据报通过<code>ppp0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 192.168.0.0/16 dev ppp0</span><br></pre></td></tr></table></figure><p>配置将一个域名添加路由，来指定数据报通过<code>ppp0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -host jwgl.sdust.edu.cn dev ppp0</span><br></pre></td></tr></table></figure><p>将所有<code>D</code>类多播<code>IP</code>路由都设置为通过<code>eth0</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br></pre></td></tr></table></figure><h1 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h1><p> <code>rm</code>命令用于删除一个文件或者目录。 </p><h2 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-f, --force</code>: 即使文件属性设为只读也直接删除，不逐一确认，此外忽略不存在的文件，不产生提示。</li><li><code>-i</code>: 删除之前逐一询问确认。</li><li><code>-I</code>: 在删除三个以上文件之前或在递归删除时提示一次，比<code>-i</code>提示的次数少，但仍然可以防止大多数错误。</li><li><code>--interactive[=WHEN]</code>: 根据<code>WHEN</code>提示，从不，一次<code>-I</code>或始终<code>-i</code>，如果没有<code>WHEN</code>，则始终提示。</li><li><code>--one-file-system</code>: 递归删除层次结构时，跳过文件系统上与相应命令行参数不同的任何目录。</li><li><code>--no-preserve-root</code>: 不特别对待<code>/</code>。</li><li><code>--preserve-root</code>: 不要删除<code>/</code>，默认选项。</li><li><code>-r, -R, --recursive</code>: 递归删除目录及其内容。</li><li><code>-d, --dir</code>: 删除空目录。</li><li><code>-v, --verbose</code>: 输出执行过程。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h2><p>删除文件<code>file.txt</code>，如果文件是写保护的，则将提示是否确认要删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm file.txt</span><br></pre></td></tr></table></figure><p>删除文件<code>file.txt</code>，即使文件是写保护的也不会有确认提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f file.txt</span><br></pre></td></tr></table></figure><p>删除当前目录中的所有文件，如果文件是写保护的，则在<code>rm</code>删除之前将提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm *</span><br></pre></td></tr></table></figure><p>删除当前目录中的所有文件，<code>rm</code>将不会有任何提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f *</span><br></pre></td></tr></table></figure><p>尝试删除当前目录中的每个文件，但在删除每个文件之前提示确认。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -i *</span><br></pre></td></tr></table></figure><p>删除当前目录中的每个文件，提示确认是否删除三个以上的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -I *</span></span><br></pre></td></tr></table></figure><p>删除目录<code>directory</code>及其包含的所有文件和目录，果<code>rm</code>尝试删除的文件或目录具有写保护，则将提示是否确实要删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r directory</span><br></pre></td></tr></table></figure><p>删除目录<code>directory</code>及其包含的所有文件和目录，不会有任何确认提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf mydirectory</span><br></pre></td></tr></table></figure><h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><p><code>read</code>命令被用来从标准输入读取单行数据，这个命令可以用来读取键盘输入，当使用重定向以及默认选项的情况下，可以读取文件中的一行数据，此时<code>read</code>会将换行符视为行尾，但是可以使用<code>-d</code>选项更改。</p><h2 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...] [name2 ...]</span><br></pre></td></tr></table></figure><h2 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a array</code>: 将单词存储在一个名为<code>array</code>的索引数组中，数组元素的编号从<code>0</code>开始。</li><li><code>-d delim</code>: 将定界符设置为<code>delim</code>，该字符表示行尾，如果未使用<code>-d</code>，则默认行定界符为换行符。</li><li><code>-e</code>: 从<code>shell</code>获取一行输入，用户手动输入字符，直到达到行分隔符为止。</li><li><code>-i text</code>: 当与<code>-e</code>结合使用并且仅在不使用<code>-s</code>的情况下，文本将作为输入行的初始文本插入，允许用户在输入行上编辑文本。</li><li><code>-n nchars</code>: 如果尚未达到行定界符，则在读取整数<code>nchars</code>个字符后停止读取。</li><li><code>-N nchars</code>: 忽略行定界符，仅在已读取<code>nchars</code>个字符，达到<code>EOF</code>或读取超时之后才停止读取。</li><li><code>-p prompt</code>: 在开始读取之前，不使用换行符打印字符串提示符。</li><li><code>-r</code>: 使用原始输入，具体来说，这个选项使<code>read</code>按字面意思解释反斜杠，而不是将它们解释为转义字符。</li><li><code>-s</code>: 当<code>read</code>从终端获取输入时，不显示按键。</li><li><code>-t timeout</code>: 如果在超时秒内未读取完整的输入行，则超时并返回失败，如果超时值为零，那么<code>read</code>将不会读取任何数据，但是如果输入可用于读取，则返回成功。如果未指定超时，则使用<code>shell</code>变量<code>TMOUT</code>的值(如果存在)，超时值可以是小数，例如<code>3.5</code>。</li><li><code>-u fd</code>: 从文件描述符<code>fd</code>中读取而不是从标准输入中读取，文件描述符应该是一个<code>small integer</code>。</li></ul><h2 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h2><p>读取终端的输入，循环读入一直持续到按<code>Ctrl + D</code>即<code>EOF</code>为止，由于指定变量名<code>text</code>，因此整行文本都存储在变量<code>text</code>中，每当输入一行后按回车时，将会把输入的内容输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while read text</span><br><span class="line">    do echo &quot;$text&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>读取终端的输入，指定一个输入的超时时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if read -t 3 -p &quot;Text: &quot; text</span><br><span class="line">then</span><br><span class="line">    echo &quot;Text: $text&quot;</span><br><span class="line">else</span><br><span class="line">    echo -e &quot;\nTimeout&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>按行读取文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt | while read line</span><br><span class="line">do</span><br><span class="line">   echo &quot;$line&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="rcp命令"><a href="#rcp命令" class="headerlink" title="rcp命令"></a>rcp命令</h1><p><code>rcp</code>命令用于复制远程文件或目录，如同时指定两个以上的文件或目录，且最后的目标位置是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中，执行<code>rcp</code>命令以后不会有返回信息，仅需要在目标目录下查看文件或目录是否复制成功即可，<code>rcp</code>不提示输入密码，其通过<code>rsh</code>执行远程执行 ，并且需要相同的授权。</p><h2 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp [options] [origin] [target]</span><br></pre></td></tr></table></figure><h2 id="参数-19"><a href="#参数-19" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-r</code>: 递归地把源目录中的所有内容拷贝到目标目录中，要使用这个选项，目标位置必须是一个目录。</li><li><code>-p</code>: 保留源文件的修改时间和模式，包括拥有者、所属群组、权限与时间，忽略<code>umask</code>。</li><li><code>-k</code>: 请求<code>rcp</code>获得在指定区域内的远程主机的<code>Kerberos</code>许可，而不是获得由<code>krb_relmofhost</code>确定的远程主机区域内的远程主机的<code>Kerberos</code>许可。</li><li><code>-x</code>: 为传送的所有数据打开<code>DES</code>加密，这会影响响应时间和<code>CPU</code>使用率，但是可以提高安全性。</li><li><code>-D</code>: 指定远程服务器的端口号。</li></ul><h2 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h2><p>远程复制<code>file.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp root@1.1.1.1:/file.txt file.txt</span><br></pre></td></tr></table></figure><h1 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h1><p><code>Linux</code>是一个多任务、多用户的操作系统，因此它允许多个进程同时运行而不相互干扰，进程是<code>Linux</code>操作系统的重要基本概念之一，进程是程序的执行实例，在操作系统中执行不同的任务。<code>Linux</code>为我们提供了一个名为<code>ps</code>的实用程序，用于查看与系统上的进程相关的信息，它是<code>process status</code>进程状态的缩写，<code>ps</code>命令用于列出当前正在运行的进程，它们的<code>pid</code>以及一些其他信息取决于不同的选项，它从<code>/proc</code>文件系统中的虚拟文件读取进程信息，<code>/proc</code>包含虚拟文件，这就是它被称为虚拟文件系统的原因，<code>process status</code>命令<code>ps</code>显示有关活动进程的信息，类似于<code>windows</code>的任务管理器，每个操作系统的<code>ps</code>版本都略有不同，因此若要是需要获取详细情况则需要查阅操作系统的<code>wiki</code>。</p><h2 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [options]</span><br></pre></td></tr></table></figure><h2 id="参数-20"><a href="#参数-20" class="headerlink" title="参数"></a>参数</h2><p><code>ps</code>命令有多种类别的参数可以选择: <code>simple|list|output|threads|misc|all</code>。</p><h3 id="Simple-Process-Selection"><a href="#Simple-Process-Selection" class="headerlink" title="Simple Process Selection"></a>Simple Process Selection</h3><ul><li><code>-A, -e</code>: 选择所有进程。</li><li><code>-a</code>: 选择除会话引线和与终端无关的进程之外的所有进程。</li><li><code>a</code>: 列出带有终端<code>tty</code>的所有进程，包括其他用户进程，或者在与<code>x</code>选项一起使用时列出所有进程。</li><li><code>-d</code>: 选择除会话所属者以外的所有进程。</li><li><code>-N, --deselect</code>: 选择除满足指定条件的进程以外的所有进程。</li><li><code>r</code>: 将选择限制为仅运行进程。</li><li><code>T</code>: 选择与此终端关联的所有进程。</li><li><code>x</code>: 列出拥有的所有进程(和<code>ps</code>相同的<code>EUID</code>)，或者在和<code>a</code>选项一起使用时列出所有进程。</li></ul><h3 id="Process-Selection-By-List"><a href="#Process-Selection-By-List" class="headerlink" title="Process Selection By List"></a>Process Selection By List</h3><ul><li><code>-C &lt;command&gt;</code>: 按命令名选择，这将选择其可执行名称在<code>command</code>中给定的进程。</li><li><code>-G, --Group &lt;GID&gt;</code>: 按真实组<code>ID (RGID)</code>或名称选择，这将选择其真实组名或<code>ID</code>在<code>grplist</code>列表中的进程。</li><li><code>-g, --group &lt;group&gt;</code>: 按会话或有效组名选择。</li><li><code>-p, p, --pid &lt;PID&gt;</code>: 按进程<code>ID</code>选择。</li><li><code>--ppid &lt;PID&gt;</code>: 按父进程<code>ID</code>选择，这将选择<code>pidlist</code>中具有父进程<code>ID</code>的进程，也就是说，它选择的进程是<code>pidlist</code>中列出的那些进程的子进程。</li><li><code>-q, q, --quick-pid &lt;PID&gt;</code>: 按进程<code>ID</code>选择(快速模式)。</li><li><code>-s, --sid &lt;session&gt;</code>: 按会话<code>ID</code>选择。</li><li><code>-t, t, --tty &lt;tty&gt;</code>: 通过<code>tty (terminal)</code>选择。</li><li><code>-u, U, --user &lt;UID&gt;</code>: 根据有效的用户<code>ID (EUID)</code>或名称选择。</li><li><code>-U, --User &lt;UID&gt;</code>: 按真实用户<code>ID (RUID)</code>或名称选择。</li></ul><h3 id="Output-Format-Control"><a href="#Output-Format-Control" class="headerlink" title="Output Format Control"></a>Output Format Control</h3><ul><li><code>-F</code>: 额外的完整格式。</li><li><code>-f</code>: 进行全格式列表，可以将此选项与其他<code>UNIX</code>样式的选项结合使用以添加其他列，它还会导致命令参数被打印，与<code>-L</code>一起使用时，将添加<code>NLWP</code>线程数和<code>LWP</code>线程<code>ID</code>列。</li><li><code>f, --forest</code>:<code>ASCII art</code>进程层次结构，如许多树，也称为林。</li><li><code>-H</code>: 显示进程层次结构(林)。</li><li><code>-j</code>: 作业格式。</li><li><code>j</code>: <code>BSD</code>作业控制格式。</li><li><code>-l</code>: 长格式，<code>-y</code>选项通常对此很有用。</li><li><code>l</code>: 显示<code>BSD</code>长格式。</li><li><code>-M, Z</code>: 对于<code>SE Linux</code>添加一列安全数据。</li><li><code>-O &lt;format&gt;</code>: 使用默认列预加载。</li><li><code>O &lt;format&gt;</code>: 与<code>-O</code>类似，具有<code>BSD</code>特性。</li><li><code>-o, o, --format &lt;format&gt;</code>: 指定用户定义的格式。</li><li><code>s</code>: 显示信号格式。</li><li><code>u</code>: 显示面向用户的格式。</li><li><code>v</code>: 显示虚拟内存格式。</li><li><code>X</code>: 寄存器格式。</li><li><code>-y</code>: 不显示标志，显示<code>rss</code>代替<code>addr</code>，此选项只能与<code>-l</code>一起使用。</li><li><code>--context</code>: 使用<code>SE Linux</code>时，显示安全上下文格式。</li><li><code>--headers</code>: 重复标题行，每页输出一行。</li><li><code>--no-headers</code>: 完全不打印标题行。</li><li><code>--cols, --columns, --width &lt;num&gt;</code>: 设置屏幕宽度。</li><li><code>--rows, --lines &lt;num&gt;</code>: 设置屏幕高度。</li></ul><h3 id="Thread-Display"><a href="#Thread-Display" class="headerlink" title="Thread Display"></a>Thread Display</h3><ul><li><code>H</code>: 将线程显示为进程。</li><li><code>-L</code>: 显示线程，可能带有<code>LWP</code>和<code>NLWP</code>列。</li><li><code>-m, m</code>: 在进程之后显示线程。</li><li><code>-T</code>: 显示线程，可能带有<code>SPID</code>列。</li></ul><h3 id="Miscellaneous-options"><a href="#Miscellaneous-options" class="headerlink" title="Miscellaneous options"></a>Miscellaneous options</h3><ul><li><code>-c</code>: 为<code>-l</code>选项显示不同的调度程序信息。</li><li><code>c</code>: 显示真实的命令名称。</li><li><code>e</code>: 在命令后显示环境。</li><li><code>k, --sort</code>: 指定排序顺序为<code>[+|-]key[,[+|-]key[,...]]</code>。</li><li><code>L</code>: 显示格式说明符。</li><li><code>n</code>: 显示数字<code>uid</code>和<code>wchan</code>。</li><li><code>S, --cumulative</code>: 包含一些<code>dead</code>子进程数据。</li><li><code>-y</code>: 不显示标志，显示<code>rss</code>，仅与<code>-l</code>一起使用。</li><li><code>-V, V, --version</code>: 显示版本信息。</li><li><code>-w, w</code>: 无限制的输出宽度。</li><li><code>--help &lt;simple|list|output|threads|misc|all&gt;</code>: 显示帮助信息。</li></ul><h2 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h2><p>显示当前<code>shell</code>的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure><p>查看所有正在运行的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e</span><br></pre></td></tr></table></figure><p>通常查看所有进程可以与管道以及<code>grep</code>命令结合用以过滤，例如我们查看与<code>nginx</code>有关的所有进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep nginx</span><br></pre></td></tr></table></figure><p>查看除会话引线和未与终端关联的进程之外的所有进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -a</span><br></pre></td></tr></table></figure><p>查看<code>www</code>用户的所有进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u www</span><br></pre></td></tr></table></figure><p>查看<code>www</code>组的所有进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -G www</span><br></pre></td></tr></table></figure><p>使用<code>-f</code>查看完整格式列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -f</span><br></pre></td></tr></table></figure><p>按用户自定义格式查看进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aN --format cmd,pid,user,ppid</span><br></pre></td></tr></table></figure><p>根据内存占用情况将进程排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem</span><br></pre></td></tr></table></figure><p>显示所有当前进程，为了便于查看可以结合管道和<code>less</code>命令来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ax | less</span><br></pre></td></tr></table></figure><p>使用<code>aux</code>参数，加入<code>CPU</code>与内存用量信息，来显示全面的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | less</span><br></pre></td></tr></table></figure><p>根据<code>CPU</code>使用将进程降序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --sort -pcpu | less</span><br></pre></td></tr></table></figure><p>根据内存使用将进程降序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --sort -pmem | less</span><br></pre></td></tr></table></figure><p>合并内存与<code>CPU</code>的整体使用情况进行排序，并只显示前<code>10</code>个结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --sort -pcpu,+pmem | head -n 10</span><br></pre></td></tr></table></figure><h1 id="pico命令"><a href="#pico命令" class="headerlink" title="pico命令"></a>pico命令</h1><p><code>pico</code>是一个简单易用、以显示导向为主的文字编辑程序，具有<code>pine</code>电子邮件编写器的风格。在现代<code>Linux</code>系统上，<code>nano</code>即<code>pico</code>的<code>GNU</code>版本是默认安装的，在使用上和<code>pico</code>一模一样。</p><h2 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano [OPTIONS] [[+LINE[,COLUMN]] FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-21"><a href="#参数-21" class="headerlink" title="参数"></a>参数</h2><ul><li><code>+LINE[,COLUMN]</code>: 启动时将光标放置在行号行和列号列，而不是默认的第<code>1</code>行第<code>1</code>列。</li><li><code>-?</code>: 与<code>-h</code>相同。</li><li><code>-A, --smarthome</code>: 使<code>Home</code>键更智能，如果在一行中非空格字符的开头但在任何地方按<code>Home</code>键，则光标将跳到该开头(向前或向后)，如果光标已经在该位置，它将跳到该行的真实开头。</li><li><code>-B, --backup</code>: 保存文件时，将以前版本的文件备份到以<code>~</code>为后缀的当前文件名。</li><li><code>-C dir, --backupdir=dir</code>: 如果启用了文件备份，请设置<code>nano</code>放置唯一备份文件的目录。</li><li><code>-D, --boldtext</code>: 使用粗体文本而不是反向视频文本。</li><li><code>-E, --tabstospaces</code>: 将键入的制表符转换为空格。</li><li><code>-F, --multibuffer</code>: 如果可用，启用多个文件缓冲区。</li><li><code>-H, --historylog</code>: 记录搜索并将字符串替换为<code>~/.nano_history</code>，如果有<code>nanorc</code>支持，则可以在以后的会话中检索它们。</li><li><code>-I, --ignorercfiles</code>: 如果有<code>nanorc</code>支持，不要检索<code>SYSCONFDIR/nanorc</code>或<code>~/.nanorc</code>。</li><li><code>-K, --rebindkeypad</code>: 解释数字小键盘的键，以便它们都可以正常工作。如果不需要，则不需要使用此选项，因为启用此选项后，鼠标支持将无法正常工作。</li><li><code>-L, --nonewlines</code>: 不要在文件末尾添加换行符。</li><li><code>-N, --noconvert</code>: 禁止从<code>DOS/Mac</code>格式自动转换文件。</li><li><code>-O, --morespace</code>: 使用标题栏下方的空白行作为额外的编辑空间。</li><li><code>-Q str, --quotestr=str</code>: 设置引号字符串以进行证明。如果有扩展的正则表达式支持，则默认值为<code>^([ \t]*[#:&gt;\|&#125;])+</code>，否则为<code>&gt;</code>。请注意<code>\t</code>代表<code>Tab</code>。</li><li><code>-R, --restricted</code>: 限制模式，不读取或写入命令行中未指定的任何文件，读取任何<code>nanorc</code>文件，允许挂起，允许将文件附加到其他名称(如果已经有文件名)或以其他名称保存，或者使用备份文件或拼写检查。也可以通过使用以<code>r</code>开头的任何名称调用<code>nano</code>(例如<code>rnano</code>)进行访问。</li><li><code>-S, --smooth</code>: 启用平滑滚动，文本将逐行滚动，而不是通常的逐块行为。</li><li><code>-T cols, --tabsize=cols</code>: 将选项卡的大小(宽度)设置为列，<code>cols</code>的值必须大于<code>0</code>，默认值为<code>8</code>。</li><li><code>-U, --quickblank</code>: 快速清除状态栏，<code>1</code>次按键而不是<code>25</code>次按键后，状态栏消息将消失，请注意<code>-c</code>会覆盖此内容。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-W, --wordbounds</code>: 通过将标点符号视为单词的一部分，可以更准确地检测单词边界。</li><li><code>-Y str, --syntax=str</code>: 从<code>nanorc</code>中指定要使用的特定语法高亮显示(如果可用)。</li><li><code>-c, --const</code>: 不断显示光标位置，请注意这将覆盖<code>-U</code>。</li><li><code>-d, --rebinddelete</code>: 以不同的方式解释<code>Delete</code>键，以便退格键和<code>Delete</code>键都能正常工作，只有当退格符在系统上的作用类似于<code>Delete</code>时，您才需要使用此选项。</li><li><code>-h, --help</code>: 输出帮助信息。</li><li><code>-i, --autoindent</code>: 将新行缩进到前一行的缩进中，在编辑源代码时很有用。</li><li><code>-k, --cut</code>: 启用从光标到行尾的剪切。</li><li><code>-l --nofollow</code>: 如果正在编辑的文件是符号链接，请用新文件替换该链接，而不是跟随它,，也许适合在<code>/tmp</code>中编辑文件。</li><li><code>-m, --mouse</code>: 启用鼠标支持(如果适用于您的系统)。设置快捷方式时，可以用鼠标双击鼠标来执行标记，鼠标将在<code>X</code>窗口系统中工作，并在<code>gpm</code>运行时在控制台上工作。</li><li><code>-o dir, --operatingdir=dir</code>: 设置操作目录，使<code>nano</code>设置类似于<code>chroot</code>。</li><li><code>-p, --preserve</code>: 保留<code>XON</code>和<code>XOFF</code>序列<code>^Q</code>和<code>^S</code>，以便它们被终端捕获。</li><li><code>-r cols, --fill=cols</code>: 在列<code>cols</code>处换行，如果此值等于或小于<code>0</code>，则将在屏幕的宽度减去<code>cols</code>列的宽度处进行换行，如果调整了屏幕大小，则换行点将随着屏幕的宽度而变化，默认值为<code>-8</code>。</li><li><code>-s prog, --speller=prog</code>: 启用备用拼写检查程序命令。</li><li><code>-t, --tempfile</code>: 始终保存更改的缓冲区而无提示，与<code>Pico</code>的<code>-t</code>选项相同。</li><li><code>-v, --view</code>: 查看文件(只读)模式。</li><li><code>-w, --nowrap</code>: 禁用长行换行。</li><li><code>-x, --nohelp</code>: 禁用编辑器底部的帮助屏幕。</li><li><code>-z, --suspend</code>: 启用暂停功能。</li><li><code>-a, -b, -e, -f, -g, -j</code>: 由于与<code>Pico</code>的兼容性而被忽略。</li></ul><h2 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h2><p>使用<code>nano</code>编辑文件，根据操作提示编辑文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nano file.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^G Get Help</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^O WriteOut</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^R Read File</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^Y Prev Page</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^K Cut Text</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^C Cur Pos</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^X Exit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^J Justify</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^W Where Is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^V Next Page</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^U UnCut Text</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">^T To Spell</span></span><br></pre></td></tr></table></figure><h1 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h1><p><code>patch</code>指令让用户利用设置修补文件的方式、修改、更新原始文件，倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行，如果配合修补文件的方式则能一次修补大批文件，这也是<code>Linux</code>系统核心的升级方法之一。</p><h2 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch [OPTION]... [ORIGFILE [PATCHFILE]]</span><br></pre></td></tr></table></figure><h2 id="参数-22"><a href="#参数-22" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --backup</code>: 备份每一个原始文件。</li><li><code>-B&lt;pref&gt;, --prefix=&lt;pref&gt;</code>: 设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。</li><li><code>-c, --context</code>: 把修补数据解译成关联性的差异。</li><li><code>-d&lt;dir&gt;, --directory=&lt;dir&gt;</code>: 设置工作目录。</li><li><code>-D&lt;define&gt;, --ifdef=&lt;define&gt;</code>: 用指定的符号把改变的地方标示出来。</li><li><code>-e, --ed</code>: 把修补数据解译成ed指令可用的叙述文件。</li><li><code>-E, --remove-empty-files</code>: 若修补过后输出的文件其内容是一片空白，则移除该文件。</li><li><code>-f, --force</code>: 此参数的效果和指定<code>-t</code>参数类似，但会假设修补数据的版本为新版本。</li><li><code>-F&lt;num &gt;, --fuzz&lt;num &gt;</code>: 设置监别列数的最大值。</li><li><code>-g&lt;num&gt;, --get=&lt;num&gt;</code>: 设置以<code>RSC</code>或<code>SCCS</code>控制修补作业。</li><li><code>-i&lt;patchfile&gt;, --input=&lt;patchfile&gt;</code>: 读取指定的修补文件。</li><li><code>-l, --ignore-whitespace</code>: 忽略修补数据与输入数据的跳格，空格字符。</li><li><code>-n, --normal</code>: 把修补数据解译成一般性的差异。</li><li><code>-N, --forward</code>: 忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。</li><li><code>-o&lt;outfile&gt;, --output=&lt;outfile&gt;</code>: 设置输出文件的名称，修补过的文件会以该名称存放。</li><li><code>-p&lt;num&gt;, --strip=&lt;num&gt;</code>: 设置欲剥离几层路径名称。</li><li><code>-f&lt;rejectfile&gt;, --reject-file=&lt;rejectfile&gt;</code>: 设置保存拒绝修补相关信息的文件名称，预设的文件名称为<code>.rej</code>。</li><li><code>-R, --reverse</code>: 假设修补数据是由新旧文件交换位置而产生。</li><li><code>-s, --quiet或--silent</code>: 不显示指令执行过程，除非发生错误。</li><li><code>-t, --batch</code>: 自动略过错误，不询问任何问题。</li><li><code>-T, --set-time</code>: 此参数的效果和指定<code>-Z</code>参数类似，但以本地时间为主。</li><li><code>-u, --unified</code>: 把修补数据解译成一致化的差异。</li><li><code>-v, --version</code>: 显示版本信息。</li><li><code>-V&lt;method&gt;, --version-control=&lt;method&gt;</code>: 用<code>-b</code>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用<code>-z</code>参数变更，当使用<code>-V</code>参数指定不同备份方式时，也会产生不同字尾的备份字符串。</li><li><code>-Y&lt;pref&gt;, --basename-prefix=--&lt;pref&gt;</code>: 设置文件备份时，附加在文件基本名称开头的字首字符串。</li><li><code>-z&lt;suffix&gt;, --suffix=&lt;suffix&gt;</code>: 此参数的效果和指定<code>-B</code>参数类似，差别在于修补作业使用的路径与文件名若为<code>src/linux/fs/super.c</code>，加上<code>backup/</code>字符串后，文件<code>super.c</code>会备份于<code>/src/linux/fs/backup</code>目录里。</li><li><code>-Z, --set-utc</code>: 把修补过的文件更改，存取时间设为<code>UTC</code>。</li><li><code>--backup-if-mismatch</code>: 在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。</li><li><code>--binary</code>: 以二进制模式读写数据，而不通过标准输出设备。</li><li><code>--help</code>: 在线帮助。</li><li><code>--nobackup-if-mismatch</code>: 在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。</li><li><code>--verbose</code>: 详细显示指令的执行过程。</li></ul><h2 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h2><p>使用补丁包<code>/tmp/file.patch</code>为文件<code>/tmp/file2.txt</code>升级。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">diff /tmp/file2.txt /tmp/file3.txt &gt; /tmp/file.patch <span class="comment"># 生成补丁文件</span></span></span><br><span class="line">patch /tmp/file2.txt /tmp/file.patch</span><br></pre></td></tr></table></figure><h1 id="paste命令"><a href="#paste命令" class="headerlink" title="paste命令"></a>paste命令</h1><p><code>paste</code>命令会把每个文件以列对列的方式，一列列地加以合并。</p><h2 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-23"><a href="#参数-23" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-d, --delimiters=[LIST]</code>: 用指定的间隔字符取代<code>TABs</code>字符。</li><li><code>-s, --serial</code>: 一次粘贴一个文件，而不是并行粘贴。</li><li><code>-z, --zero-terminated</code>: 行定界符为<code>NUL</code>，而不是换行符。</li><li><code>--help</code>: 显示此帮助并退出。</li><li><code>--version</code>: 输出版本信息并退出。</li></ul><h2 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h2><p>按列合并<code>/tmp/file1.txt</code>与<code>/tmp/file2.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste /tmp/file1.txt /tmp/file2.txt</span><br></pre></td></tr></table></figure><p>按列合并<code>/tmp/file1.txt</code>与<code>/tmp/file2.txt</code>文件，并追加到<code>/tmp/file3.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste /tmp/file1.txt /tmp/file2.txt &gt;&gt; /tmp/file3.txt</span><br></pre></td></tr></table></figure><p>按列合并<code>/tmp/file1.txt</code>与<code>/tmp/file2.txt</code>文件，并指定间隔符<code>-</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -d - /tmp/file1.txt /tmp/file2.txt</span><br></pre></td></tr></table></figure><h1 id="od命令"><a href="#od命令" class="headerlink" title="od命令"></a>od命令</h1><p><code>od</code>命令会读取所指定的文件的内容，并将其内容以八进制字节码呈现出来。</p><h2 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">od [OPTION]... [FILE]...</span><br><span class="line">od [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]</span><br><span class="line">od --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.][b]]</span><br></pre></td></tr></table></figure><h2 id="参数-24"><a href="#参数-24" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-A, --address-radix=RADIX</code>: 选择要以何种基数计算字码。</li><li><code>-j, --skip-bytes=BYTES</code>: 跳过设置的字符数目。</li><li><code>-N, --read-bytes=BYTES</code>: 到设置的字符数目为止。</li><li><code>-S BYTES, --strings[=BYTES]</code>: 输出至少<code>BYTES</code>图形字符的字符串，未指定<code>BYTES</code>时默认<code>3</code>。</li><li><code>-t, --format=TYPE</code>: 设置输出格式。</li><li><code>-v, --output-duplicates</code>: 输出时不省略重复的数据。</li><li><code>-w[BYTES], --width[=BYTES]</code>: 设置每列的最大字符数。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h2><ul><li><code>-a</code>: 与<code>-t a</code>相同，选择命名字符。</li><li><code>-b</code>: 与<code>-t o1</code>相同，选择八进制字节。</li><li><code>-c</code>: 与<code>-t c</code>相同，选择<code>ASCII</code>字符或反斜杠转义。</li><li><code>-d</code>: 与<code>-t u2</code>相同，选择无符号十进制<code>2</code>字节单位。</li><li><code>-f</code>: 与<code>-t fF</code>相同，选择浮点数。</li><li><code>-i</code>: 与<code>-t dI</code>相同，选择十进制整数。</li><li><code>-l</code>: 与<code>-t dL</code>相同，选择十进制长。</li><li><code>-o</code>: 与<code>-t o2</code>相同，选择八进制<code>2</code>字节单位。</li><li><code>-s</code>: 与<code>-t d2</code>相同，选择十进制<code>2</code>字节单位。</li><li><code>-x</code>: 与<code>-t x2</code>相同，选择十六进制<code>2</code>字节单位。</li><li><code>d[SIZE]</code>: 有符号十进制，每个整数<code>SIZE</code>个字节。</li><li><code>f[SIZE]</code>: 浮点数，每个整数<code>SIZE</code>个字节。</li><li><code>o[SIZE]</code>: 八进制，每个整数<code>SIZE</code>个字节。</li><li><code>u[SIZE]</code>: 无符号十进制，每个整数<code>SIZE</code>个字节。</li><li><code>x[SIZE]</code>: 十六进制，每个整数<code>SIZE</code>个字节。</li></ul><h2 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h2><p>输出文件八进制字节码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od /tmp/file.txt</span><br></pre></td></tr></table></figure><p>使用单字节八进制解释进行输出，左侧的默认地址格式为八字节。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -c /tmp/file.txt</span><br></pre></td></tr></table></figure><p>使用<code>ASCII</code>码进行输出，其中包括转义字符，左侧的默认地址格式为八字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t d1 /tmp/file.txt</span><br></pre></td></tr></table></figure><h1 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h1><p><code>netstat</code>命令显示各种网络相关信息，例如网络连接、路由表、接口统计信息、伪装连接、多播成员身份等。</p><h2 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">netstat [address_family_options] [--tcp|-t] [--udp|-u] [--raw|-w] </span><br><span class="line">        [--listening|-l] [--all|-a] [--numeric|-n] [--numeric-hosts] </span><br><span class="line">        [--numeric-ports] [--numeric-users] [--symbolic|-N] </span><br><span class="line">        [--extend|-e[--extend|-e]] [--timers|-o] [--program|-p] </span><br><span class="line">        [--verbose|-v] [--continuous|-c]</span><br><span class="line"></span><br><span class="line">netstat &#123;--route|-r&#125; [address_family_options] [--extend|-e[--extend|-e]] </span><br><span class="line">        [--verbose|-v] [--numeric|-n] [--numeric-hosts] [--numeric-ports] </span><br><span class="line">        [--numeric-users] [--continuous|-c]</span><br><span class="line">        </span><br><span class="line">netstat &#123;--interfaces|-i&#125; [--all|-a] [--extend|-e[--extend|-e]] [--verbose|-v] </span><br><span class="line">        [--program|-p] [--numeric|-n] [--numeric-hosts] [--numeric-ports] </span><br><span class="line">        [--numeric-users] [--continuous|-c]</span><br><span class="line"></span><br><span class="line">netstat &#123;--groups|-g&#125; [--numeric|-n] [--numeric-hosts] [--numeric-ports] </span><br><span class="line">        [--numeric-users] [--continuous|-c]</span><br><span class="line">        </span><br><span class="line">netstat &#123;--masquerade|-M&#125; [--extend|-e] [--numeric|-n] [--numeric-hosts] </span><br><span class="line">        [--numeric-ports] [--numeric-users] [--continuous|-c]</span><br><span class="line">        </span><br><span class="line">netstat &#123;--statistics|-s&#125; [--tcp|-t] [--udp|-u] [--raw|-w]</span><br><span class="line"></span><br><span class="line">netstat &#123;--version|-V&#125;</span><br><span class="line"></span><br><span class="line">netstat &#123;--help|-h&#125;</span><br><span class="line"></span><br><span class="line">address_family_options may be any combination of the following options: </span><br><span class="line">[-4] [-6] [--protocol=&#123;inet,unix,ipx,ax25,netrom,ddp&#125;[,...]] [--unix|-x] </span><br><span class="line">[--inet|--ip] [--ax25] [--ipx] [--netrom] [--ddp]</span><br></pre></td></tr></table></figure><h2 id="参数-25"><a href="#参数-25" class="headerlink" title="参数"></a>参数</h2><p><code>netstat</code>打印的信息类型由第一个参数控制，该参数是以下参数之一:</p><ul><li><code>(none)</code>: 默认情况下，<code>netstat</code>显示打开的套接字列表，如果未指定任何地址族，则将打印所有已配置地址族的活动套接字。</li><li><code>--route, -r</code>: 显示内核路由表，<code>netstat -r</code>和<code>route -e</code>产生相同的输出。</li><li><code>--groups, -g</code>: 显示<code>IPv4</code>和<code>IPv6</code>的多播组成员身份信息。</li><li><code>--interfaces, -i</code>: 显示所有网络接口的表。</li><li><code>--masquerade, -M</code>: 显示伪装的连接列表。</li><li><code>--statistics, -s</code>: 显示每个协议的摘要统计信息。</li></ul><p>在第一个参数之后，以下选项指定<code>netstat</code>的报告行为: </p><ul><li><code>--verbose, -v</code>: 通过详细操作告诉用户发生了什么，特别是打印一些有关未配置地址族的有用信息。</li><li><code>--wide, -W</code>: 使用指定宽度而不根据使用输出来截断<code>IP</code>地址，为了不破坏现有的脚本，这是可选的。</li><li><code>--numeric, -n</code>: 显示数字地址，而不是尝试确定符号主机、端口或用户名。</li><li><code>--numeric-hosts</code>: 显示数字主机地址，但不影响端口或用户名的解析。</li><li><code>--numeric-ports</code>: 显示数字端口号，但不影响主机名或用户名的解析。</li><li><code>--numeric-users</code>: 显示数字用户<code>id</code>，但不影响主机名或端口名的解析。</li><li><code>--protocol=family, -A</code>: 指定要显示其连接的地址族(低级协议)，该族是逗号分隔的地址族关键字列表，如<code>inet</code>、<code>unix</code>、<code>ipx</code>、<code>ax25</code>、<code>netrom</code>和<code>ddp</code>，这与使用<code>--inet</code>、<code>-unix(-x)</code>、<code>-ipx</code>、<code>-ax25</code>、<code>-netrom</code>和<code>--ddp</code>选项具有相同的效果，地址族<code>inet</code>包括<code>raw</code>、<code>udp</code>和<code>tcp</code>协议套接字。</li><li><code>-c, --continuous</code>: 使<code>netstat</code>每秒连续打印所选信息。</li><li><code>-e, --extend</code>: 显示附加信息，使用此选项两次以获得最大细节。</li><li><code>-o, --timers</code>: 包括与网络计时器相关的信息。</li><li><code>-p, --program</code>: 显示<code>PID</code>进程标识符和每个套接字所属的程序的名称。</li><li><code>-l, --listening</code>: 只显示监听套接字，这些在默认情况下被省略。</li><li><code>-a, --all</code>: 显示监听和非监听套接字，使用<code>--interfaces</code>选项显示未启动的接口。</li><li><code>-F</code>: 从<code>FIB</code>打印路由信息，这是默认设置。</li><li><code>-C</code>: 从路由缓存中打印路由信息。</li></ul><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><p>关于活跃的互联网连接<code>TCP</code>、<code>UDP</code>、<code>raw</code>的信息属于以下类别: </p><ul><li><code>Proto</code>: 套接字使用的协议<code>tcp</code>、<code>udp</code>、<code>raw</code>。</li><li><code>Recv-Q</code>: 连接到此套接字的用户程序未复制的字节数。</li><li><code>Send-Q</code>: 远程主机未确认的字节数。</li><li><code>Local Address</code>: 套接字本地端的地址和端口号，除非指定了<code>--numeric, -n</code>选项，否则套接字地址将解析为其规范的主机名<code>FQDN</code>，并且端口号将转换为相应的服务名。</li><li><code>Foreign Address</code>: 套接字远端的地址和端口号，类似于本地地址。</li><li><code>State</code>: <code>socket</code>的状态，由于在原始套接字<code>raw</code>模式中没有状态，而且<code>UDP</code>中通常没有使用状态，因此这一列可以留空，通常这可以是以下值之一，<code>TCP</code>握手与挥手的过程中通常会经历这些状态。<ul><li><code>ESTABLISHED</code>: 套接字已建立连接。</li><li><code>SYN_SENT</code>: 套接字正在积极尝试建立连接。</li><li><code>SYN_RECV</code>: 从网络接收到连接请求。</li><li><code>FIN_WAIT1</code>: 套接字已关闭，连接正在关闭。</li><li><code>FIN_WAIT2</code>: 连接已关闭，套接字正在等待从远端关闭。</li><li><code>TIME_WAIT</code>: 套接字在关闭后正在等待处理仍在网络中的数据包。</li><li><code>CLOSE</code>: 没有使用该套接字。</li><li><code>CLOSE_WAIT</code>: 远端已关闭，等待套接字关闭。</li><li><code>LAST_ACK</code>: 远端已经关闭，套接字已关闭，等待确认。</li><li><code>LISTEN</code>: 套接字正在监听传入的连接，除非指定<code>--listening, -l</code>或<code>--all, -a</code>选项，否则此类套接字不包含在输出中。</li><li><code>CLOSING</code>: 两个套接字都关闭了，但我们仍然没有发送所有的数据。</li><li><code>UNKNOWN</code>: 套接字的状态未知。</li></ul></li><li><code>User</code>: 套接字所有者的用户名或用户<code>ID(UID)</code>。</li><li><code>PID/Program name</code>: 进程<code>ID(PID)</code>和拥有套接字的进程的进程名称之间用斜杠分隔，<code>--program</code>使该列包括在内，需要超级用户特权才能在不拥有的套接字上查看此信息，此标识信息尚不适用于<code>IPX</code>套接字。</li></ul><h2 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h2><p>有关活动<code>UNIX</code>域套接字的信息属于以下类别: </p><ul><li><code>Proto</code>: 套接字使用的协议，通常是<code>unix</code>。</li><li><code>RefCnt</code>: 引用计数，即通过此套接字连接的进程。</li><li><code>Flags</code>: 显示的标志是<code>SO_ACCEPTON</code>显示为<code>ACC</code>，<code>SO_WAITDATA(W)</code>或<code>SO_NOSPACE(N)</code>，如果未连接的套接字的相应进程正在等待连接请求，则在未连接的套接字上使用<code>SO_ACCECPTON</code>，其他标志不是正常的关注点。</li><li><code>Type</code>: 套接字访问有几种类型: <ul><li><code>SOCK_DGRAM</code>: 套接字用于数据报(无连接)模式。</li><li><code>SOCK_STREAM</code>: 这是一个流(连接)套接字。</li><li><code>SOCK_RAW</code>: 该套接字用作原始套接字。</li><li><code>SOCK_RDM</code>: 这个服务提供可靠的消息传递。</li><li><code>SOCK_SEQPACKET</code>: 这是一个顺序数据包套接字。</li><li><code>SOCK_PACKET</code>: 原始接口访问套接字。</li></ul></li><li><code>State</code>: 该字段将包含以下关键字之一: <ul><li><code>FREE</code>: 未分配套接字。</li><li><code>LISTENING</code>:套接字正在监听连接请求，仅当指定<code>--listening, -l</code>或<code>--all, -a</code>选项时，此类套接字才会包含在输出中。</li><li><code>CONNECTING</code>: 套接字即将建立连接。</li><li><code>CONNECTED</code>: 套接字已连接。</li><li><code>DISCONNECTING</code>: 套接字正在断开连接。</li><li><code>(empty)</code>: 该套接字未连接到另一套接字。</li></ul></li><li><code>PID/Program name</code>:打开套接字的进程的进程<code>ID(PID)</code>和进程名称。</li><li><code>Path</code>: 这是相应进程附加到套接字的路径名。</li><li><code>Active IPX sockets</code>: 活动<code>IPX</code>套接字的列表。</li><li><code>Active NET/ROM sockets</code>: 活动<code>NET/ROM</code>套接字的列表。</li><li><code>Active AX.25 sockets</code>: 活动<code>AX.25</code>套接字的列表。</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><code>netstat</code>使用以下文件: </p><ul><li><code>/etc/services</code>: 服务转换文件。</li><li><code>/proc</code>: <code>proc</code>文件系统的挂载点，它以文件层次结构的形式提供对内核状态信息的访问。</li><li><code>/proc/net/dev</code>: 设备信息文件。</li><li><code>/proc/net/raw</code>: 原始套接字信息。</li><li><code>/proc/net/tcp</code>: <code>TCP</code>套接字信息。</li><li><code>/proc/net/udp</code>: <code>UDP</code>套接字信息。</li><li><code>/proc/net/igmp</code>: <code>IGMP</code>多播信息。</li><li><code>/proc/net/unix</code>: <code>Unix</code>域套接字信息。</li><li><code>/proc/net/ipx</code>: <code>IPX</code>套接字信息。</li><li><code>/proc/net/ax25</code>: <code>AX25</code>套接字信息。</li><li><code>/proc/net/appletalk</code>: <code>DDP(appletalk)</code>套接字信息。</li><li><code>/proc/net/nr</code>: <code>NET/ROM</code>套接字信息。</li><li><code>/proc/net/route</code>: <code>IP</code>路由信息。</li><li><code>/proc/net/ax25_route</code>: <code>AX25</code>路由信息。</li><li><code>/proc/net/ipx_route</code>: <code>IPX</code>路由信息。</li><li><code>/proc/net/nr_nodes</code>: <code>NET/ROM</code>节点列表。</li><li><code>/proc/net/nr_neigh</code>: <code>NET/ROM</code>邻居。</li><li><code>/proc/net/ip_masquerade</code>: 伪装的连接。</li><li><code>/proc/net/snmp</code>: 统计。</li></ul><h2 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h2><p>显示所有<code>listening</code>与<code>non-listening</code>的套接字，并使用管道和<code>less</code>便于查看当前状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | less</span><br></pre></td></tr></table></figure><p>列出所有<code>TCP</code>端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -at</span><br></pre></td></tr></table></figure><p>列出所有<code>udp</code>端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -au</span><br></pre></td></tr></table></figure><p>仅列出侦听端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -l</span><br></pre></td></tr></table></figure><p>列出所有端口的统计信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | less</span><br></pre></td></tr></table></figure><p>显示使用<code>TCP</code>的<code>PID</code>和程序名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -pt</span><br></pre></td></tr></table></figure><p>获取内核路由信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>获取与<code>ssh</code>相关的进程的网络信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ap | grep ssh</span><br></pre></td></tr></table></figure><p>获取<code>80</code>端口的网路状态信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp |grep :80</span><br></pre></td></tr></table></figure><p>获取网络接口列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>获取网络接口列表与拓展信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ie</span><br></pre></td></tr></table></figure><p>配合<code>awk</code>命令获取<code>TCP</code>套接字的状态统计信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant|awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#x27;</span><br></pre></td></tr></table></figure><h1 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h1><p><code>mv</code>命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><h2 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv [OPTION] [-T] SOURCE DEST</span><br><span class="line">mv [OPTION] SOURCE DIRECTORY</span><br><span class="line">mv [OPTION] -t DIRECTORY SOURCE</span><br></pre></td></tr></table></figure><h2 id="参数-26"><a href="#参数-26" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--backup[=CONTROL]</code>: 对每个现有目标文件进行备份。</li><li><code>-b</code>: 像<code>--backup</code>一样，但是不接受参数。</li><li><code>-f, --force</code>: 若指定目录已有同名文件，覆盖前不提示。</li><li><code>-i, --interactive</code>: 若指定目录已有同名文件，则先询问是否覆盖旧文件。</li><li><code>-n, --no-clobber</code>: 若指定目录已有同名文件，不覆盖此文件。</li><li><code>--strip-trailing-slashes</code>: 从每个源中删除所有结尾的斜杠。</li><li><code>-S, --suffix=SUFFIX</code>: 指定要用于所有备份文件的文件名后缀<code>SUFFIX</code>，默认值为<code>~</code>。</li><li><code>-t, --target-directory=DIRECTORY</code>: 将所有源移动到目标目录中，此时目标目录在前，源文件在后。。</li><li><code>-T, --no-target-directory</code>: 将目标视为普通文件，而不是目录。</li><li><code>-u, --update</code>: 如果文件较新，则不会覆盖，仅当目标文件早于源文件或目标文件不存在时才会发生移动。</li><li><code>-v, --verbose</code>: 提供详细的输出，打印每个移动文件的名称。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="语法设置"><a href="#语法设置" class="headerlink" title="语法设置"></a>语法设置</h2><div class="table-container"><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td><code>mv</code> 文件名 文件名</td><td>将源文件名改为目标文件名。</td></tr><tr><td><code>mv</code> 文件名 目录名</td><td>将文件移动到目标目录。</td></tr><tr><td><code>mv</code> 目录名 目录名</td><td>目标目录已存在，将源目录移动到目标目录，目标目录不存在则改名。</td></tr><tr><td><code>mv</code> 目录名 文件名</td><td>出错。</td></tr></tbody></table></div><h2 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h2><p>将<code>file2.txt</code>更名为<code>file3.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file2.txt file3.txt</span><br></pre></td></tr></table></figure><p>将<code>file.txt</code>移动到<code>var</code>目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file.txt /var/</span><br></pre></td></tr></table></figure><p>将<code>dir</code>目录改名为<code>dirs</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir dirs</span><br></pre></td></tr></table></figure><h1 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h1><p><code>more</code>命令类似<code>less</code>，以分页的形式浏览文件内容，在<code>more</code>命令退出后会在<code>shell</code>上留下操作的内容，在分页浏览时使用<code>h</code>键输出说明文件。</p><h2 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [options] [file]</span><br></pre></td></tr></table></figure><h2 id="参数-27"><a href="#参数-27" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-d</code>: 提示使用者，在画面下方显示<code>[Press space to continue, &#39;q&#39; to quit.]</code>，如果使用者按错键，则会显示<code>[Press &#39;h&#39; for instructions.]</code>而不是滴声。</li><li><code>-f</code>: 计算行数时，以实际上的行数，而非自动换行过后的行数，某些单行字数太长的会被扩展为两行或两行以上。</li><li><code>-l</code>: 取消遇见特殊字元<code>^L</code>送纸字元时会暂停的功能。</li><li><code>-c</code>: 不进行滚动而是从顶部绘制每个屏幕，清除每行显示的其余部分，跟<code>-p</code>相似，不同的是先显示内容再清除其他输出。</li><li><code>-p</code>: 不以滚动的方式显示每一页，而是先清除输出后再显示内容。</li><li><code>-s</code>: 当遇到有连续两行以上的空白行，就代换为一行的空白行。</li><li><code>-u</code>: 不显示下划线，根据环境变数<code>TERM</code>指定的<code>terminal</code>而有所不同。</li><li><code>-&lt;num&gt;</code>: 指定每屏的行数。</li><li><code>+&lt;num&gt;</code>: 从第<code>num</code>行开始显示。</li><li><code>+/&lt;str&gt;</code>: 在每个文档显示前搜寻字串<code>str</code>，然后从该字串之后开始显示。</li><li><code>-V</code>: 显示版本信息。</li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><code>h or ?</code>: 帮助菜单，显示命令的摘要。</li><li><code>SPACE</code>: 显示接下来的<code>k</code>行文本，默认为当前屏幕尺寸。</li><li><code>Enter</code>: 向下<code>n</code>行，需要定义，默认为<code>1</code>行。</li><li><code>Ctrl+F</code>: 向下滚动一屏。</li><li><code>Ctrl+B</code>: 返回上一屏。</li><li><code>=</code>: 输出当前行的行号。</li><li><code>:f</code>: 输出文件名和当前行的行号。</li><li><code>V</code>: 调用<code>vi</code>编辑器。</li><li><code>! &lt;cmd&gt;</code>: 调用<code>Shell</code>，并执行命令。</li><li><code>q</code>: 退出<code>more</code>命令。</li></ul><h2 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h2><p>分页显示<code>/var/log/ufw.log</code>文件内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /var/log/ufw.log</span><br></pre></td></tr></table></figure><p>从第<code>20</code>行开始显示<code>/var/log/ufw.log</code>文件内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +20 /var/log/ufw.log</span><br></pre></td></tr></table></figure><p>以<code>1</code>行分页显示<code>/var/log/ufw.log</code>文件内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -1 /var/log/ufw.log</span><br></pre></td></tr></table></figure><h1 id="mktemp命令"><a href="#mktemp命令" class="headerlink" title="mktemp命令"></a>mktemp命令</h1><p><code>mktemp</code>命令用于安全地创建一个临时文件或目录，并输出其名称，<code>TEMPLATE</code>在最后一个组件中必须至少包含<code>3</code>个连续的<code>X</code>，如果未指定<code>TEMPLATE</code>，则使用<code>tmp.XXXXXXXXXX</code>作为名称在当前目录下创建相应的临时文件，<code>X</code>为生成的随机数，尾部的<code>X</code>将替换为当前进程号和随机字母的组合，文件的名称取决于模板中<code>X</code>的数量以及与现有文件冲突的数量，<code>mktemp</code>可以返回的唯一文件名的数量取决于所提供的<code>X</code>的数量，十个<code>X</code>将导致<code>mktemp</code>测试大约<code>26**10</code>个组合，<code>mktemp</code>命令创建的临时文件不会使用默认的<code>umask</code>管理权限值，其会将文件的读写权限分配给文件属主，一旦创建了文件，在<code>shell</code>脚本中就拥有了完整的读写权限，除<code>root</code>外其他人不可访问，即在创建文件时即有<code>u+rw</code>权限，创建文件夹时有<code>u+rwx</code>权限。</p><h2 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mktemp [OPTION] [TEMPLATE]</span><br></pre></td></tr></table></figure><h2 id="参数-28"><a href="#参数-28" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-d, --directory</code>: 创建目录，而不是文件。</li><li><code>-u, --dry-run</code>: 在<code>mktemp</code>退出之前，临时文件将被取消链接，相当于不创建任何文件或文件夹，仅输出名称，不建议使用该选项。</li><li><code>-q, --quiet</code>: 执行时若发生错误，不会输出任何信息。</li><li><code>--suffix=SUFF</code>: 将<code>STUFF</code>附加到<code>TEMPLATE</code>，<code>SUFF</code>不能包含斜线，如果<code>TEMPLATE</code>不以<code>X</code>结尾，则默认此选项。</li><li><code>-p &lt;DIR&gt;, --tmpdir &lt;DIR&gt;</code>: 生成临时文件时使用指定的目录作为目标。</li><li><code>-t</code>: 将目标文件存储在临时目录，该目录首先会选择用户的<code>TMPDIR</code>环境变量，其次是用户指定的<code>-p</code>参数选择的目录，最后的选择即<code>/tmp</code>目录，创建后会输出临时文件的全路径。</li><li><code>--help</code>: 输出帮助选项。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h2><p>在当前目录创建临时文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mktemp tmp.XXX</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tmp.g6k</span></span><br></pre></td></tr></table></figure><p>创建指定文件类型的临时文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mktemp tmp.XXX --suffix=.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tmp.gSI.txt</span></span><br></pre></td></tr></table></figure><p>在指定目录创建临时文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mktemp --tmpdir=/home tmp.XXX</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/home/tmp.HxB</span></span><br></pre></td></tr></table></figure><h1 id="mc命令"><a href="#mc命令" class="headerlink" title="mc命令"></a>mc命令</h1><p><code>mc</code>是一个基于字符的目录浏览器和文件管理器，其将熟悉的图形文件管理器和常见的命令行工具联系在一起，<code>mc</code>的设计基于文件管理器中双目录窗格的设计，其中同时显示两个目录的列表，可以执行所有常见的文件和目录操作，例如复制、移动、重命名、链接和删除等，也允许操纵文件和目录权限等操作。</p><h2 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc [option] [file]</span><br></pre></td></tr></table></figure><h2 id="参数-29"><a href="#参数-29" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--configure-options</code>: 打印配置选项。</li><li><code>-e, --edit=&lt;file&gt;</code>: 以<code>mc</code>模式下编辑文件。</li><li><code>-f, --datadir</code>: 打印数据目录。</li><li><code>-F, --datadir-info</code>: 打印有关使用的数据目录的扩展信息。</li><li><code>-h, --help</code>: 显示帮助。</li><li><code>--help-all</code>: 显示所有帮助选项。</li><li><code>--help-terminal</code>: 终端选项。</li><li><code>--help-color</code>: 颜色选项。</li><li><code>-l, --ftplog=&lt;file&gt;</code>: 将<code>ftp</code>对话框记录到指定文件。</li><li><code>-P, --printwd=&lt;file&gt;</code>: 将最后一个工作目录打印到指定文件。</li><li><code>-u, --nosubshell</code>: 禁用<code>subshell</code>支持。</li><li><code>-U, --subshell</code>: 启用<code>subshell</code>支持，默认选项。</li><li><code>-v, --view=&lt;file&gt;</code>: 在文件上启动文件查看器。</li></ul><h2 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h2><p>启动<code>Midnight Commander</code>管理器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc</span><br></pre></td></tr></table></figure><h1 id="lsattr命令"><a href="#lsattr命令" class="headerlink" title="lsattr命令"></a>lsattr命令</h1><p><code>lsattr</code>命令用于显示文件的属性。</p><h2 id="语法-30"><a href="#语法-30" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr [-RVadlv] [file | folder]</span><br></pre></td></tr></table></figure><h2 id="参数-30"><a href="#参数-30" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a</code>: 显示所有文件和目录，包括以<code>.</code>为名称开头字符的额外内建，即现行目录<code>.</code>与上层目录<code>..</code>。</li><li><code>-d</code>: 显示目录名称，而非其内容。</li><li><code>-l</code>: 指出要显示设备的逻辑名称。</li><li><code>-R</code>: 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li><code>-v</code>: 显示文件或目录版本。</li><li><code>-V</code>: 显示版本信息。</li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><ul><li><code>a</code>: 使文件或目录仅供附加用途。</li><li><code>b</code>: 不更新文件或目录的最后存取时间。</li><li><code>c</code>: 将文件或目录压缩后存放。</li><li><code>d</code>: 将文件或目录排除在倾倒操作之外。</li><li><code>i</code>: 不得任意更动文件或目录。</li><li><code>s</code>: 保密性删除文件或目录。</li><li><code>S</code>: 即时更新文件或目录。</li><li><code>u</code>: 预防意外删除。</li></ul><h2 id="示例-30"><a href="#示例-30" class="headerlink" title="示例"></a>示例</h2><p>查看<code>file.txt</code>文件的属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr file.txt</span><br></pre></td></tr></table></figure><p>显示所有文件和目录的属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr -a</span><br></pre></td></tr></table></figure><p>递归处理将<code>/tmp/</code>目录下的所有文件及子目录一并处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr -R /tmp/</span><br></pre></td></tr></table></figure><h1 id="look命令"><a href="#look命令" class="headerlink" title="look命令"></a>look命令</h1><p><code>look</code>命令用于查询单词，仅需指定欲查询的字首字符串，它会显示所有开头字符串符合该条件的单词。</p><h2 id="语法-31"><a href="#语法-31" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">look [-bdf] [-t char] string [file ...]</span><br></pre></td></tr></table></figure><h2 id="参数-31"><a href="#参数-31" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --alternative</code>: 使用备用字典文件。</li><li><code>-d, --alphanum</code>: 使用普通字典字符集和顺序，即只比较空格和字母数字字符。如果未指定文件，则默认情况下此选项处于启用状态。</li><li><code>-f, --ignore-case</code>: 忽略字母字符的大小写，如果未指定文件，则默认情况下此选项处于启用状态。</li><li><code>-t, --terminate character</code>: 指定一个字符串终止字符，即仅比较字符串中直到第一个出现的字符，包括第一个出现的字符。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-h, --help</code>: 输出帮助信息。</li></ul><h2 id="示例-31"><a href="#示例-31" class="headerlink" title="示例"></a>示例</h2><p>使用<code>look</code>查找以<code>ab</code>开头的单词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">look ab</span><br><span class="line"># Abbas</span><br><span class="line"># Abbas&#x27;s</span><br><span class="line"># Abbasid</span><br><span class="line"># Abbasid&#x27;s</span><br><span class="line"># Abbott</span><br><span class="line"># Abbott&#x27;s</span><br><span class="line"># Abby</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><p>在文件中查找以<code>L</code>开头的单词并列出全句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># file.txt</span><br><span class="line">HELLO LINUX!  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">look L file.txt</span><br><span class="line">Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure><p>在上述示例中使用<code>-t</code>指定字符串终止字符，即仅比较字符串中第一次出现之前(包括第一次出现)的字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">look -t E HEO file.txt</span><br><span class="line"># HELLO LINUX!</span><br></pre></td></tr></table></figure><h1 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h1><p> <code>locate</code>命令用于查找符合条件的文件，其会去保存文件和目录名称的数据库内，查找符合指定条件的文件或目录，<code>locate</code>命令预设的数据库位于<code>/var/lib/mlocate/mlocate.db</code>，<code>locate</code>与<code>find</code>不同，<code>find</code>是去硬盘找，而<code>locate</code>只在数据库中查找，这个数据库中含有本地所有文件信息，<code>Linux</code>系统自动创建这个数据库，并且每天自动更新一次，所以使用<code>locate</code>命令查不到最新变动过的文件，可以主动执行<code>updatedb</code>命令以更新数据库。</p><h2 id="语法-32"><a href="#语法-32" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [OPTION] [PATTERN]</span><br></pre></td></tr></table></figure><h2 id="参数-32"><a href="#参数-32" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --basename</code>: 仅将基本名称与指定的模式匹配。</li><li><code>-c, --count</code>: 在标准输出上不输出文件名，而只输出匹配条目的数量。</li><li><code>-d, --database &lt;DBPATH&gt;</code>: 用指定的数据库替换默认数据库，如果指定了多个<code>--database</code>选项，则结果路径是单独路径的串联，此外空数据库文件名将替换为默认数据库。</li><li><code>-e, --existing</code>: 仅打印引用定位时存在的文件的条目。</li><li><code>-L, --follow</code>: 在检查文件是否存在时，遵循尾随的符号链接，这会使将导致断开的符号链接从输出中省略，这是默认行为。</li><li><code>-h, --help</code>: 在线帮助。</li><li><code>-i, --ignore-case</code>: 匹配模式时忽略大小写区别。</li><li><code>-l, --limit, -n &lt;LIMIT&gt;</code>: 找到<code>LIMIT</code>个条目后成功退出，如果指定了<code>--count</code>选项，则结果计数也将限制为<code>LIMIT</code>。</li><li><code>-m, --mmap</code>: 出于<code>BSD</code>和<code>GNU</code>兼容性而被忽略。</li><li><code>-P, --nofollow, -H</code>: 在检查文件是否存在时，不跟随尾随的符号链接，这会使断开的符号链接像其他文件一样被报告。</li><li><code>-0, --null</code>: 使用<code>ASCII NUL</code>字符分隔输出上的条目，而不是将每个条目写在单独的行上，此选项旨在与<code>GNU xargs</code>的 <code>--null</code>选项互操作。</li><li><code>-S, --statistics</code>: 将每个有关读取数据库的统计信息写入标准输出，而不是搜索文件并成功退出。</li><li><code>-q, --quiet</code>: 不输出任何有关读取和处理数据库时遇到的错误的消息。</li><li><code>-r, --regexp &lt;REGEXP&gt;</code>: 搜索基本的正则表达式，如果使用此选项，则不允许使用模式匹配，但可以多次指定此选项。</li><li><code>--regex</code>: 将所有<code>PATTERN</code>解释为扩展的正则表达式。</li><li><code>-s, --stdio</code>: 出于<code>BSD</code>和<code>GNU</code>兼容性而被忽略。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-w, --wholename</code>: 将整个路径名与指定的模式匹配，这是默认行为。</li></ul><h2 id="示例-32"><a href="#示例-32" class="headerlink" title="示例"></a>示例</h2><p>查找<code>file.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate file.txt</span><br></pre></td></tr></table></figure><p>输出匹配<code>file.txt</code>文件名的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -c file.txt</span><br></pre></td></tr></table></figure><p>匹配以<code>make</code>结尾的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate -r make$</span><br></pre></td></tr></table></figure><h1 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h1><p><code>ln</code>命令用来为文件创建链接，链接类型分为硬链接和软链接两种，软链接又称符号链接，默认的链接类型是硬链接，如果要创建符号链接必须使用<code>-s</code>选项，符号链接文件不是一个独立的文件，其很多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。</p><h2 id="语法-33"><a href="#语法-33" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [-bdfinsvF] [-S backup-suffix] [-V &#123;numbered,existing,simple&#125;] [--help] [...] [origin] [target]</span><br></pre></td></tr></table></figure><h2 id="参数-33"><a href="#参数-33" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --backup</code>: 删除，覆盖目标文件之前的备份。</li><li><code>-d, -F, --directory</code>: 建立目录的硬链接。</li><li><code>-f, --force</code>: 强行建立文件或目录的链接，不论文件或目录是否存在。</li><li><code>-i, --interactive</code>: 覆盖既有文件之前先询问用户。</li><li><code>-n, --no-dereference</code>: 把符号链接的目的目录视为一般文件。</li><li><code>-s, --symbolic</code>: 对源文件建立符号链接，而非硬链接。</li><li><code>-S &lt;backup-suffix&gt;, --suffix=&lt;backup-suffix&gt;</code>: 用<code>-b</code>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字符串是符号<code>~</code>，用户可通过<code>-S</code>参数来改变它。</li><li><code>-v, --verbose</code>: 显示指令执行过程。</li><li><code>-V &lt;backup method&gt;, --version-control=&lt;backup method&gt;</code>: 用<code>-b</code>参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用<code>-S</code>参数变更，当使用<code>-V</code>参数&lt;备份方式&gt;指定不同备份方式时，也会产生不同字尾的备份字符串。</li><li><code>--help</code>: 在线帮助。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><ul><li>软链接以路径的形式存在，类似于<code>Windows</code>操作系统中的快捷方式。</li><li>软链接可以 跨文件系统，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接。</li><li>软链接可以对目录进行链接。</li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><ul><li>硬链接，以文件副本的形式存在，但不占用实际空间。</li><li>不允许给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li></ul><h2 id="示例-33"><a href="#示例-33" class="headerlink" title="示例"></a>示例</h2><p>为<code>file.txt</code>创建软链接<code>filesoftlink</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s file.txt filesoftlink</span><br></pre></td></tr></table></figure><p>为<code>file.txt</code>创建硬链接<code>filehardlink</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file.txt filehardlink</span><br></pre></td></tr></table></figure><p>显示版本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln --version</span><br></pre></td></tr></table></figure><h1 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h1><p><code>less</code>命令的作用与<code>more</code>相似，都可以用来浏览文件的内容，用<code>less</code>命令显示文件时，使用<code>pageup</code>键向上翻页，使用<code>pagedown</code>键向下翻页，使用<code>↑</code>与<code>↓</code>按行浏览，使用<code>q</code>退出浏览，<code>less</code>在加载时不必读整个文件，加载速度会比<code>more</code>更快，<code>less</code>退出后<code>shell</code>不会留下刚显示的内容，而<code>more</code>退出后会在<code>shell</code>上留下刚显示的内容。</p><h2 id="语法-34"><a href="#语法-34" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [option] [file]</span><br></pre></td></tr></table></figure><h2 id="参数-34"><a href="#参数-34" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b &lt;buffer size&gt;</code>: 设置缓冲区的大小。</li><li><code>-e</code>: 当文件显示结束后，自动离开。</li><li><code>-f</code>: 强迫打开特殊文件，例如外围设备代号、目录和二进制文件。</li><li><code>-g</code>: 只标志最后搜索的关键词。</li><li><code>-i</code>: 忽略搜索时的大小写。</li><li><code>-m</code>: 显示类似<code>more</code>命令的百分比。</li><li><code>-N</code>: 显示每行的行号。</li><li><code>-o &lt;file&gt;</code>: 将<code>less</code>输出的内容在指定文件中保存起来。</li><li><code>-Q</code>: 不使用警告音。</li><li><code>-s</code>: 显示连续空行为一行。</li><li><code>-S</code>: 行过长时将超出部分舍弃。</li><li><code>-x &lt;num&gt;</code>: 将<code>tab</code>键显示为规定的数字空格。</li></ul><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><code>ctrl + F</code>: 向前移动一屏。</li><li><code>ctrl + B</code>: 向后移动一屏。</li><li><code>ctrl + D</code>: 向前移动半屏。</li><li><code>ctrl + U</code>: 向后移动半屏。</li><li><code>j</code>: 向前移动一行</li><li><code>k</code>: 向后移动一行</li><li><code>/string</code>: 向下搜索字符串的功能。</li><li><code>?string</code>: 向上搜索字符串的功能。</li><li><code>n</code>: 重复前一个搜索，与<code>/</code>或<code>?</code>有关。</li><li><code>N</code>: 反向重复前一个搜索，与<code>/</code>或<code>?</code>有关。</li><li><code>b</code>: 向上翻一页。</li><li><code>d</code>: 向后翻半页。</li><li><code>h</code>: 显示帮助界面。</li><li><code>Q</code>: 退出<code>less</code>命令。</li><li><code>u</code>: 向前滚动半页。</li><li><code>y</code>: 向前滚动一行。</li><li><code>space</code>: 滚动一页。</li><li><code>enter</code>: 滚动一行。</li><li><code>pageup</code>: 向上翻动一页。</li><li><code>pagedown</code>: 向下翻动一页。</li><li><code>G</code>: 移动到最后一行。</li><li><code>g</code>: 移动到第一行。</li><li><code>q / ZZ</code>: 退出<code>less</code>命令。</li><li><code>v</code>: 使用配置的编辑器编辑当前文件。</li><li><code>h</code>: 显示<code>less</code>的帮助文档。</li><li><code>&amp;pattern</code>: 仅显示匹配模式的行，而不是整个文件。</li><li><code>ma</code>: 使用<code>a</code>标记文本的当前位置。</li><li><code>a</code>: 导航到标记<code>a</code>处。</li></ul><h2 id="示例-34"><a href="#示例-34" class="headerlink" title="示例"></a>示例</h2><p>浏览<code>file.txt</code>文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file.txt</span><br></pre></td></tr></table></figure><p><code>ps</code>查看进程信息并通过<code>less</code>分页显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | less</span><br></pre></td></tr></table></figure><p>查看<code>file.txt</code>文件并检索向后检索<code>1</code>字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less file.txt </span><br><span class="line">/1</span><br></pre></td></tr></table></figure><h1 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h1><p><code>kill</code>命令向指定的<code>pid</code>进程发送信号，如果不指定要发送的<code>signal</code>信号，则默认情况下<code>signal</code>是<code>SIGTERM</code>，它会终止进程，要列出所有可用信号，可以使用<code>-l</code>选项获取<code>Linux</code>信号列表，经常使用的信号包括<code>HUP</code>、<code>INT</code>、<code>KILL</code>、<code>STOP</code>、<code>CONT</code>和<code>0</code>，可以通过三种方式指定信号: 按数字例如<code>-9</code>，带有<code>SIG</code>前缀例如<code>-SIGKILL</code>，不带<code>SIG</code>前缀例如<code>-KILL</code>。负<code>PID</code>值用于指示过程组<code>ID</code>，如果传递了进程组<code>ID</code>，则该组中的所有进程都将接收到该信号，<code>PID</code>为<code>-1</code>是特殊的，其指示除两个以外的所有进程，<code>kill</code>进程本身和<code>init</code>即<code>PID 1</code>，其是系统上所有进程的父进程，将<code>-1</code>指定为目标会将信号发送到除这两个以外的所有进程。</p><h2 id="语法-35"><a href="#语法-35" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill pid ...</span><br><span class="line">kill &#123;-signal | -s signal&#125; pid ...</span><br><span class="line">kill &#123;-l | --list[=signal] | -L | --table&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-35"><a href="#参数-35" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-signal, -s signal</code>: 要发送的信号的名称、缩写名或编号，前面有破折号，例如<code>-SIGTERM</code>、<code>-TERM</code>、<code>-15</code>等，要查看可用信号的列表可以使用<code>kill -l</code>。</li><li><code>pid</code>: 数字进程<code>ID</code>，如果不确定某个进程的<code>PID</code>是什么，可以使用<code>ps</code>命令将其列出例如<code>ps -aux</code>，通常会配合管道与<code>grep</code>使用例如查看<code>nginx</code>相关的进程<code>ps -aux | grep nginx</code>。</li><li><code>-l, --list[=signal]</code>: 列出可用的信号名称，用<code>-l</code>或<code>--list</code>列出所有信号名称，使用<code>--list = signal</code>，可将数字转换为其信号名称。</li><li><code>-L, --table</code>: 在表格中列出可用的信号名称和编号。</li></ul><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>下列的某些信号是不能使用的，因为系统有可能不支持这些信号，或者这些信号已中断，详情可以实际查阅系统的<code>kill -l</code>命令。每个系统都有信号<code>1</code>、<code>3</code>、<code>9</code>和<code>15</code>，这些是最常见的信号。终止信号不仅用于关闭锁定的应用程序，还可以阻止软件执行不允许的任务，这意味着其中一些终止信号是安全的一部分，另外<code>kill</code>命令不仅停止<code>/</code>终止进程，而且还暂停，继续和重新启动进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><ul><li><code>SIGHUP</code>: <code>SIGHUP</code>信号用于断开进程与父进程的连接，这也可以用于重新启动进程，这对于内存泄漏的守护程序很有用。</li><li><code>SIGINT</code>: 该信号与按<code>Ctrl+C</code>相同，在某些系统上<code>delete + break</code>会向进程发送相同的信号，该进程被中断并停止，但是该进程自身可以忽略此信号。</li><li><code>SIGQUIT</code>: 这类似于<code>SIGINT</code>，但由于<code>QUIT</code>字符通常是由<code>Ctrl+\</code>来控制，进程在收到<code>SIGQUIT</code>退出时会产生<code>core</code>文件, 在这个意义上类似于一个程序错误信号。</li><li><code>SIGILL</code>: 当一个进程执行一个错误的、禁止的或未知的功能时，系统向该进程发送<code>SIGILL</code>信号，这是代表非法操作的信号。</li><li><code>SIGTRAP</code>: 此信号用于调试目的，当某个进程执行了某个操作或满足了调试器正在等待的条件时，此信号将被发送到该进程。</li><li><code>SIGABRT</code>: 该终止信号是中止信号,通常进程会在自身上发出此终止信号。</li><li><code>SIGBUS</code>: 当一个进程被发送<code>SIGBUS</code>信号时，是因为该进程导致了一个总线错误，通常这些总线错误是由于进程试图使用假物理地址或进程的内存对齐设置不正确造成的。</li><li><code>SIGFPE</code>: 被零除的进程使用<code>SIGFPE</code>终止。</li><li><code>SIGKILL</code>: <code>SIGKILL</code>信号强制进程立即停止执行，程序不能忽略该信号，此过程也无法清除。</li><li><code>SIGUSR1</code>: 这表示用户定义的条件，用户可以通过在<code>sigusr1.c</code>中编程命令来设置此信号。</li><li><code>SIGSEGV</code>: 当应用程序有分段冲突时，这个信号被发送到进程。</li><li><code>SIGUSR2</code>: 这表示用户定义的条件。</li><li><code>SIGPIPE</code>: 当进程尝试写入缺少与读取器连接的一端的管道时，此信号将发送到进程，读取器是在管道末端读取数据的过程。</li><li><code>SIGALRM</code>: 当实时或时钟计时器到期时，将发送<code>SIGALRM</code>。</li><li><code>SIGTERM</code>: 该信号请求进程停止运行，该信号可以被程序自身忽略，该过程有时间正常关闭，当程序正常关闭时，这意味着它有时间保存进度并释放资源，换句话说即它不被迫停止。</li><li><code>SIGCHLD</code>: 当父进程丢失其子进程时，将向父进程发送<code>SIGCHLD</code>信号，这将清理子进程使用的资源，子进程指的是由另一个称为父进程的进程启动的进程。</li><li><code>SIGCONT</code>: 要使进程在被<code>SIGTSTP</code>或<code>SIGSTOP</code>信号暂停后继续执行，需要将<code>SIGCONT</code>信号发送到已暂停的进程，这是<code>CONTiNUE SIGNAL</code>，该信号对<code>Unix</code>作业控制执行后台任务很有帮助。</li><li><code>SIGSTOP</code>: 该信号使操作系统暂停进程的执行，进程自身不能忽略该信号。</li><li><code>SIGTSTP</code>: 这个信号类似于按下<code>Ctrl+Z</code>，它向包含进程的终端发出请求，请求进程暂时停止，进程自身可以忽略该信号。</li><li><code>SIGTTIN</code>: 当进程试图从<code>tty</code>终端读取数据时，进程接收到这个信号。</li><li><code>SIGTTOU</code>: 当某个进程尝试向<code>tty</code>终端进行写操作时，该进程将收到此信号。</li><li><code>SIGURG</code>: 当进程中有紧急数据要读取或数据非常大时，<code>SIGURG</code>信号将发送到该进程。</li><li><code>SIGXCPU</code>: 当某个进程在分配的时间之后使用<code>CPU</code>时，系统将向该进程发送该信号，<code>SIGXCPU</code>的行为就像一个警告，该进程有时间保存进度(如果可能)并在系统使用<code>SIGKILL</code>终止该进程之前将其关闭。</li><li><code>SIGXFSZ</code>: 文件系统对文件的大小有限制，当程序尝试违反此限制时，系统将发送该过程<code>SIGXFSZ</code>信号。</li><li><code>SIGVTALRM</code>: <code>SIGVTALRM</code>在进程使用的<code>CPU</code>时间结束时发送。</li><li><code>SIGPROF</code>: 当进程以及由系统代表进程使用的<code>CPU</code>时间过去时，将发送<code>SIGPROF</code>信号。</li><li><code>SIGWINCH</code>: 当进程在更改其大小的终端中时，该进程将接收此信号。</li><li><code>SIGIO</code>: <code>SIGPOLL</code>的别名或至少表现得很像<code>SIGPOLL</code>。</li><li><code>SIGPWR</code>: 电源故障将导致系统将该信号发送到进程，如果系统仍在运行。</li><li><code>SIGSYS</code>: 为系统调用提供无效参数的进程将接收此信号。</li><li><code>SIGRTMIN*</code>: 这是一组在系统之间变化的信号，它们被标记为<code>SIGRTMIN + 1</code>、<code>SIGRTMIN + 2</code>、<code>SIGRTMIN + 3</code>、<code>...</code>，通常最多<code>15</code>个，这些是用户定义的信号，它们必须在<code>Linux</code>内核的源代码中进行编程。</li><li><code>SIGRTMAX*</code>: 这是一组在系统之间变化的信号，它们被标记为<code>SIGRTMAX-1</code>、<code>SIGRTMAX-2</code>、<code>SIGRTMAX-3</code>、<code>...</code>，通常最多<code>14</code>个，这些是用户定义的信号，它们必须在<code>Linux</code>内核的源代码中进行编程。</li><li><code>SIGEMT</code>:  指示一个实现定义的硬件故障。</li><li><code>SIGINFO</code>: 终端有时可能会向进程发送状态请求，发生这种情况时，进程也将收到此信号。</li><li><code>SIGLOST</code>: 试图访问锁定文件的进程将收到此信号。</li><li><code>SIGPOLL</code>: 当进程引起异步<code>I/O</code>事件时，会向该进程发送<code>SIGPOLL</code>信号。</li></ul><h2 id="示例-35"><a href="#示例-35" class="headerlink" title="示例"></a>示例</h2><p>要显示所有可用信号，查看信号的详细信息可以使用<code>man</code>命令，例如信号<code>7 SIGBUS</code>即使用<code>man 7 signal</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><p>在表格中列出可用的信号名称和编号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -L</span><br></pre></td></tr></table></figure><p>终端断线，重新加载配置文件，平滑重启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -1 111</span><br></pre></td></tr></table></figure><p>通知进程关闭，使进程自行关闭，这个关闭是安全、干净地退出，如果<code>kill</code>命令后直接加进程的<code>pid</code>号默认选项为<code>-15</code>，这个信号是可以被进程自身忽略并继续执行自身的，即该信号是可以被阻塞和忽略的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -15 111</span><br></pre></td></tr></table></figure><p>强行中断当前程序的执行，类似<code>Ctrl+C</code>按键用以结束进程的结果，该信号是可以被阻塞和忽略的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -2 111</span><br></pre></td></tr></table></figure><p>退出进程，类似<code>Ctrl+\</code>按键用以结束进程的结果，该信号是可以被阻塞和忽略的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -3 111</span><br></pre></td></tr></table></figure><p>强行关闭进程，<code>-9</code>信号是无条件终止，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理，该信号是不可以被阻塞和忽略的，当然通常是不建议使用<code>kill -9</code>的，应该尝试使用<code>-15</code>以及<code>-2</code>给目标进程一个清理自身资源工作的机会，不要用收割机来修剪花盆里的花。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 111</span><br></pre></td></tr></table></figure><p>暂停进程，对于暂停信号进程自身不能忽略该信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -19 111 </span><br></pre></td></tr></table></figure><p>激活进程，对于激活信号必须发送到已暂停的进程才有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -18 111 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;which命令&quot;&gt;&lt;a href=&quot;#which命令&quot; class=&quot;headerlink&quot; title=&quot;which命令&quot;&gt;&lt;/a&gt;which命令&lt;/h1&gt;&lt;p&gt;&lt;code&gt;which&lt;/code&gt;命令用于标识在终端提示符下键入可执行文件名称或命令时执行的给定可</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Linux" scheme="https://blog.haodene.love/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令--下</title>
    <link href="https://blog.haodene.love/2023/07/01/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8--%E4%B8%8B/"/>
    <id>https://blog.haodene.love/2023/07/01/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8--%E4%B8%8B/</id>
    <published>2023-07-01T04:30:00.000Z</published>
    <updated>2023-10-17T03:33:55.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="journalctl命令"><a href="#journalctl命令" class="headerlink" title="journalctl命令"></a>journalctl命令</h1><p><code>journalctl</code>命令是<code>Systemd</code>日志系统的一个命令，主要用途是用来查看通过<code>Systemd</code>日志系统记录的日志，在<code>Systemd</code>出现之前，<code>Linux</code>系统及各应用的日志都是分别管理的，<code>Systemd</code>取代了<code>initd</code>之后便开始统一管理了所有<code>Unit</code>的启动日志，可以只用一个<code>journalctl</code>命令，查看所有内核和应用的日志。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl [OPTIONS...] [MATCHES...]</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--no-full, --full, -l</code>: 当字段匹配可用列时将其省略，默认设置是显示完整字段，允许它们换行或被截断，旧的选项<code>-l/--full</code>不再有用，除了撤销<code>--no-full</code>。</li><li><code>-a, --all</code>: 完整显示所有字段，即使它们包含不可打印字符或非常长。</li><li><code>-f, --follow</code>: 仅显示最近的日志条目，并在新条目附加到日志时连续打印。</li><li><code>-e, --pager-end</code>: 立即跳到日志的结尾内隐含的工具，这意味着<code>-n 1000</code>可以保证分页器不会缓冲大小不受限制的日志，可以在命令行中使用显式的<code>-n</code>和其他一些数值来覆盖它，注意，这个选项只支持<code>less</code>页。</li><li><code>-n, --lines=</code>: 显示最近的日志事件并限制显示的事件数，如果使用<code>--follow</code>，则隐含此选项，参数为正整数，是可选的，默认为<code>10</code>。</li><li><code>--no-tail</code>: 显示所有存储的输出行，即使在<code>follow</code>模式下也是如此，撤消<code>--line=</code>的效果。</li><li><code>-r, --reverse</code>: 反转输出，以便首先显示最新的条目。</li><li><code>-o, --output=</code>: 控制所显示的日志条目的格式，采用以下选项之一：<ul><li><code>short</code>: 默认值，并生成与经典<code>syslog</code>文件格式基本相同的输出，每个日志条目显示一行。</li><li><code>short-iso</code>: 与<code>short</code>非常相似，但显示<code>ISO 8601 wallclock</code>时间戳。</li><li><code>short-precise</code>: 与<code>short</code>非常相似，但是以微秒的精度显示时间戳。</li><li><code>short-monotonic</code>: 非常相似，但是显示的是<code>monotonic</code>的时间戳，而不是<code>wallclock</code>的时间戳。</li><li><code>verbose</code>: 显示具有所有字段的完整结构条目。</li><li><code>export</code>: 将日志序列化成适合备份和网络传输的二进制流，主要是基于文本的。</li><li><code>json</code>: 将条目格式化为<code>JSON</code>数据结构，每行一个。</li><li><code>json-pretty</code>: 将条目格式化为JSON数据结构，但将它们格式化为多行，以使人们更容易阅读。</li><li><code>json-sse</code>: 将条目格式化为<code>JSON</code>数据结构，但将它们包装为适合服务器发送的<code>Eventsm</code>的格式。</li><li><code>cat</code>: 生成一个非常简洁的输出，只显示每个日志条目的实际消息，没有元数据，甚至没有时间戳。</li></ul></li><li><code>-x, --catalog</code>: 用来自消息目录的解释文本扩充日志行，这将向输出中可用的日志消息中添加解释性帮助文本，这些简短的帮助文本将解释错误或日志事件的上下文、可能的解决方案，以及指向支持论坛、开发人员文档和任何其他相关手册的指针，注意，帮助文本不是对所有消息都可用，而是仅对选定的消息可用。此外，将<code>journalctl</code>输出附加到错误报告时，请不要使用<code>-x</code>。</li><li><code>-q, --quiet</code>: 当以普通用户身份运行时，禁止显示有关不可访问的系统日志的任何警告消息。</li><li><code>-m, --merge</code>: 显示所有可用的日志，包括远程日志的交叉条目。</li><li><code>-b [ID][±offset], --boot=[ID][±offset]</code>: 显示来自特定启动的消息，这将为<code>_BOOT_ID=</code>添加匹配项，参数可能为空，在这种情况下，将显示当前引导的日志，如果省略引导<code>ID</code>，则正偏移量将查找从日志开始的引导，而等于或小于零的偏移量将查找从日志结束的引导，因此，<code>1</code>表示按时间顺序在日志中找到的第一个引导，<code>2</code>表示第二个引导，依此类推，而<code>-0</code>表示最后一个引导，<code>-1</code>表示最后一个引导之前的引导，依此类推，空偏移量等同于指定<code>-0</code>，除非当前引导不是最后一次引导，例如因为指定<code>--directory</code>查看来自不同计算机的日志。如果指定了<code>32</code>个字符的<code>ID</code>，则可以选择后跟偏移量，该偏移量标识相对于<code>boot ID</code>给定的引导，负值表示较早的引导，正值表示较晚的引导，如果未指定<code>offset</code>，则假定值为零，并显示<code>ID</code>给定的引导日志。</li><li><code>--list-boots</code>: 显示引导编号(相对于当前引导)、它们的<code>id</code>以及与引导相关的第一条和最后一条消息的时间戳的列表。</li><li><code>-k, --dmesg</code>: 只显示内核消息，这意味着<code>-b</code>并添加匹配<code>_TRANSPORT=kernel</code>。</li><li><code>-u, --unit=UNIT|PATTERN</code>: 显示指定的<code>systemd</code>单元单元的消息，或任何与<code>PATTERN</code>匹配的单元的消息，如果指定了模式，日志中找到的单元名称列表将与指定的模式进行比较，并使用所有匹配的内容，对于每个单元名，将为来自该单元的消息添加一个匹配<code>_SYSTEMD_UNIT= unit</code>，以及来自<code>systemd</code>的消息和关于指定单元的<code>coredumps</code>的消息的额外匹配，该参数可以指定多次。</li><li><code>--user-unit=</code>: 显示指定用户会话单元的消息，这将为来自单元的消息<code>_SYSTEMD_USER_UNIT=</code>和<code>_UID=</code>添加匹配，并为来自会话<code>systemd</code>的消息和关于指定单元的<code>coredumps</code>的消息添加额外匹配，该参数可以指定多次。</li><li><code>-p, --priority=</code>: 根据消息优先级或优先级范围筛选输出，接受单个数字或文本日志级别(即在<code>0 emerg</code>和<code>7 debug</code>之间)，或以<code>..</code>形式表示的<code>numeric/text</code>日志级别范围，日志级别是<code>syslog</code>中记录的通常的<code>syslog</code>日志级别，即<code>emerg 0</code>、<code>alert 1</code>、<code>crit 2</code>、<code>err 3</code>、<code>warning 4</code>、<code>notice 5</code>、<code>info 6</code>、<code>debug 7</code>，如果指定一个日志级别，则显示该级别或更低(值更低优先级更高)日志级别的所有消息，如果指定了一个范围，则将显示该范围内的所有消息，包括该范围的开始值和结束值，这将为指定的优先级添加<code>PRIORITY=</code>匹配项。</li><li><code>-c, --cursor=</code>: 从传递的游标指定的日志位置开始显示条目。</li><li><code>--after-cursor=</code>: 从该光标指定的位置之后的日志位置开始显示条目，使用<code>--show-cursor</code>选项时将显示光标。</li><li><code>--show-cursor</code>: 光标显示在最后一项的两个破折号后，类似于<code>-- cursor: s=0639...</code>，光标的格式是私有的，可能会更改。</li><li><code>--since=, --until=</code>: 分别在指定日期或更新日期，或在指定日期或更新日期开始显示条目，日期规范的格式应该是<code>2012-10-30 18:17:16</code>，如果省略了时间部分，则假定为<code>00:00:00</code>，如果只省略了<code>seconds</code>组件，则假定为<code>:00</code>，如果省略了<code>date</code>部分，则假定为当前日期，或者理解字符串<code>yesterday</code>、<code>today</code>、<code>tomorrow</code>，分别表示当前日期的前一天<code>00:00:00</code>、当前日期的前一天<code>00:00:00</code>、当前日期的后一天，<code>now</code>指的是当前时间，最后，可以指定相对次数，以<code>-</code>或<code>+</code>作为前缀，分别表示当前时间之前或之后的次数。</li><li><code>-F, --field=</code>: 在日志的所有条目中打印指定字段可以接受的所有可能数据值。</li><li><code>--system, --user</code>: 显示来自系统服务和内核的消息(使用<code>--system</code>)，显示来自当前用户服务的消息(使用<code>--user</code>)，如果两者都未指定，则显示用户可以看到的所有消息。</li><li><code>-M, --machine=</code>: 显示来自运行中的本地容器的消息，指定要连接的容器名称。</li><li><code>-D DIR, --directory=DIR</code>: 以目录路径作为参数，如果指定，<code>journalctl</code>将操作指定的日志目录<code>DIR</code>，而不是默认的运行时和系统日志路径。</li><li><code>--file=GLOB</code>: 以文件<code>glob</code>作为参数，如果指定，<code>journalctl</code>将操作与<code>GLOB</code>匹配的指定日志文件，而不是默认的运行时和系统日志路径，可以指定多次，在这种情况下文件将被适当地交错。</li><li><code>--root=ROOT</code>: 以目录路径作为参数，如果指定，<code>journalctl</code>将对指定目录下的目录文件层次结构而不是根目录进行操作，例如<code>--update catalog</code>将创建<code>root/var/lib/systemd/catalog/database</code>。</li><li><code>--new-id128</code>: 生成一个新的适合标识消息的<code>128</code>位<code>ID</code>，而不是显示日志内容，这是为那些需要为他们引入的新消息使用新标识符并希望使其可识别的开发人员准备的，这将以三种不同的格式打印新的<code>ID</code>，这些格式可以复制到源代码或类似的文件中。</li><li><code>--header</code>: 不是显示日志内容，而是显示所访问日志字段的内部头信息。</li><li><code>--disk-usage</code>: 显示所有日志文件的当前磁盘使用情况。</li><li><code>--list-catalog [128-bit-ID...]</code>: 以消息<code>id</code>表的形式列出消息目录的内容，以及它们的简短描述字符串，如果指定了任何<code>128</code>位<code>id</code>，则只显示那些条目。</li><li><code>--dump-catalog [128-bit-ID...]</code>: 显示消息目录的内容，条目由由两个破折号和<code>ID</code>组成的行分隔，格式与<code>.catalog</code>文件相同，如果指定了任何<code>128</code>位<code>id</code>，则只显示那些条目。</li><li><code>--update-catalog</code>: 更新消息目录索引，每次安装、删除或更新新的编目文件以重新生成二进制编目索引时，都需要执行此命令。</li><li><code>--setup-keys</code>: 生成一个用于前向安全密封<code>FSS</code>的新密钥对，而不是显示日志内容，这将生成一个密封密钥和一个验证密钥，密封密钥存储在日志数据目录中，并保留在主机上，验证键应该存储在外部。</li><li><code>--force</code>: 当传递了<code>--setup keys</code>并且已经配置了前向安全密封<code>FSS</code>时，重新创建<code>FSS keys</code>。</li><li><code>--interval=</code>: 指定使用<code>--setup-keys</code>生成<code>FSS</code>密钥对时密封密钥的更改间隔，较短的时间间隔会增加<code>CPU</code>消耗，但会缩短无法检测到的日志更改的时间范围，默认为<code>15</code>分钟。</li><li><code>--verify</code>: 检查日志文件的内部一致性，如果文件是在启用<code>FSS</code>的情况下生成的，并且<code>FSS</code>验证密钥是用<code>--verify key=</code>指定的，则会验证日志文件的真实性。</li><li><code>--verify-key=</code>: 指定用于<code>--verify</code>操作的<code>FSS</code>验证密钥。</li><li><code>--no-pager</code>: 不将程序的输出内容管道<code>pipe</code>给分页程序。</li><li><code>--vacuum-size=BYTES</code>: 将磁盘使用减少到指定大小以下。</li><li><code>--vacuum-files=INT</code>: 仅保留指定数量的日记文件。</li><li><code>--vacuum-time=TIME</code>: 任何早于指定时间点的条目都将被删除。</li><li><code>--rotate</code>: 要求日志守护进程滚动日志文件，此命令会一直阻塞到滚动操作完成之后才会返回，日志滚动可以确保所有活动的日志文件都被关闭、并被重命名以完成归档，同时新的空白日志文件将被创建，并成为新的活动日志文件，通常可以与<code>--vacuum-size=</code>、<code>--vacuum-time=</code>、<code>--vacuum-file=</code>一起使用， 以提高日志清理的效率。</li><li><code>-h, --help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>显示本次启动以来的全部日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl</span><br></pre></td></tr></table></figure><p>显示内核日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -k</span><br></pre></td></tr></table></figure><p>使用<code>-n</code>参数可以显示最后<code>n</code>行日志，如果不指定行数，默认显示<code>10</code>行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -n 20</span><br></pre></td></tr></table></figure><p>查看指定进程的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl _PID=1</span><br></pre></td></tr></table></figure><p>显示最近<code>30</code>分钟的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since=-30m</span><br></pre></td></tr></table></figure><p>显示<code>2021</code>年以来的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since=&quot;2021-01-01&quot;</span><br></pre></td></tr></table></figure><p>显示今天的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since=today</span><br></pre></td></tr></table></figure><p>使用<code>-f</code>参数可以实现类型<code>tail -f</code>的功能，持续监控最新的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -f</span><br></pre></td></tr></table></figure><p>查看指定<code>Unit</code>的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx.service</span><br></pre></td></tr></table></figure><p>查看日志占用的磁盘空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --disk-usage</span><br></pre></td></tr></table></figure><p>要求日志守护进程滚动日志文件，日志滚动可以确保所有活动的日志文件都被关闭、并被重命名以完成归档，同时新的空白日志文件将被创建，并成为新的活动日志文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --rotate</span><br></pre></td></tr></table></figure><p>清理一个周前的日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-time=1week</span><br></pre></td></tr></table></figure><p>将磁盘占用减少到指定大小以下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-size=10M</span><br></pre></td></tr></table></figure><h1 id="join命令"><a href="#join命令" class="headerlink" title="join命令"></a>join命令</h1><p><code>join</code>命令用于将两个文件中，指定栏位内容相同的行连接起来。其首先找出两个文件中指定栏位内容相同的行，并加以合并，再输出到标准输出设备。</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">join [OPTION]... FILE1 FILE2</span><br></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a FILENUM</code>: 从<code>FILENUM</code>打印不成对的行，其中<code>FILENUM</code>是<code>1</code>或<code>2</code>，对应于<code>FILE1</code>或<code>FILE2</code>。</li><li><code>-e EMPTY</code>: 将缺少的输入字段替换为空。</li><li><code>-i, --ignore-case</code>: 比较字段时忽略大小写的差异。</li><li><code>-j FIELD</code>: 相当于<code>-1 FIELD -2 FIELD</code>。</li><li><code>-o FORMAT</code>: 构造输出线时遵守<code>FORMAT</code>。</li><li><code>-t CHAR</code>: 使用<code>CHAR</code>作为输入和输出字段分隔符。</li><li><code>-v FILENUM</code>: 类似于<code>-a FILENUM</code>，但不连接输出行。</li><li><code>-1 FIELD</code>: 加入文件<code>1</code>的这个<code>FIELD</code>。</li><li><code>-2 FIELD</code>: 加入文件<code>2</code>的这个<code>FIELD</code>。</li><li><code>--check-order</code>: 检查输入是否正确排序，即使所有输入行都可以配对。</li><li><code>--nocheck-order</code>: 不要检查输入是否正确排序。</li><li><code>--header</code>: 将每个文件的第一行视为字段标题，无需尝试将它们配对即可打印它们。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><code>file1.txt</code>与<code>file2.txt</code>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># file1.txt</span><br><span class="line">1 AAYUSH</span><br><span class="line">2 APAAR</span><br><span class="line">3 HEMANT</span><br><span class="line">4 KARTIK</span><br><span class="line">5 TIM</span><br><span class="line"></span><br><span class="line"># file2.txt</span><br><span class="line">1 101</span><br><span class="line">2 102</span><br><span class="line">3 103</span><br><span class="line">4 104</span><br></pre></td></tr></table></figure><p>使用<code>join</code>命令合并文件，为了合并两个文件，文件必须具有一些公共字段，此时两个文件中的公共字段均带有编号<code>1、2...</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">join file1.txt file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 AAYUSH 101</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 APAAR 102</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 HEMANT 103</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 KARTIK 104</span></span><br></pre></td></tr></table></figure><p>使用<code>-a</code>选项打印<code>FILE1</code>中已成对的行并链接以及不成对的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">join file1.txt file2.txt -a 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 AAYUSH 101</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 APAAR 102</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 HEMANT 103</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 KARTIK 104</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5 TIM</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>-v</code>选项打印<code>FILE1</code>中不成对的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join file1.txt file2.txt -v 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5 TIM</span></span><br></pre></td></tr></table></figure><p><code>join</code>会在第一个公共字段上组合文件行，该字段是默认值。但是这两个文件中的公共值不一定总是第一个列，所以<code>join</code>可以使用<code>-1, -2</code>指定公共值位置。<code>-1</code>和<code>-2</code>表示第一个和第二个文件，这些选项需要一个数字参数，该参数引用相应文件的连接字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">`file1.txt`与`file2.txt`文件内容如下：</span><br><span class="line"># file1.txt</span><br><span class="line">AAYUSH 1 </span><br><span class="line">APAAR 2</span><br><span class="line">HEMANT 3</span><br><span class="line">KARTIK 4</span><br><span class="line">TIM 5</span><br><span class="line"></span><br><span class="line"># file2.txt</span><br><span class="line">101 1</span><br><span class="line">102 2</span><br><span class="line">103 3</span><br><span class="line">104 4</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">join -1 2 -2 2 file1.txt file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 AAYUSH  101</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 APAAR 102</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 HEMANT 103</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 KARTIK 104</span></span><br></pre></td></tr></table></figure><p>对于上面的示例，我们直接使用<code>-j</code>参数也可以实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">join -j 2 file1.txt file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 AAYUSH  101</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 APAAR 102</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3 HEMANT 103</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4 KARTIK 104</span></span><br></pre></td></tr></table></figure><h1 id="ip命令"><a href="#ip命令" class="headerlink" title="ip命令"></a>ip命令</h1><p><code>ip</code>命令与<code>ifconfig</code>命令类似，但比<code>ifconfig</code>命令更加强大，主要功能是用于显示或设置网络设备、路由和隧道的配置等，<code>ip</code>命令是<code>Linux</code>加强版的的网络配置工具，用于代替<code>ifconfig</code>命令。</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</span><br><span class="line">ip [ -force ] -batch filename</span><br><span class="line"></span><br><span class="line">OBJECT := &#123; link | addr | addrlabel | route | rule | neigh | ntable | tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm | netns &#125;</span><br><span class="line"></span><br><span class="line">OPTIONS := &#123; -V[ersion] | -s[tatistics] | -r[esolve] | -f[amily] &#123; inet | inet6 | ipx | dnet | link &#125; | -o[neline] &#125;</span><br></pre></td></tr></table></figure><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><ul><li><code>-b, -batch &lt;FILENAME&gt;</code>: 从提供的文件或标准输入读取命令并调用它们，第一次失败将导致<code>ip</code>执行终止。</li><li><code>-force</code>: 不要在批处理模式下因错误而终止<code>ip</code>，如果在执行命令期间发生任何错误，则应用程序返回码将为非零。</li><li><code>-s, -stats, -statistics</code>: 输出更多信息，如果该选项出现两次或更多次，则信息量会增加，通常，信息是统计信息或一些时间值。</li><li><code>-l, -loops &lt;COUNT&gt;</code>: 指定<code>ip addr flush</code>逻辑在放弃之前尝试的最大循环数，默认值为<code>10</code>，<code>0</code>表示循环直到删除所有地址。</li><li><code>-f, -family &lt;FAMILY&gt;</code>: 指定使用的协议族，协议族标识符可以是<code>inet</code>、<code>inet6</code>、<code>bridge</code>、<code>ipx</code>、<code>dnet</code>或<code>link</code>中的一个，如果该选项不存在，则根据其他参数猜测协议族，如果命令行的其余部分没有提供足够的信息来猜测家族，<code>ip</code>将退回到默认的<code>ip</code>设置，通常是<code>inet</code>或<code>any</code>，<code>link</code>是一种特殊的族标识符，不涉及任何网络协议。</li><li><code>-4</code>: <code>-family inet</code>的快捷方式。</li><li><code>-6</code>: <code>-family inet6</code>的快捷方式。</li><li><code>-B</code>: <code>-family bridge</code>的快捷方式。</li><li><code>-D</code>: <code>-family decnet</code>的快捷方式。</li><li><code>-I</code>: <code>-family ipx</code>的快捷方式。</li><li><code>-0</code>: <code>-family link</code>的快捷方式。</li><li><code>-o, -oneline</code>: 将每条记录输出为一行，用<code>\</code>字符替换换行符，当使用<code>wc</code>计数记录或<code>grep</code>输出时，这很方便。</li><li><code>-r, -resolve</code>: 使用系统的名称解析程序打印<code>DNS</code>名称而不是主机地址。</li><li><code>-V, -Version</code>: 输出版本信息。</li></ul><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><ul><li><code>address</code>: 设备上的协议地址，<code>IP</code>或<code>IPv6</code>。</li><li><code>addrlabel</code>: 用于协议地址选择的标签配置。</li><li><code>l2tp</code>: IP隧道以太网<code>L2TPv3</code>。</li><li><code>link</code>: 网络设备。</li><li><code>maddress</code>: 多播地址。</li><li><code>monitor</code>: 监视<code>netlink</code>消息。</li><li><code>mroute</code>: 多播路由缓存项。</li><li><code>mrule</code>: 多播路由策略数据库中的规则。</li><li><code>neighbour</code>: 管理<code>ARP</code>或<code>NDISC</code>缓存项。</li><li><code>netns</code>: 管理网络名称空间。</li><li><code>ntable</code>: 管理邻居缓存的操作。</li><li><code>route</code>: 路由表条目。</li><li><code>rule</code>: 路由策略数据库中的规则。</li><li><code>tcp_metrics/tcpmetrics</code>: 管理<code>TCP</code>指标。</li><li><code>tunnel</code>: <code>IP</code>隧道。</li><li><code>tuntap</code>: 管理<code>TUN/TAP</code>设备。</li><li><code>xfrm</code>: 管理<code>IPSec</code>策略。</li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>查看网络接口信息，例如<code>IP</code>地址，子网等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure><p>要查看<code>eth0</code>网卡信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0</span><br></pre></td></tr></table></figure><p>启用网络接口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link set eth0 up</span><br></pre></td></tr></table></figure><p>关闭网络接口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link set eth0 down</span><br></pre></td></tr></table></figure><p>查看路由和默认网关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure><p>获取到特定<code>ip</code>的路由信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route get to 192.168.111.111</span><br></pre></td></tr></table></figure><p>查看<code>arp</code>条目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip neigh</span><br></pre></td></tr></table></figure><p>查看网络统计。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -s link</span><br></pre></td></tr></table></figure><p>查看详细帮助信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ip</span><br></pre></td></tr></table></figure><h1 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h1><p><code>ifconfig</code>代表<code>interface configuration</code>，其用于查看和更改系统上网络接口的配置。</p><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [-a] [-v] [-s] &lt;interface&gt; [[&lt;AF&gt;] &lt;address&gt;]</span><br><span class="line">  [add &lt;address&gt;[/&lt;prefixlen&gt;]]</span><br><span class="line">  [del &lt;address&gt;[/&lt;prefixlen&gt;]]</span><br><span class="line">  [[-]broadcast [&lt;address&gt;]]  [[-]pointopoint [&lt;address&gt;]]</span><br><span class="line">  [netmask &lt;address&gt;]  [dstaddr &lt;address&gt;]  [tunnel &lt;address&gt;]</span><br><span class="line">  [outfill &lt;NN&gt;] [keepalive &lt;NN&gt;]</span><br><span class="line">  [hw &lt;HW&gt; &lt;address&gt;]  [mtu &lt;NN&gt;]</span><br><span class="line">  [[-]trailers]  [[-]arp]  [[-]allmulti]</span><br><span class="line">  [multicast]  [[-]promisc]</span><br><span class="line">  [mem_start &lt;NN&gt;]  [io_addr &lt;NN&gt;]  [irq &lt;NN&gt;]  [media &lt;type&gt;]</span><br><span class="line">  [txqueuelen &lt;NN&gt;]</span><br><span class="line">  [[-]dynamic]</span><br><span class="line">  [up|down] ...</span><br></pre></td></tr></table></figure><h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><ul><li><code>(none), -a</code>: 显示所有网络接口的信息，即使它们已关闭。</li><li><code>-s</code>: 以与命令<code>netstat -i</code>相同的格式显示简短列表。</li><li><code>-v</code>: 详细模式，显示某些错误情况的详细信息。</li><li><code>interface</code>: 接口名称，通常是驱动程序名称，后跟一个单元号，例如第一个以太网接口的<code>eth0</code>，如果内核支持别名接口，则可以为<code>eth0</code>的第一个别名使用<code>eth0:0</code>指定它们，可以使用它们来分配第二个地址，要删除别名接口，可以使用<code>ifconfig eth0：0 down</code>，注意如果删除第一个(主接口)，则对于每个范围即具有地址/网络掩码组合的同一网络，所有别名都将被删除。</li><li><code>up</code>: 该标志导致接口被激活，如果为接口分配了地址，则隐式指定。</li><li><code>down</code>: 该标志导致该接口的驱动程序被关闭。</li><li><code>[-]arp</code>: 在此接口上启用(指定了<code>-</code>前缀则禁用)<code>ARP</code>协议的使用。</li><li><code>[-]promisc</code>: 启用(指定了<code>-</code>前缀则禁用)接口的混杂模式，如果启用混杂模式，接口将接收网络上的所有数据包。</li><li><code>[-]allmulti</code>: 启用(指定了<code>-</code>前缀则禁用)全组播模式，启用组播模式后，该接口将接收网络上所有的组播报文。</li><li><code>metric N</code>: 此参数设置接口度量，接口使用该度量做出路由决策，<code>N</code>必须是介于<code>0</code>和<code>4294967295</code>之间的整数。</li><li><code>mtu N</code>: 该参数用于设置接口的最大传输单元，该设置用于限制接口传输的最大数据包大小。</li><li><code>dstaddr address</code>: 为点到点链路(如<code>PPP</code>)设置远程<code>IP</code>地址，此关键字现在已过时，请改用<code>pointopoint</code>关键字。</li><li><code>netmask address</code>: 设置接口的<code>IP</code>网络掩码，该值默认为通常的<code>A</code>、<code>B</code>或<code>C</code>类网络掩码(从接口<code>IP</code>地址派生)，但它可以设置为任何值。</li><li><code>add address/prefixlen</code>: 在接口上添加<code>IPv6</code>地址。</li><li><code>del address/prefixlen</code>: 从接口移除<code>IPv6</code>地址。</li><li><code>tunnel aa.bb.cc.dd</code>: 创建一个新的<code>SIT (IPv6-in-IPv4)</code>设备，通过隧道传送到给定的目的地。</li><li><code>irq address</code>: 设置此设备使用的中断线，并非所有设备都可以动态更改其<code>IRQ</code>设置。</li><li><code>io_addr address</code>: 在此设备的<code>I/O</code>空间中设置起始地址。</li><li><code>mem_start address</code>: 设置此设备使用的共享内存的起始地址，仅少数设备需要此功能。</li><li><code>media type</code>: 设置设备要使用的物理端口或介质类型，并非所有设备都可以更改此设置，并且某些设备可以更改其支持的值，类型的典型值是<code>10base2</code>(细缆网)、<code>10baseT</code>(双绞线<code>10 Mbps</code>以太网)、<code>AUI</code>外部收发器等，<code>auto</code>的特殊介质类型告诉驱动程序自动感知介质，同样并非所有驱动程序都可以执行此操作。</li><li><code>[-]broadcast [address]</code>: 如果指定了地址参数，则将为此接口设置协议广播地址，否则它将设置(指定了<code>-</code>前缀则清除)接口的<code>IFF_BROADCAST</code>标志。</li><li><code>[-]pointopoint [address]</code>: 这个关键字启用了接口的点对点模式，这意味着它是两台机器之间的直接链接，没有其他人监听它，如果还提供了<code>address</code>参数，请设置链接另一端的协议地址，就像过时的<code>dstaddr</code>关键字一样，否则，设置或清除接口的<code>IFF POINTOPOINT</code>标志。</li><li><code>hw class address</code>: 如果设备驱动程序支持此操作，则设置此接口的硬件地址，关键字之后必须是硬件类的名称以及与硬件地址等效的可打印<code>ASCII</code>。当前支持的硬件类别包括以太<code>ether (Ethernet)</code>、<code>ax25 (AMPR AX.25)</code>、<code>ARCnet and netrom (AMPR NET/ROM)</code>。</li><li><code>multicast</code>: 在接口上设置多播标志，由于驱动程序自己会正确设置该标志，因此通常不需要这样做。</li><li><code>address</code>: 分配给该接口的<code>IP</code>地址。</li><li><code>txqueuelen length</code>: 设置设备发送队列的长度，对于具有较高延迟的较慢设备(例如通过调制解调器或<code>ISDN</code>进行的连接)将其设置为较小的值非常有用，以防止快速的批量传输过多地干扰诸如<code>telnet</code>之类的交互式通信。</li></ul><h2 id="硬体类型"><a href="#硬体类型" class="headerlink" title="硬体类型 "></a>硬体类型 <HW></h2><p><code>loop (Local Loopback)</code>、<code>slip (Serial Line IP)</code>、<code>cslip (VJ Serial Line IP)</code>、<code>slip6 (6-bit Serial Line IP)</code>、<code>cslip6 (VJ 6-bit Serial Line IP)</code>、<code>adaptive (Adaptive Serial Line IP)</code>、<code>ash (Ash)</code>、<code>ether (Ethernet)</code>、<code>ax25 (AMPR AX.25)</code>、<code>netrom (AMPR NET/ROM)</code>、<code>rose (AMPR ROSE)</code>、<code>tunnel (IPIP Tunnel)</code>、<code>ppp (Point-to-Point Protocol)</code>、<code>hdlc ((Cisco)-HDLC)</code>、<code>lapb (LAPB)</code>、   <code>arcnet (ARCnet)</code>、<code>dlci (Frame Relay DLCI)</code>、<code>frad (Frame Relay Access Device)</code>、<code>sit (IPv6-in-IPv4)</code>、<code>fddi (Fiber Distributed Data Interface)</code>、<code>hippi (HIPPI)</code>、<code>irda (IrLAP)</code>、<code>ec (Econet)</code>、<code>x25 (generic X.25)</code>、<code>eui64 (Generic EUI-64)</code></p><h2 id="地址族"><a href="#地址族" class="headerlink" title="地址族 "></a>地址族 <AF></h2><p><code>unix (UNIX Domain)</code>、<code>inet (DARPA Internet)</code>、<code>inet6 (IPv6)</code>、<code>ax25 (AMPR AX.25)</code>、<code>netrom (AMPR NET/ROM)</code>、<code>rose (AMPR ROSE)</code>、<code>ipx (Novell IPX)</code>、<code>ddp (Appletalk DDP)</code>、<code>ec (Econet)</code>、<code>ash (Ash)</code>、<code>x25 (CCITT X.25)</code></p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>显示网络设备信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>启动关闭指定网卡。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>为网卡配置和删除<code>IPv6</code>地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 add 33ffe:3240:800:1005::2/ 64</span><br><span class="line">ifconfig eth0 del 33ffe:3240:800:1005::2/ 64</span><br></pre></td></tr></table></figure><p>修改<code>MAC</code>地址，需要首先关闭网卡并修改<code>MAC</code>地址，之后再开启网卡。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 hw ether 00:1D:1C:1D:1E</span><br><span class="line">ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>为网卡配置<code>IP</code>地址，并加上子掩码以及广播地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br></pre></td></tr></table></figure><p>启用和关闭<code>ARP</code>协议。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 arp</span><br><span class="line">ifconfig eth0 -arp</span><br></pre></td></tr></table></figure><p>设置最大传输单元<code>MTU</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 mtu 1500 </span><br></pre></td></tr></table></figure><h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><p> <code>grep</code>命令用于查找文件里符合条件的字符串，如果发现某文件的内容符合所指定的模式，<code>grep</code>命令会把含有模式的那一行显示出来。若不指定任何文件名称，或是所给予的文件名为<code>-</code>，则<code>grep</code>指令会从标准输入设备读取数据。</p><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [OPTION]... PATTERN [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-A NUM, --after-context=NUM</code>: 在匹配行之后打印尾部上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-a, --text</code>: 像处理文本一样处理二进制文件，这相当于<code>--binary files=text</code>选项。</li><li><code>-B NUM, --before-context=NUM</code>: 在匹配行之前打印前导上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-C NUM, --context=NUM</code>: 打印输出上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-b, --byte-offset</code>: 打印输入文件中每行输出之前的字节偏移量。</li><li><code>--binary-files=TYPE</code>: 如果文件的前几个字节指示该文件包含二进制数据，则假定该文件为类型类型。默认情况下，<code>TYPE</code>是<code>binary</code>，<code>grep</code>通常输出一行消息，说明二进制文件匹配，或者不输出消息(如果不匹配)。如果<code>TYPE</code>不匹配，<code>grep</code>假设二进制文件不匹配，这相当于<code>-I</code>选项。如果<code>TYPE</code>是<code>text</code>，<code>grep</code>会像处理文本一样处理二进制文件，这相当于<code>-a</code>选项。此外<code>grep--binary files=text</code>可能会输出二进制垃圾，如果输出是终端，并且终端驱动程序将其中的一些解释为命令，则会产生严重的副作用。</li><li><code>--colour[=WHEN], --color[=WHEN]</code>: 在匹配字符串周围加上标记<code>find in GREP_COLOR</code>环境变量，<code>WHEN</code>可以是<code>never</code>、<code>always</code>、<code>auto</code>。</li><li><code>-c, --count</code>: 禁止正常输出，而是为每个输入文件打印匹配行的计数，使用<code>-v，--invert match</code>选项，计算不匹配的行数。</li><li><code>-D ACTION, --devices=ACTION</code>: 如果输入文件是设备、<code>FIFO</code>或套接字，使用<code>ACTION</code>来处理它。默认情况下，<code>ACTION</code>是<code>read</code>，这意味着设备的读取就像它们是普通文件一样，如果<code>ACTION</code>为<code>skip</code>，则设备将自动跳过。</li><li><code>-d ACTION, --directories=ACTION</code>: 如果输入文件是目录，使用<code>ACTION</code>来处理它。默认情况下，<code>ACTION</code>是<code>read</code>，这意味着目录的读取就像它们是普通文件一样，如果<code>ACTION</code>是<code>skip</code>，则目录将被自动跳过，如果<code>ACTION</code>是递归的，<code>grep</code>将递归地读取每个目录下的所有文件，这相当于<code>-r</code>选项。</li><li><code>-E, --extended-regexp</code>: 将模式解释为扩展的正则表达式。</li><li><code>-e PATTERN, --regexp=PATTERN</code>: 使用<code>PATTERN</code>作为模式，用于保护以<code>-</code>开头的模式。</li><li><code>-F, --fixed-strings</code>: 将<code>PATTERN</code>解释为固定字符串的列表，用换行符分隔，这些字符串可以匹配。</li><li><code>-P, --perl-regexp</code>: 将<code>PATTERN</code>解释为<code>Perl</code>正则表达式。</li><li><code>-f FILE, --file=FILE</code>: 从<code>FILE</code>获取模式，每行一个，空文件包含零个模式，因此不匹配。</li><li><code>-G, --basic-regexp</code>: 将<code>PATTERN</code>解释为基本正则表达式，这是默认值。</li><li><code>-H, --with-filename</code>: 打印每个匹配项的文件名。</li><li><code>-h, --no-filename</code>: 当搜索多个文件时，禁止在输出中使用文件名前缀。</li><li><code>--help</code>: 显示帮助文件。</li><li><code>-I</code>: 处理二进制文件，就像它不包含匹配数据一样，这相当于<code>--binary-files=without-match</code>选项。</li><li><code>-i, --ignore-case</code>: 忽略<code>PATTERN</code>和输入文件中的大小写区别。</li><li><code>-L, --files-without-match</code>: 禁止正常输出，而是打印通常不会从中打印输出的每个输入文件的名称，扫描将在第一个匹配时停止。</li><li><code>-l, --files-with-matches</code>: 禁止正常输出，而是打印通常从中打印输出的每个输入文件的名称，扫描将在第一个匹配时停止。</li><li><code>-m NUM, --max-count=NUM</code>: 在匹配行数之后停止读取文件。如果输入是来自常规文件的标准输入，并且输出<code>NUM</code>个匹配行，<code>grep</code>确保标准输入在退出之前定位到最后一个匹配行之后，而不管是否存在后续上下文行。这使调用进程能够继续(恢复)搜索，当<code>grep</code>在NUM个匹配行之后停止时，它输出任何后面的上下文行。当<code>-c</code>或<code>--count</code>选项也被使用时，<code>grep</code>不会输出大于<code>NUM</code>的计数。当<code>-v</code>或<code>--invert match</code>选项也被使用时，<code>grep</code>会在输出<code>NUM</code>个不匹配的行之后停止。</li><li><code>--mmap</code>: 如果可能，使用<code>mmap</code>系统调用来读取输入，而不是默认的读取系统调用。在某些情况下，<code>--mmap</code>可以产生更好的性能。但是，如果在<code>grep</code>操作时输入文件收缩，或者发生<code>I/O</code>错误，那么<code>--mmap</code>可能会导致未定义的行为(包括核心转储)。</li><li><code>-n, --line-number</code>: 在输出的每一行前面加上输入文件中的行号。</li><li><code>-o, --only-matching</code>: 只显示匹配行中与模式匹配的部分。</li><li><code>--label=LABEL</code>: 将实际来自标准输入的输入显示为来自文件<code>LABEL</code>的输入。这对于<code>zgrep</code>之类的工具尤其有用，例如<code>gzip -cd foo.gz | grep -H --label = foo</code>。</li><li><code>--line-buffered</code>: 使用行缓冲，这可能会导致性能损失。</li><li><code>-q, --quiet, --silent</code>: 保持安静，不向标准输出写入任何内容。如果找到任何匹配项，即使检测到错误，也立即退出，状态为零。</li><li><code>-R, -r, --recursive</code>: 递归地读取每个目录下的所有文件，这相当于<code>-d recurse</code>选项。</li><li><code>-s, --no-messages</code>: 禁止显示有关不存在或不可读文件的错误消息。</li><li><code>-U, --binary</code>: 将文件视为二进制文件。默认情况下，在<code>MS-DOS</code>和<code>MS Windows</code>下，<code>grep</code>通过查看从文件中读取的第一个<code>32KB</code>的内容来猜测文件类型。如果<code>grep</code>确定文件是文本文件，它将从原始文件内容中删除<code>CR</code>字符(以使带有<code>^</code>和<code>$</code>的正则表达式正常工作)。指定<code>-U</code>会推翻这种猜测，导致读取所有文件并逐字传递给匹配机制，如果文件是一个文本文件，每行末尾都有<code>CR/LF</code>对，这将导致某些正则表达式失败。此选项对<code>MS-DOS</code>和<code>MS Windows</code>以外的平台无效。</li><li><code>-u, --unix-byte-offsets</code>: 报告<code>Unix</code>样式的字节偏移量，此开关使<code>grep</code>报告字节偏移，就好像该文件是<code>Unix</code>样式的文本文件一样，即去除了<code>CR</code>字符。这将产生与在<code>Unix</code>机器上运行<code>grep</code>相同的结果，除非也使用<code>-b</code>选项，否则该选项无效。它对除<code>MS-DOS</code>和<code>MS-Windows</code>以外的平台没有影响。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-v, --invert-match</code>: 反转匹配的意义，以选择不匹配的行。</li><li><code>-w, --word-regexp</code>: 只选择与表单中包含的单词匹配的行。测试是匹配的子串必须在行的开头，或者前面有非单词组成字符，同样，它必须位于行的末尾，或者后跟非单词组成字符。单词组成字符是字母、数字和下划线。</li><li><code>-x, --line-regexp</code>: 仅选择与整行完全匹配的那些匹配项。</li><li><code>-Z, --null</code>: 输出零字节(<code>ASCII NULL</code>字符)，而不是通常在文件名后的字符。例如<code>grep -lZ</code>在每个文件名之后输出一个零字节，而不是通常的换行符。即使存在包含不寻常字符(例如换行符)的文件名，此选项也可以使输出明确。此选项可与<code>find -print0</code>、<code>perl -0</code>、<code>sort -z</code>和<code>xargs -0</code>等命令一起使用，以处理任意文件名，即使是包含换行符的文件名。</li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p><code>hello.c</code>文件内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>行的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -c Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br></pre></td></tr></table></figure><p>反转匹配的意义，选择不匹配<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep -v Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># int main() &#123;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>i</code>的行并忽略大小写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep -i I hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">int <span class="function"><span class="title">main</span></span>() &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>仅输出与文件整行匹配的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -x &quot;   return 0;&quot; hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行并输出行号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -n Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>递归匹配当前目录下所有文件中能够匹配<code>h*</code>的文件，输出行号并忽略大小写，注意实际在终端中匹配成功的位置会使用红色字体标注。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep -rni &quot;h*&quot; ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:1:<span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:2:<span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:3:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:4:int <span class="function"><span class="title">main</span></span>() &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:5:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:6:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:7:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:8:   <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:9:&#125;</span></span><br></pre></td></tr></table></figure><h1 id="fold命令"><a href="#fold命令" class="headerlink" title="fold命令"></a>fold命令</h1><p><code>fold</code>命令用于限制文件列宽，其会从指定的文件里读取内容，将超过限定列宽的列加入增列字符后，输出到标准输出设备。若不指定任何文件名称，或是所给予的文件名为<code>-</code>，则<code>fold</code>命令会从标准输入设备读取数据。</p><h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fold [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --bytes</code>: 计算字节数而不是列数。</li><li><code>-s, --spaces</code>: 在空格处跳过。</li><li><code>-w, --width=WIDTH</code>: 使用<code>n</code>列，而不是默认值<code>80</code>。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>使用<code>fold</code>命令进行分隔，每行最多包含默认值<code>80</code>个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fold file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">fold</span> <span class="built_in">command</span> <span class="keyword">in</span> Linux wraps each line <span class="keyword">in</span> an input file to fit a specified width</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and prints it to the standard output. By default, it wraps lines at a maximum wi</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dth of 80 columns but this is configurable. To <span class="built_in">fold</span> input using the <span class="built_in">fold</span> <span class="built_in">command</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> pass a file or standard input to the <span class="built_in">command</span>.</span></span><br></pre></td></tr></table></figure><p>使用<code>fold</code>命令进行分隔，指定每行最多包含默认值<code>50</code>个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fold -w 50 file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">fold</span> <span class="built_in">command</span> <span class="keyword">in</span> Linux wraps each line <span class="keyword">in</span> an input</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file to fit a specified width and prints it to the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> standard output. By default, it wraps lines at a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maximum width of 80 columns but this is configurab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">le. To <span class="built_in">fold</span> input using the <span class="built_in">fold</span> <span class="built_in">command</span> pass a <span class="keyword">fi</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">le or standard input to the <span class="built_in">command</span>.</span></span><br></pre></td></tr></table></figure><p>使用<code>fold</code>命令进行分隔，并使用<code>-s</code>选项用于分隔空格上的行，以便不打断单词。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fold -w 50 -s file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">fold</span> <span class="built_in">command</span> <span class="keyword">in</span> Linux wraps each line <span class="keyword">in</span> an input</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file to fit a specified width and prints it to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the standard output. By default, it wraps lines</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">at a maximum width of 80 columns but this is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configurable. To <span class="built_in">fold</span> input using the <span class="built_in">fold</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> pass a file or standard input to the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span>.</span></span><br></pre></td></tr></table></figure><h1 id="fmt命令"><a href="#fmt命令" class="headerlink" title="fmt命令"></a>fmt命令</h1><p><code>fmt</code>命令用于编排文本文件，其会从指定的文件里读取内容，将其依照指定格式重新编排后，输出到标准输出设备，若指定的文件名为<code>-</code>，则<code>fmt</code>指令会从标准输入设备读取数据。</p><h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt [-WIDTH] [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-c, --crown-margin</code>: 保留前两行的缩进。</li><li><code>-p, --prefix=STRING</code>: 仅重新格式化以<code>STRING</code>开头的行，并将前缀重新附加到格式化后的行上。</li><li><code>-s, --split-only</code>: 拆分长行，但不再重新填充它们。</li><li><code>-t, --tagged-paragraph</code>: 第一行的缩进不同于第二行。</li><li><code>-u, --uniform-spacing</code>: 单词之间使用一个空格，句子后面使用两个空格。</li><li><code>-w, --width=WIDTH</code>: 最大行宽(默认为<code>75</code>列)。</li><li><code>-g, --goal=WIDTH</code>: 目标宽度(默认为宽度的<code>93％</code>)。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>默认情况下，<code>fmt</code>不使用任何选项，将给定文件中存在的所有单词格式化为一行，当然默认单行最大宽度<code>75</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">everyone.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Have</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">nice</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">day.</span></span><br><span class="line"></span><br><span class="line">fmt file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello everyone.  Have a <span class="built_in">nice</span> day.</span></span><br></pre></td></tr></table></figure><p>格式化文件，并使用<code>-w</code>选项指定文件行最大宽度，添加单词超出长度则将单词换行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">everyone.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Have</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">nice</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">day.</span></span><br><span class="line"></span><br><span class="line">fmt -w 10 file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hello</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">everyone.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Have a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">nice</span> day.</span></span><br></pre></td></tr></table></figure><p><code>-s</code>选项分割了很长的行，但是不重新填充它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br><span class="line"># Love is patient, love is kind. It does not envy, it does not boast, it is not proud. It is not rude, it is not self-seeking, it is not easily angered,  it keeps no record of wrongs. Love does not delight in evil but rejoices with the truth. It always protects, always trusts, always hopes, always perseveres. Love never fails.</span><br><span class="line"></span><br><span class="line">fmt -s file.txt</span><br><span class="line"># Love is patient, love is kind. It does not envy, it does not boast, it</span><br><span class="line"># is not proud. It is not rude, it is not self-seeking, it is not easily</span><br><span class="line"># angered,  it keeps no record of wrongs. Love does not delight in evil</span><br><span class="line"># but rejoices with the truth. It always protects, always trusts, always</span><br><span class="line"># hopes, always perseveres. Love never fails.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><p><code>find</code>命令用来在指定目录下查找文件，任何位于参数之前的字符串都将被视为要查找的目录名，如果使用该命令时，不设置任何参数，则<code>find</code>命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。</p><h2 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec|time] [path...] [expression]</span><br></pre></td></tr></table></figure><h2 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-amin&lt;minute&gt;</code>: 查找在指定时间曾被存取过的文件或目录，单位以分钟计算。</li><li><code>-anewer&lt;file or folder&gt;</code>: 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录。</li><li><code>-atime&lt;day&gt;</code>: 查找在指定时间曾被存取过的文件或目录，单位以天计算。</li><li><code>-cmin&lt;minute&gt;</code>: 查找在指定时间之时被更改过的文件或目录。</li><li><code>-cnewer&lt;file or folder&gt;</code>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。</li><li><code>-ctime&lt;day&gt;</code>: 查找在指定时间之时被更改的文件或目录，单位以天计算。</li><li><code>-daystart</code>: 从本日开始计算时间。</li><li><code>-depth</code>: 从指定目录下最深层的子目录开始查找。</li><li><code>-empty</code>: 寻找文件大小为<code>0 Byte</code>的文件，或目录下没有任何子目录或文件的空目录。</li><li><code>-exec&lt;command&gt;</code>: 假设<code>find</code>指令的回传值为<code>True</code>，就执行该指令。</li><li><code>-false</code>: 将<code>find</code>指令的回传值皆设为<code>False</code>。</li><li><code>-fls&lt;file list&gt;</code>: 此参数的效果和指定<code>-ls</code>参数类似，但会把结果保存为指定的列表文件。</li><li><code>-follow</code>: 排除符号连接。</li><li><code>-fprint&lt;file list&gt;</code>: 此参数的效果和指定<code>-print</code>参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fprint0&lt;file list&gt;</code>: 此参数的效果和指定<code>-print0</code>参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fprintf&lt;file list&gt;&lt;output format&gt;</code>: 此参数的效果和指定<code>-printf</code>参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fstype&lt;file system type&gt;</code>: 只寻找该文件系统类型下的文件或目录。</li><li><code>-gid&lt;group id&gt;</code>: 查找符合指定之群组识别码的文件或目录。</li><li><code>-group&lt;group name&gt;</code>: 查找符合指定之群组名称的文件或目录。</li><li><code>-help, --help</code>: 在线帮助。</li><li><code>-ilname&lt;template style&gt;</code>: 此参数的效果和指定<code>-lname</code>参数类似，但忽略字符大小写的差别。</li><li><code>-iname&lt;template style&gt;</code>: 此参数的效果和指定<code>-name</code>参数类似，但忽略字符大小写的差别。</li><li><code>-inum&lt;inode num&gt;</code>: 查找符合指定的inode编号的文件或目录。</li><li><code>-ipath&lt;template style&gt;</code>: 此参数的效果和指定<code>-path</code>参数类似，但忽略字符大小写的差别。</li><li><code>-iregex&lt;template style&gt;</code>: 此参数的效果和指定<code>-regexe</code>参数类似，但忽略字符大小写的差别。</li><li><code>-links&lt;number of connections&gt;</code>: 查找符合指定的硬连接数目的文件或目录。</li><li><code>-iname&lt;template style&gt;</code>: 指定字符串作为寻找符号连接的范本样式。</li><li><code>-ls</code>: 假设<code>find</code>指令的回传值为<code>Ture</code>，就将文件或目录名称列出到标准输出。</li><li><code>-maxdepth&lt;directory level&gt;</code>: 设置最大目录层级。</li><li><code>-mindepth&lt;directory level&gt;</code>: 设置最小目录层级。</li><li><code>-mmin&lt;minute&gt;</code>: 查找在指定时间曾被更改过的文件或目录，单位以分钟计算。</li><li><code>-mount</code>: 此参数的效果和指定<code>-xdev</code>相同。</li><li><code>-mtime&lt;24 hour&gt;</code>: 查找在指定时间曾被更改过的文件或目录，单位以<code>24</code>小时计算。</li><li><code>-name&lt;template style&gt;</code>: 指定字符串作为寻找文件或目录的范本样式。</li><li><code>-newer&lt;file or folder&gt;</code>: 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。</li><li><code>-nogroup</code>: 找出不属于本地主机群组识别码的文件或目录。</li><li><code>-noleaf</code>: 不去考虑目录至少需拥有两个硬连接存在。</li><li><code>-nouser</code>: 找出不属于本地主机用户识别码的文件或目录。</li><li><code>-ok&lt;command&gt;</code>: 此参数的效果和指定<code>-exec</code>类似，但在执行指令之前会先询问用户，若回答<code>y</code>或<code>Y</code>，则放弃执行命令。</li><li><code>-path&lt;template style&gt;</code>: 指定字符串作为寻找目录的范本样式。</li><li><code>-perm&lt;permission value&gt;</code>: 查找符合指定的权限数值的文件或目录。</li><li><code>-print</code>: 假设<code>find</code>指令的回传值为<code>Ture</code>，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有<code>./</code>字符串。</li><li><code>-print0</code>: 假设<code>find</code>指令的回传值为<code>Ture</code>，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行。</li><li><code>-printf&lt;output format&gt;</code>: 假设<code>find</code>指令的回传值为<code>Ture</code>，就将文件或目录名称列出到标准输出。格式可以自行指定。</li><li><code>-prune</code>: 不寻找字符串作为寻找文件或目录的范本样式;</li><li><code>-regex&lt;template style&gt;</code>: 指定字符串作为寻找文件或目录的范本样式。</li><li><code>-size&lt;file size&gt;</code>: 查找符合指定的文件大小的文件。</li><li><code>-true</code>: 将find指令的回传值皆设为<code>True</code>。</li><li><code>-type&lt;file type&gt;</code>: 只寻找符合指定的文件类型的文件。</li><li><code>-uid&lt;user id&gt;</code>: 查找符合指定的用户识别码的文件或目录。</li><li><code>-used&lt;day&gt;</code>: 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算。</li><li><code>-user&lt;owner name&gt;</code>: 查找符和指定的拥有者名称的文件或目录。</li><li><code>-version, --version</code>: 显示版本信息。</li><li><code>-xdev</code>: 将范围局限在先行的文件系统中。</li><li><code>-xtype&lt;file type&gt;</code>: 此参数的效果和指定<code>-type</code>参数类似，差别在于它针对符号连接检查。</li></ul><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>查找<code>/tmp/</code>目录及其子目录下所有拓展名为<code>py</code>的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/ -name *.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file.py</span></span><br></pre></td></tr></table></figure><p>查找<code>/tmp/</code>目录及其子目录下所有一般文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/ -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/a.out</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/www/1.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file.py</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>查找<code>/tmp/</code>目录及其子目录下所有最近<code>1</code>天内更改过的文件，<code>+1</code>则表示<code>1</code>天前更改过文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/ -ctime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/tmp/file</span></span><br></pre></td></tr></table></figure><p>查找<code>/tmp/</code>目录及其子目录下所有更改时间在<code>7</code>日以前的普通文件，并在删除之前询问是否删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/ -type f -mtime +7 -ok rm &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; <span class="built_in">rm</span> ... /tmp/file.py &gt; ? n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>查找<code>/tmp/</code>目录及其子目录下所有文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/  -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-rw-r--r-- 1 root root 60 Jul 22 19:55 /tmp/file.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-rw-r--r-- 1 www www 73 Jul 23 20:54 /tmp/file.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><p>查找<code>/tmp/</code>目录及其子目录下所有文件长度为<code>0</code>的普通文件，并列出它们的完整路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/ -type f -size 0 -exec ls -l &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-rwx------ 1 root root 0 Jul 11 17:25 /tmp/file.py</span></span><br></pre></td></tr></table></figure><h1 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h1><p><code>file</code>命令用来探测给定文件的类型，<code>file</code>命令对文件的检查分为文件系统、魔法文件和语言检查<code>3</code>个过程。</p><h2 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file [ -bchikLnNprsvz ] [ -f namefile ] [ -F separator ] [ -m magicfiles ] [file or folder] ...</span><br><span class="line">file -C [ -m magicfile ]</span><br></pre></td></tr></table></figure><h2 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --brief</code>: 简洁模式，列出辨识结果时，不显示文件名称。</li><li><code>-c, --checking-printout</code>: 详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li><code>-C, --compile</code>: 编译一个<code>magic.mgc</code>输出文件，其中包含文件的预解析版本。</li><li><code>-f, --files-from &lt;file&gt;</code>: 指定名称文件，其内容有一个或多个文件名称时，让<code>file</code>依序辨识这些文件，格式为每列一个文件名称。</li><li><code>-F, --separator separator</code>: 使用指定的字符串作为文件名和返回的文件结果之间的分隔符，默认为<code>:</code>。</li><li><code>-i, --mime</code>: 使文件命令输出<code>mime</code>类型。</li><li><code>-L</code>: 直接显示符号连接所指向的文件的类别。</li><li><code>-L, --dereference</code>: 跟随符号链接，如果设置了<code>POSIXLY_CORRECT</code>，则为默认值。</li><li><code>-m &lt;file&gt;</code>: 指定魔法文件，<code>magic file</code>规则就是根据文件的特殊内容去判断一个文件的类型，例如<code>tar</code>格式的标识信息，通常默认<code>magic file</code>文件存在于<code>/usr/share/file/</code>等目录下。</li><li><code>-n, --no-buffer</code>: 检查每个文件后强制刷新标准输出，仅在检查文件列表时才有用，该选项供希望从管道输出文件类型的程序使用。</li><li><code>-N, --no-pad</code>: 不要填充文件名，以使它们在输出中对齐。</li><li><code>-r, --raw</code>: 不将无法打印的字符翻译为<code>\ooo</code>，通常文件将不可打印的字符转换为八进制表示形式。</li><li><code>-v</code>: 显示版本信息。</li><li><code>-z</code>: 尝试去解读压缩文件的内容。</li><li><code>file or folder</code>: 要确定类型的文件列表，多个文件之间使用空格分开，可以使用<code>shell</code>通配符匹配多个文件。</li></ul><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>显示文件类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file.txt: ASCII text</span></span><br></pre></td></tr></table></figure><p>显示文件<code>MIME</code>类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file.txt: text/plain; charset=us-ascii</span></span><br></pre></td></tr></table></figure><p>简洁模式，不显示文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -b -i file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">text/plain; charset=us-ascii</span></span><br></pre></td></tr></table></figure><h1 id="fgrep命令"><a href="#fgrep命令" class="headerlink" title="fgrep命令"></a>fgrep命令</h1><p>当需要搜索包含很多正则表达式元字符的字符串时，例如<code>$</code>、<code>^</code>等，<code>fgrep</code>很有用，其通过指定搜索字符串包含固定字符，从而无需对每个字符进行转义用反斜杠，如果搜索的字符串包含换行符，则每行将被视为要在搜索中匹配的单个固定字符字符串。也就是说<code>fgrep</code>是用来搜索固定字符的，固定字符表示字符串是按字面意义解释的-元字符不存在，因此不能使用正则表达式，运行<code>fgrep</code>与使用<code>-F</code>选项运行<code>grep</code>效果相同。</p><h2 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgrep [-b] [-c] [-h] [-i] [-l] [-n] [-s] [-v] [-x] [ -e pattern_list] [-f pattern-file] [pattern] [file]</span><br></pre></td></tr></table></figure><h2 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b</code>: 在每一行前面加上找到该行所在的块号，这在根据上下文(第一个块为<code>0</code>)定位块号时非常有用。</li><li><code>-c</code>: 只打印包含模式的行数。</li><li><code>-h</code>: 搜索多个文件时禁止打印文件。</li><li><code>-i</code>: 在比较时忽略大小写的区别。</li><li><code>-l</code>: 打印一次具有匹配行的文件名称，用换行分隔，当模式出现多次时，不会重复文件名。</li><li><code>-n</code>: 在文件中，在每一行前面加上它的行号(第一行是<code>1</code>)。</li><li><code>-s</code>: 静默工作，也就是说只显示错误消息，这对于检查错误状态非常有用。</li><li><code>-v</code>: 打印除包含模式的行以外的所有行。</li><li><code>-x</code>: 仅打印完全匹配的行。</li><li><code>-e pattern_list</code>: 在<code>pattern list</code>中搜索字符串，当字符串以<code>-</code>开头时很有用。</li><li><code>-f pattern-file</code>: 从模式文件中获取模式列表。</li><li><code>pattern</code>: 指定在搜索输入期间使用的模式。</li><li><code>file</code>: 要搜索模式的文件的路径名，如果没有指定文件参数，将使用标准输入。</li></ul><h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p><code>hello.c</code>文件内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fgrep Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>行的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgrep -c Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br></pre></td></tr></table></figure><p>反转匹配的意义，选择不匹配<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fgrep -v Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># int main() &#123;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>i</code>的行并忽略大小写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fgrep -i I hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">int <span class="function"><span class="title">main</span></span>() &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>仅输出与文件整行匹配的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgrep -x &quot;   return 0;&quot; hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行并输出行号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fgrep -n Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>递归匹配当前目录下所有文件中能够匹配<code>h*</code>的文件，请注意由于使用<code>fgrep</code>，命令是不会匹配<code>*</code>的模式，而是将其作为固定字符<code>*</code>去匹配，所以此时是没有匹配的，如果使用<code>grep</code>以及相同的参数，则能够输出行号并忽略大小写，注意实际在终端中匹配成功的位置会使用红色字体标注。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgrep -rni &quot;h*&quot; ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[输出为空]</span></span><br></pre></td></tr></table></figure><h1 id="ex命令"><a href="#ex命令" class="headerlink" title="ex命令"></a>ex命令</h1><p><code>ex</code>命令用于在<code>Ex</code>模式下启动<code>vim</code>文本编辑器，<code>ex</code>执行效果如同<code>vi -e</code>，如要从<code>Ex</code>模式回到普通模式，则在<code>vim</code>中输入<code>:vi</code>或<code>:visual</code>指令即可，可以通过运行<code>vi -e</code>来启动<code>ex</code>，也可以通过运行<code>ex -v</code>来启动<code>vi</code>，<code>ex</code>是<code>vim</code>的基础，<code>vim</code>是世界上最受欢迎的文本编辑器之一。<code>ex</code>并不是另一个编辑器，应该说<code>vi</code>是更一般更基本的<code>ex</code>行编辑器的可视模式，所以<code>ex</code>算是<code>vi</code>的底层行编辑器。由于一些<code>ex</code>命令可以节省大量的编辑时间，因此在使用<code>vi</code>时它们是非常有用的，这些命令的大部分都可以在不离开<code>vi</code>的情况下使用。</p><h2 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ex [ -| -s ] [ -l ] [ -L ] [ -R ] [ -r [ file ] ] [ -t tag ] [ -v ] [ -V ] </span><br><span class="line">   [ -x ] [ -wn ] [ -C ] [ +command | -c command ] file</span><br></pre></td></tr></table></figure><h2 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--</code>: 此后仅文件名。</li><li><code>-v</code>: 在<code>vi</code>模式下启动<code>vim</code>。</li><li><code>-e</code>: 在<code>ex</code>模式下启动<code>vim</code>。</li><li><code>-E</code>: 以改进的<code>ex</code>模式启动<code>vim</code>。</li><li><code>-s</code>: 沉默模式，仅当以<code>Ex</code>开头或在<code>-s</code>选项之前给出<code>-e</code>选项时生效。</li><li><code>-d</code>: 以<code>diff</code>模式启动，应该有两个或三个文件名参数，<code>vim</code>将打开所有文件并显示它们之间的差异，像<code>vimdiff</code>一样工作。</li><li><code>-y</code>: 以简单模式启动<code>vim</code>，类似于<code>evim</code>或<code>eview</code>，使<code>vim</code>的行为像单击并键入编辑器。</li><li><code>-R</code>: 只读模式，将设置<code>readonly</code>选项，此时仍然可以编辑缓冲区，但将防止意外覆盖文件。如果仍要覆盖文件，请在<code>Ex</code>命令中使用<code>w!</code>。</li><li><code>-Z</code>: 限制模式，类似于<code>rvim</code>。</li><li><code>-m</code>: 禁止修改文件，重置写入选项，此时仍然可以修改缓冲区，但不可写入文件。</li><li><code>-M</code>: 不允许修改，可修改和写入选项将被取消设置，因此不允许进行更改并且无法写入文件。请注意，可以设置这些选项以进行修改。</li><li><code>-b</code>: 二进制模式，将设置一些选项，以便可以编辑二进制文件或可执行文件。</li><li><code>-l</code>: <code>Lisp</code>模式，将<code>lisp</code>和<code>showmatch</code>选项设置为开。</li><li><code>-C</code>: 兼容的，设置<code>兼容</code>选项，这将使<code>vim</code>的行为与<code>vi</code>类似，即使存在<code>.vimrc</code>文件。</li><li><code>-N</code>: 不兼容模式，重置兼容选项，即使<code>.vimrc</code>文件不存在，这也会使<code>vim</code>表现得更好，但与<code>vi</code>的兼容性较差。</li><li><code>-V[N][fname]</code>: 详细信息，提供有关哪些文件来源以及用于读取和写入<code>viminfo</code>文件的消息，可选数字<code>N</code>是详细的值，默认值是<code>10</code>。</li><li><code>-D</code>: 调试模式，从脚本执行第一个命令时转到调试模式。</li><li><code>-n</code>: 不会使用交换文件，这样崩溃后的恢复将是不可能的。如果要在非常慢的介质例如软盘上编辑文件，此功能非常方便。</li><li><code>-r</code>: 列出交换文件，以及有关使用它们进行恢复的信息。</li><li><code>-r &lt;file name&gt;</code>: 恢复模式，交换文件用于恢复崩溃的编辑会话，交换文件与附加<code>.swp</code>的文本文件具有相同的文件名。</li><li><code>-L</code>: 与<code>-r</code>相同。</li><li><code>-A</code>: 如果<code>vim</code>是在阿拉伯语支持下编译的，用于编辑从右向左的文件和阿拉伯语键盘映射，则此选项将以阿拉伯语模式启动<code>vim</code>，即设置<code>ARABIC</code>，否则将发出错误消息，<code>vim</code>将中止。</li><li><code>-H</code>: 以希伯来语模式启动。</li><li><code>-F</code>: 以波斯语模式开始。</li><li><code>-T &lt;terminal&gt;</code>: 告诉<code>vim</code>正在使用的终端的名称，仅在自动方式无效时才需要，应该是<code>vim</code>内置已知的终端，或在<code>termcap</code>或<code>terminfo</code>文件中定义的终端。</li><li><code>--not-a-term</code>: 输入或输出不是终端时跳过警告。</li><li><code>-u &lt;vimrc&gt;</code>: 使用文件<code>.vimrc</code>中的命令进行初始化，将跳过所有其他初始化。使用此选项可编辑特殊类型的文件，也可以用来跳过所有的初始化，方法是给名称<code>NONE</code>。 initialization”。</li><li><code>--noplugin</code>: 跳过加载插件，由<code>-u</code>表示无。</li><li><code>-p[N]</code>: 打开<code>N</code>个标签页，如果省略<code>N</code>，则为每个文件打开一个标签页。</li><li><code>-o[N]</code>: 打开堆叠的<code>N</code>个窗口，当省略<code>N</code>时，为每个文件打开一个窗口。</li><li><code>-O[N]</code>: 并排打开<code>N</code>个窗口，如果省略<code>N</code>，则为每个文件打开一个窗口。</li><li><code>+</code>: 从文件末尾开始。</li><li><code>+&lt;lnum&gt;</code>: 对于第一个文件，光标将定位在<code>num</code>行上。如果缺少<code>num</code>，则光标将位于最后一行。</li><li><code>--cmd &lt;command&gt;</code>: 在加载任何<code>.vimrc</code>文件之前执行<code>&lt;command&gt;</code>。</li><li><code>-c &lt;command&gt;</code>: 加载第一个文件后执行<code>&lt;command&gt;</code>。</li><li><code>-S &lt;session&gt;</code>: 加载第一个文件后源文件的<code>&lt;session&gt;</code>。</li><li><code>-s &lt;scriptin&gt;</code>: 从文件<code>&lt;scriptin&gt;</code>中读取普通模式命令。</li><li><code>-w &lt;scriptout&gt;</code>: 将所有键入的命令附加到文件<code>&lt;scriptout&gt;</code>。</li><li><code>-W &lt;scriptout&gt;</code>: 将所有键入的命令写入文件<code>&lt;scriptout&gt;</code>。</li><li><code>-x</code>: 编辑加密文件。</li><li><code>--startuptime &lt;file&gt;</code>: 将启动定时消息写入<code>&lt;file&gt;</code>。</li><li><code>-i &lt;viminfo&gt;</code>: 使用<code>&lt;viminfo&gt;</code>而不是<code>.viminfo</code>。</li><li><code>-h  or  --help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>对<code>file.txt</code>启动<code>ex</code>编辑模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex file.txt</span><br></pre></td></tr></table></figure><p>显示总行数、当前行号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">= | .=</span><br></pre></td></tr></table></figure><p>打印文件前<code>3</code>行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,3 p</span><br></pre></td></tr></table></figure><p>删除第<code>1</code>到第<code>2</code>行，切换回<code>vi</code>模式查看效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2 d</span><br><span class="line">vi</span><br></pre></td></tr></table></figure><p>移动第<code>1</code>、<code>2</code>行到第<code>3</code>行下边。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2 m 3</span><br><span class="line">vi</span><br></pre></td></tr></table></figure><p>复制第<code>1</code>、<code>2</code>行到第<code>3</code>行下边。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1,2 co 3</span><br><span class="line">vi</span><br></pre></td></tr></table></figure><h1 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h1><p><code>expr</code>命令计算给定表达式并显示其相应的输出，其被使用用于：基本操作像加法、减法、乘法、除法和模等等整数，求值正则表达式，字符串操作，如子字符串，字符串长度等。</p><h2 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr [EXPRESSION | OPTION]</span><br></pre></td></tr></table></figure><h2 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h2><ul><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>:  输出版本信息。</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul><li><code>ARG1 | ARG2</code>: <code>ARG1</code>，如果它既不为<code>null</code>也不为<code>0</code>，否则为<code>ARG2</code>。</li><li><code>ARG1 &amp; ARG2</code>: 如果两个参数都不为<code>null</code>或<code>0</code>，则为<code>ARG1</code>，否则为<code>0</code>。</li><li><code>ARG1 &lt; ARG2</code>: <code>ARG1</code>小于<code>ARG2</code>。</li><li><code>ARG1 &lt;= ARG2</code>: <code>ARG1</code>小于等于<code>ARG2</code>。</li><li><code>ARG1 = ARG2</code>: <code>ARG1</code>等于<code>ARG2</code>。</li><li><code>ARG1 != ARG2</code>: <code>ARG1</code>与<code>ARG2</code>不相等。</li><li><code>ARG1 &gt;= ARG2</code>: <code>ARG1</code>大于或等于<code>ARG2</code>。</li><li><code>ARG1 &gt; ARG2</code>: <code>ARG1</code>大于<code>ARG2</code>。</li><li><code>ARG1 + ARG2</code>: <code>ARG1</code>和<code>ARG2</code>的算术和。</li><li><code>ARG1 - ARG2</code>: <code>ARG1</code>和<code>ARG2</code>的算术差。</li><li><code>ARG1 * ARG2</code>: <code>ARG1</code>和<code>ARG2</code>的算术乘积。</li><li><code>ARG1 / ARG2</code>: <code>ARG1</code>除以<code>ARG2</code>的算术商。</li><li><code>ARG1 % ARG2</code>: <code>ARG1</code>除以<code>ARG2</code>的算术余数。</li><li><code>STRING : REGEXP</code>: 正则表达式<code>REGEXP</code>在<code>STRING</code>中的定位模式匹配。</li><li><code>match STRING REGEXP</code>: 与<code>STRING</code>相同<code>REGEXP</code>。</li><li><code>substr STRING POS LENGTH</code>: <code>STR</code>的子字符串，<code>POS</code>从<code>1</code>开始计数。</li><li><code>index STRING CHARS</code>: 找到任何<code>CHARS</code>的<code>STRING</code>中的索引，或者为<code>0</code>。</li><li><code>length STRING</code>: 字符串长度。</li><li><code>+ TOKEN</code>: 将<code>TOKEN</code>解释为字符串，即使它是像<code>match</code>这样的关键字或像<code>/</code>这样的操作符。</li><li><code>( EXPRESSION )</code>: <code>EXPRESSION</code>的值。</li></ul><h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>计算<code>12 + 9</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 12 + 9</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">21</span></span><br></pre></td></tr></table></figure><p>计算<code>12 * 2</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 12 \* 2</span><br><span class="line"># 24</span><br></pre></td></tr></table></figure><p>对<code>shell</code>脚本中的变量执行操作，注意保存成<code>.sh</code>文件并赋权限<code>755</code>再执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Enter two numbers&quot;</span><br><span class="line">read x </span><br><span class="line">read y</span><br><span class="line">sum=`expr $x + $y`</span><br><span class="line">echo &quot;Sum = $sum&quot;</span><br></pre></td></tr></table></figure><h1 id="egrep命令"><a href="#egrep命令" class="headerlink" title="egrep命令"></a>egrep命令</h1><p><code>egrep</code>命令用于模式搜索，属于<code>grep</code>函数族，工作原理和<code>grep -E</code>一样，其将模式视为扩展正则表达式，并打印出与模式匹配的行，如果有多个文件具有匹配的模式，其还能显示每行的文件名。</p><h2 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep [options] PATTERN [FILE...]</span><br></pre></td></tr></table></figure><h2 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-A NUM, --after-context=NUM</code>: 在匹配行之后打印尾部上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-a, --text</code>: 像处理文本一样处理二进制文件，这相当于<code>--binary files=text</code>选项。</li><li><code>-B NUM, --before-context=NUM</code>: 在匹配行之前打印前导上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-C NUM, --context=NUM</code>: 打印输出上下文的<code>NUM</code>行，在相邻的匹配组之间放置包含<code>--</code>的行。</li><li><code>-b, --byte-offset</code>: 打印输入文件中每行输出之前的字节偏移量。</li><li><code>--binary-files=TYPE</code>: 如果文件的前几个字节指示该文件包含二进制数据，则假定该文件为类型类型。默认情况下，<code>TYPE</code>是<code>binary</code>，<code>grep</code>通常输出一行消息，说明二进制文件匹配，或者不输出消息(如果不匹配)。如果<code>TYPE</code>不匹配，<code>grep</code>假设二进制文件不匹配，这相当于<code>-I</code>选项。如果<code>TYPE</code>是<code>text</code>，<code>grep</code>会像处理文本一样处理二进制文件，这相当于<code>-a</code>选项。此外<code>grep--binary files=text</code>可能会输出二进制垃圾，如果输出是终端，并且终端驱动程序将其中的一些解释为命令，则会产生严重的副作用。</li><li><code>--colour[=WHEN], --color[=WHEN]</code>: 在匹配字符串周围加上标记<code>find in GREP_COLOR</code>环境变量，<code>WHEN</code>可以是<code>never</code>、<code>always</code>、<code>auto</code>。</li><li><code>-c, --count</code>: 禁止正常输出，而是为每个输入文件打印匹配行的计数，使用<code>-v，--invert match</code>选项，计算不匹配的行数。</li><li><code>-D ACTION, --devices=ACTION</code>: 如果输入文件是设备、<code>FIFO</code>或套接字，使用<code>ACTION</code>来处理它。默认情况下，<code>ACTION</code>是<code>read</code>，这意味着设备的读取就像它们是普通文件一样，如果<code>ACTION</code>为<code>skip</code>，则设备将自动跳过。</li><li><code>-d ACTION, --directories=ACTION</code>: 如果输入文件是目录，使用<code>ACTION</code>来处理它。默认情况下，<code>ACTION</code>是<code>read</code>，这意味着目录的读取就像它们是普通文件一样，如果<code>ACTION</code>是<code>skip</code>，则目录将被自动跳过，如果<code>ACTION</code>是递归的，<code>grep</code>将递归地读取每个目录下的所有文件，这相当于<code>-r</code>选项。</li><li><code>-e PATTERN, --regexp=PATTERN</code>: 使用<code>PATTERN</code>作为模式，用于保护以<code>-</code>开头的模式。</li><li><code>-F, --fixed-strings</code>: 将<code>PATTERN</code>解释为固定字符串的列表，用换行符分隔，这些字符串可以匹配。</li><li><code>-P, --perl-regexp</code>: 将<code>PATTERN</code>解释为<code>Perl</code>正则表达式。</li><li><code>-f FILE, --file=FILE</code>: 从<code>FILE</code>获取模式，每行一个，空文件包含零个模式，因此不匹配。</li><li><code>-G, --basic-regexp</code>: 将<code>PATTERN</code>解释为基本正则表达式，这是默认值。</li><li><code>-H, --with-filename</code>: 打印每个匹配项的文件名。</li><li><code>-h, --no-filename</code>: 当搜索多个文件时，禁止在输出中使用文件名前缀。</li><li><code>--help</code>: 显示帮助文件。</li><li><code>-I</code>: 处理二进制文件，就像它不包含匹配数据一样，这相当于<code>--binary-files=without-match</code>选项。</li><li><code>-i, --ignore-case</code>: 忽略<code>PATTERN</code>和输入文件中的大小写区别。</li><li><code>-L, --files-without-match</code>: 禁止正常输出，而是打印通常不会从中打印输出的每个输入文件的名称，扫描将在第一个匹配时停止。</li><li><code>-l, --files-with-matches</code>: 禁止正常输出，而是打印通常从中打印输出的每个输入文件的名称，扫描将在第一个匹配时停止。</li><li><code>-m NUM, --max-count=NUM</code>: 在匹配行数之后停止读取文件。如果输入是来自常规文件的标准输入，并且输出<code>NUM</code>个匹配行，<code>grep</code>确保标准输入在退出之前定位到最后一个匹配行之后，而不管是否存在后续上下文行。这使调用进程能够继续(恢复)搜索，当<code>grep</code>在NUM个匹配行之后停止时，它输出任何后面的上下文行。当<code>-c</code>或<code>--count</code>选项也被使用时，<code>grep</code>不会输出大于<code>NUM</code>的计数。当<code>-v</code>或<code>--invert match</code>选项也被使用时，<code>grep</code>会在输出<code>NUM</code>个不匹配的行之后停止。</li><li><code>--mmap</code>: 如果可能，使用<code>mmap</code>系统调用来读取输入，而不是默认的读取系统调用。在某些情况下，<code>--mmap</code>可以产生更好的性能。但是，如果在<code>grep</code>操作时输入文件收缩，或者发生<code>I/O</code>错误，那么<code>--mmap</code>可能会导致未定义的行为(包括核心转储)。</li><li><code>-n, --line-number</code>: 在输出的每一行前面加上输入文件中的行号。</li><li><code>-o, --only-matching</code>: 只显示匹配行中与模式匹配的部分。</li><li><code>--label=LABEL</code>: 将实际来自标准输入的输入显示为来自文件<code>LABEL</code>的输入。这对于<code>zgrep</code>之类的工具尤其有用，例如<code>gzip -cd foo.gz | grep -H --label = foo</code>。</li><li><code>--line-buffered</code>: 使用行缓冲，这可能会导致性能损失。</li><li><code>-q, --quiet, --silent</code>: 保持安静，不向标准输出写入任何内容。如果找到任何匹配项，即使检测到错误，也立即退出，状态为零。</li><li><code>-R, -r, --recursive</code>: 递归地读取每个目录下的所有文件，这相当于<code>-d recurse</code>选项。</li><li><code>-s, --no-messages</code>: 禁止显示有关不存在或不可读文件的错误消息。</li><li><code>-U, --binary</code>: 将文件视为二进制文件。默认情况下，在<code>MS-DOS</code>和<code>MS Windows</code>下，<code>grep</code>通过查看从文件中读取的第一个<code>32KB</code>的内容来猜测文件类型。如果<code>grep</code>确定文件是文本文件，它将从原始文件内容中删除<code>CR</code>字符(以使带有<code>^</code>和<code>$</code>的正则表达式正常工作)。指定<code>-U</code>会推翻这种猜测，导致读取所有文件并逐字传递给匹配机制，如果文件是一个文本文件，每行末尾都有<code>CR/LF</code>对，这将导致某些正则表达式失败。此选项对<code>MS-DOS</code>和<code>MS Windows</code>以外的平台无效。</li><li><code>-u, --unix-byte-offsets</code>: 报告<code>Unix</code>样式的字节偏移量，此开关使<code>grep</code>报告字节偏移，就好像该文件是<code>Unix</code>样式的文本文件一样，即去除了<code>CR</code>字符。这将产生与在<code>Unix</code>机器上运行<code>grep</code>相同的结果，除非也使用<code>-b</code>选项，否则该选项无效。它对除<code>MS-DOS</code>和<code>MS-Windows</code>以外的平台没有影响。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-v, --invert-match</code>: 反转匹配的意义，以选择不匹配的行。</li><li><code>-w, --word-regexp</code>: 只选择与表单中包含的单词匹配的行。测试是匹配的子串必须在行的开头，或者前面有非单词组成字符，同样，它必须位于行的末尾，或者后跟非单词组成字符。单词组成字符是字母、数字和下划线。</li><li><code>-x, --line-regexp</code>: 仅选择与整行完全匹配的那些匹配项。</li><li><code>-Z, --null</code>: 输出零字节(<code>ASCII NULL</code>字符)，而不是通常在文件名后的字符。例如<code>grep -lZ</code>在每个文件名之后输出一个零字节，而不是通常的换行符。即使存在包含不寻常字符(例如换行符)的文件名，此选项也可以使输出明确。此选项可与<code>find -print0</code>、<code>perl -0</code>、<code>sort -z</code>和<code>xargs -0</code>等命令一起使用，以处理任意文件名，即使是包含换行符的文件名。</li></ul><h2 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h2><p><code>hello.c</code>文件内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">egrep Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>行的数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep -c Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br></pre></td></tr></table></figure><p>反转匹配的意义，选择不匹配<code>Hello</code>的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">egrep -v Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># int main() &#123;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#125;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>i</code>的行并忽略大小写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">egrep -i I hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">int <span class="function"><span class="title">main</span></span>() &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>仅输出与文件整行匹配的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep -x &quot;   return 0;&quot; hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   <span class="built_in">return</span> 0;</span></span><br></pre></td></tr></table></figure><p>匹配带有<code>Hello</code>的行并输出行号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">egrep -n Hello hello.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br></pre></td></tr></table></figure><p>递归匹配当前目录下所有文件中能够匹配<code>h*</code>的文件，输出行号并忽略大小写，注意实际在终端中匹配成功的位置会使用红色字体标注。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">egrep -rni &quot;h*&quot; ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:1:<span class="comment">#include &lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:2:<span class="comment">#include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:3:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:4:int <span class="function"><span class="title">main</span></span>() &#123;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:5:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:6:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:7:   <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:8:   <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./hello.c:9:&#125;</span></span><br></pre></td></tr></table></figure><h1 id="ed命令"><a href="#ed命令" class="headerlink" title="ed命令"></a>ed命令</h1><p><code>ed</code>命令是文本编辑器，用于文本编辑，<code>ed</code>是<code>Linux</code>中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。<code>ed</code>命令并不是一个常用的命令，一般使用比较多的是<code>vi</code>指令，但<code>ed</code>文本编辑器对于编辑大文件或对于在<code>shell</code>脚本程序中进行文本编辑很有用。如果使用文件名参数调用<code>ed</code>，则文件的副本将被读入编辑器的缓冲区，对该副本进行更改，而不是直接对文件本身进行更改。退出<code>ed</code>后，任何未使用<code>w</code>命令显式保存的更改都将丢失。编辑有两种不同的模式：命令和输入。第一次调用时，<code>ed</code>处于命令模式，在这种模式下，命令从标准输入中读取并执行以操作编辑器缓冲区的内容。</p><h2 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ed [options] [file]</span><br></pre></td></tr></table></figure><h2 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-G, --traditional</code>: 在兼容模式下运行。</li><li><code>-l, --loose-exit-status</code>: 即使命令失败，也以零状态退出(正常终止)。例如如果将<code>ed</code>设置为<code>crontab</code>的编辑器，则此选项很有用。</li><li><code>-p, --prompt=STRING</code>: <code>ed</code>通常在空白行等待用户输入，此选项将使用字符串作为提示。</li><li><code>-r, --restricted</code>: 在受限模式下运行。</li><li><code>-s, --quiet, --silent</code>: 禁止诊断。</li><li><code>-v, --verbose</code>: 详细操作。</li><li><code>-h, --help</code>: 显示帮助信息。</li><li><code>-V, --version</code>: 显示版本信息。</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul><li><code>0</code>表示正常退出。</li><li><code>1</code>表示环境问题，例如文件未找到、无效标志、<code>I/O</code>错误等等。</li><li><code>2</code>表示损坏或无效的输入文件。</li><li><code>3</code>表示内部一致性错误(如软件<code>bug</code>)，导致<code>ed</code>死机。</li></ul><h2 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h2><p>比较完整的编辑示例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ed</span><br><span class="line">a</span><br><span class="line">My name is Titan.</span><br><span class="line">And I love Perl very much.</span><br><span class="line">.</span><br><span class="line">i</span><br><span class="line">I am 24.</span><br><span class="line">.</span><br><span class="line">c</span><br><span class="line">I am 24 years old. </span><br><span class="line">.</span><br><span class="line">w readme.txt</span><br><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ed                          # 激活 ed 命令 </span><br><span class="line">a                           # 告诉 ed 我要编辑新文件 </span><br><span class="line">My name is Titan.           # 输入第一行内容 </span><br><span class="line">And I love Perl very much.  # 输入第二行内容 </span><br><span class="line">.                           # 返回 ed 的命令行状态 </span><br><span class="line">i                           # 告诉 ed 我要在最后一行之前插入内容 </span><br><span class="line">I am 24.                    # 将 I am 24. 插入 My name is Titan. 和 And I love Perl very much. 之间 </span><br><span class="line">.                           # 返回 ed 的命令行状态 </span><br><span class="line">c                           # 告诉 ed 我要替换最后一行输入内容 </span><br><span class="line">I am 24 years old.          # 将 I am 24. 替换成 I am 24 years old. ，这里替换的是最后输的内容</span><br><span class="line">.                           # 返回 ed 的命令行状态 </span><br><span class="line">w readme.txt                # 将文件命名为 readme.txt 并保存，如果是编辑已经存在的文件，只需要敲入 w 即可</span><br><span class="line">q                           # 完全退出 ed 编辑器 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat readme.txt</span><br><span class="line"># My name is Titan.</span><br><span class="line"># I am 24 years old. </span><br><span class="line"># And I love Perl very much.</span><br></pre></td></tr></table></figure><h1 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h1><p><code>diff</code>命令能够比较给定的两个文件的不同，如果使用<code>-</code>代替文件参数，则要比较的内容将来自标准输入，<code>diff</code>命令是以逐行的方式比较文本文件的异同处，如果该命令指定进行目录的比较，则将会比较该目录中具有相同文件名的文件，而不会对其子目录文件进行任何比较操作。</p><h2 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [-abBcdefHilnNpPqrstTuvwy][-&lt;line&gt;][-C &lt;line&gt;][-D &lt;macro&gt;][-I &lt;string&gt;][-S &lt;file&gt;][-W &lt;width&gt;][-x &lt;file or folder&gt;][-X &lt;file&gt;][--help][--left-column][--suppress-common-line][file or folder][file or folder]</span><br></pre></td></tr></table></figure><h2 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a</code>或<code>--text</code>: <code>diff</code>预设只会逐行比较文本文件。</li><li><code>-b</code>或<code>--ignore-space-change</code>: 不检查空格字符的不同。</li><li><code>-B</code>或<code>--ignore-blank-lines</code>: 不检查空白行。</li><li><code>-c</code>: 显示全部内容，并标出不同之处。</li><li><code>-C &lt;line&gt;</code>或<code>--context &lt;line&gt;</code>: 与执行<code>-c-&lt;line&gt;</code>指令相同。</li><li><code>-d</code>或<code>--minimal</code>: 使用不同的演算法，以小的单位来做比较。</li><li><code>-D &lt;macro&gt;</code>或<code>ifdef &lt;macro&gt;</code>: 此参数的输出格式可用于前置处理器巨集。</li><li><code>-e</code>或<code>--ed</code>: 此参数的输出格式可用于<code>ed</code>的<code>script</code>文件。</li><li><code>-f</code>或<code>-forward-ed</code>: 输出的格式类似<code>ed</code>的<code>script</code>文件，但按照原来文件的顺序来显示不同处。</li><li><code>-H</code>或<code>--speed-large-files</code>: 比较大文件时，可加快速度。</li><li><code>-l&lt;string&gt;</code>或<code>--ignore-matching-lines&lt;string&gt;</code>: 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li><li><code>-i</code>或<code>--ignore-case</code>: 不检查大小写的不同。</li><li><code>-l</code>或<code>--paginate</code>: 将结果交由<code>pr</code>程序来分页。</li><li><code>-n</code>或<code>--rcs</code>: 将比较结果以<code>RCS</code>的格式来显示。</li><li><code>-N</code>或<code>--new-file</code>: 在比较目录时，若文件<code>A</code>仅出现在某个目录中，预设会显示<code>Only in &lt;folder&gt;</code>，文件<code>A</code>若使用<code>-N</code>参数，则<code>diff</code>会将文件<code>A</code>与一个空白的文件比较。</li><li><code>-p</code>: 若比较的文件为<code>C</code>语言的程序码文件时，显示差异所在的函数名称。</li><li><code>-P</code>或<code>--unidirectional-new-file</code>: 与<code>-N</code>类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</li><li><code>-q</code>或<code>--brief</code>: 仅显示有无差异，不显示详细的信息。</li><li><code>-r</code>或<code>--recursive</code>: 比较子目录中的文件。</li><li><code>-s</code>或<code>--report-identical-files</code>: 若没有发现任何差异，仍然显示信息。</li><li><code>-S &lt;file&gt;</code>或<code>--starting-file &lt;file&gt;</code>: 在比较目录时，从指定的文件开始比较。</li><li><code>-t</code>或<code>--expand-tabs</code>: 在输出时，将<code>tab</code>字符展开。</li><li><code>-T</code>或<code>--initial-tab</code>: 在每行前面加上<code>tab</code>字符以便对齐。</li><li><code>-u</code>，<code>-U &lt;columns&gt;</code>或<code>--unified=&lt;columns&gt;</code>: 以合并的方式来显示文件内容的不同。</li><li><code>-v</code>或<code>--version</code>: 显示版本信息。</li><li><code>-w</code>或<code>--ignore-all-space</code>: 忽略全部的空格字符。</li><li><code>-W &lt;width&gt;</code>或<code>--width &lt;width&gt;</code>: 在使用<code>-y</code>参数时，指定栏宽。</li><li><code>-x &lt;file or folder&gt;</code>或<code>--exclude &lt;file or folder&gt;</code>: 不比较选项中所指定的文件或目录。</li><li><code>-X&lt;file&gt;</code>或<code>--exclude-from&lt;file&gt;</code>: 您可以将文件或目录类型存成文本文件，然后在<code>&lt;file&gt;</code>中指定此文本文件。</li><li><code>-y</code>或<code>--side-by-side</code>: 以并列的方式显示文件的异同之处。</li><li><code>--help</code>: 显示帮助。</li><li><code>--left-column</code>: 在使用<code>-y</code>参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li><code>--suppress-common-lines</code>: 在使用<code>-y</code>参数时，仅显示不同之处。</li></ul><h2 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h2><p>比较<code>file.txt</code>与<code>file2.txt</code>文件的差异，仅输出不同之处。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file.txt file2.txt</span><br></pre></td></tr></table></figure><p>比较<code>file.txt</code>与<code>file2.txt</code>文件的差异，并排输出全部内容，<code>|</code>表示前后<code>2</code>个文件内容有不同，<code>&lt;</code>表示后面文件比前面文件少了<code>1</code>行内容，<code>&gt;</code>表示后面文件比前面文件多了<code>1</code>行内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -y file.txt file2.txt </span><br></pre></td></tr></table></figure><p>比较<code>file.txt</code>与自定义输入内容的差异，输入内容后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -y file.txt -</span><br></pre></td></tr></table></figure><h1 id="diffstat命令"><a href="#diffstat命令" class="headerlink" title="diffstat命令"></a>diffstat命令</h1><p><code>diffstat</code>命令根据<code>diff</code>的比较结果，统计各文件的插入、删除、修改等差异计量。</p><h2 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diffstat [options] [files]</span><br></pre></td></tr></table></figure><h2 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-c</code>: 输出的每一行都以<code>＃</code>作为前缀，使其成为<code>Shell</code>脚本的注释行。</li><li><code>-C</code>: 添加<code>SGR</code>颜色转义序列以突出显示直方图。</li><li><code>-e</code>: 将标准错误重定向到<code>file</code>。</li><li><code>-f &lt;num&gt;</code>: 指定直方图的格式，<code>0</code>仅显示插入<code>+</code>，删除<code>-</code>或修改<code>!</code>的值和单个直方图代码，<code>1</code>正常输出，<code>2</code>用点填充直方图，<code>4</code>用直方图打印每个值，任何非零值都会给出直方图，点和单个值可以组合。</li><li><code>-H</code>: 打印使用情况消息并退出。</li><li><code>-k</code>: 禁止合并报告中的文件名。</li><li><code>-l</code>: 仅列出文件名，不生成直方图。</li><li><code>-n &lt;file length&gt;</code>: 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li><li><code>-o &lt;file&gt;</code>: 将标准输出重定向到<code>file</code>。</li><li><code>-p &lt;file length&gt;</code>: 与<code>-n</code>参数相同，但此处的<code>&lt;file length&gt;</code>包括了文件的路径。</li><li><code>-r</code>: 提供对直方图所示数据的可选舍入，而不是通过误差调整来截断，<code>0</code>是默认值，不进行舍入，但累积的错误将添加到以下列，<code>1</code>舍入数据，<code>2</code>对数据进行舍入并调整直方图，以确保即使有差异通常会四舍五入也存在差异。</li><li><code>-t</code>: 覆盖直方图，生成逗号分隔值的输出。</li><li><code>-u</code>: 禁止在报告中对文件名进行排序。</li><li><code>-v</code>: 显示进度，例如如果将输出重定向到文件，则将进度消息写入标准错误。</li><li><code>-w</code>: 指定输出时栏位的宽度。</li><li><code>-V</code>: 显示版本信息。</li></ul><h2 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h2><p>统计<code>diff</code>的比较结果的差异信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file.txt file2.txt | diffstat -v</span><br></pre></td></tr></table></figure><p>统计<code>diff</code>的比较结果的差异信息，仅列出文件名，不生成直方图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file.txt file2.txt | diffstat -l</span><br></pre></td></tr></table></figure><p>统计<code>diff</code>的比较结果的差异信息，指定直方图的最大宽度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff file.txt file2.txt | diffstat -w 11</span><br></pre></td></tr></table></figure><h1 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h1><p><code>cut</code>命令用来显示行中的指定部分，其从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出，如果不指定<code>File</code>参数，<code>cut</code>命令将读取标准输入，该命令常用的两项功能，一是用来显示文件的内容，它依次读取由参数<code>file</code>所指明的文件，将它们的内容输出到标准输出上，其二是连接两个或多个文件，如<code>cut f1 f2 &gt; f3</code>将把文件<code>f1</code>和几的内容合并起来，然后通过输出重定向符<code>&gt;</code>的作用，将它们放入文件<code>f3</code>中，当文件较大时，文本在屏幕上迅速闪过，也就是滚屏现象，为了控制滚屏，可以执行<code>Ctrl+S</code>按键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，按<code>Ctrl+C</code>键终止该命令的执行等操作。</p><h2 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure><h2 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b</code>: 仅显示行中指定直接范围的内容。</li><li><code>-c</code>: 仅显示行中指定范围的字符。</li><li><code>-d</code>: 指定字段的分隔符，默认的字段分隔符为<code>TAB</code>。</li><li><code>-f</code>: 显示指定字段的内容。</li><li><code>-n</code>: 与<code>-b</code>选项连用，不分割多字节字符。</li><li><code>--complement</code>: 补足被选择的字节、字符或字段。</li><li><code>--out-delimiter=&lt;delimiter&gt;</code>: 指定输出内容是的字段分割符。</li><li><code>--help</code>: 显示指令的帮助信息。</li><li><code>--version</code>: 显示指令的版本信息。</li></ul><h2 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h2><p>截取<code>/tmp/file.txt</code>文件每一行的第<code>3</code>个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /tmp/file.txt | cut -c 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2</span></span><br></pre></td></tr></table></figure><p>截取<code>/tmp/file.txt</code>文件每一行的第<code>3-6</code>个字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /tmp/file.txt | cut -c 3-6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3456</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4567</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5678</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6789</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8901</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9012</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0123</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1234</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2345</span></span><br></pre></td></tr></table></figure><p>截取<code>/tmp/file.txt</code>文件每一行的第<code>3</code>个字符到结尾字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat /tmp/file.txt | cut -c 3-</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">34567890</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">45678901</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">56789012</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">67890123</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">78901234</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">89012345</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">90123456</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">01234567</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">12345678</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">23456789</span></span><br></pre></td></tr></table></figure><h1 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h1><p><code>curl</code>是一个命令行工具，用于使用任何受支持的协议<code>HTTP</code>、<code>FTP</code>、<code>IMAP</code>、<code>POP3</code>、<code>SCP</code>、<code>SFTP</code>、<code>SMTP</code>、<code>TFTP</code>、<code>TELNET</code>、<code>LDAP</code>或<code>FILE</code>向网络服务器传输数据或从网络服务器传输数据，其被设计成无需用户交互即可工作，因此非常适合在<code>shell</code>脚本中使用，该软件提供代理支持、用户身份验证、<code>FTP</code>上传、<code>HTTP posting</code>、<code>SSL</code>连接、<code>cookie</code>、文件断点传输、<code>metalink</code>等功能。</p><h2 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URL...]</span><br></pre></td></tr></table></figure><h2 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-#, --progress-bar</code>: 让<code>curl</code>将进度显示为一个简单的进度条，而不是标准的、更具信息性的计量器。</li><li><code>-:, --next</code>: 告诉<code>curl</code>对以下<code>URL</code>和相关选项使用单独的操作，这允许您发送多个<code>URL</code>请求，每个请求都有自己的特定选项，例如不同的用户名或自定义请求，在<code>7.36.0</code>中添加`。</li><li><code>-0, --http1.0</code>: <code>HTTP</code>，告诉<code>curl</code>使用<code>HTTP 1.0</code>版本，而不是内部首选的<code>HTTP 1.1</code>。</li><li><code>--http1.1</code>: <code>HTTP</code>，告诉<code>curl</code>使用<code>HTTP</code>版本<code>1.1</code>，这是内部默认版本，在<code>7.33.0</code>添加。</li><li><code>--http2</code>: <code>HTTP</code>，告诉<code>curl</code>使用<code>HTTP 2</code>发出请求，这需要构建底层<code>libcurl</code>来支持它，在<code>7.33.0</code>添加。</li><li><code>--no-npn</code>: 禁用<code>NPN TLS</code>扩展，如果<code>libcurl</code>是使用支持<code>NPN</code>的<code>SSL</code>库构建的，则<code>NPN</code>默认启用，支持<code>HTTP 2</code>的<code>libcurl</code>使用<code>NPN</code>在<code>https</code>会话期间与服务器协商对<code>HTTP 2</code>的支持，在<code>7.36.0</code>添加。</li><li><code>--no-alpn</code>: 禁用<code>ALPN TLS</code>扩展，如果<code>libcurl</code>是用一个支持<code>ALPN</code>的<code>SSL</code>库构建的，那么<code>ALPN</code>默认启用，支持<code>HTTP 2</code>的<code>libcurl</code>使用<code>ALPN</code>在<code>https</code>会话期间与服务器协商对<code>HTTP 2</code>的支持，在<code>7.36.0</code>添加。</li><li><code>-1, --tlsv1</code>: <code>SSL</code>，强制<code>curl</code>在与远程<code>TLS</code>服务器协商时使用<code>tls1.x</code>版本，您可以使用选项<code>--tlsv1.0</code>、<code>--tlsv1.1</code>和<code>--tlsv1.2</code>来更精确地控制<code>TLS</code>版本。</li><li><code>-2, --sslv2</code>: <code>SSL</code>，当与远程<code>SSL</code>服务器协商时，强制<code>curl</code>使用<code>SSL version 2</code>。</li><li><code>-3, --sslv3</code>: <code>SSL</code>，当与远程<code>SSL</code>服务器协商时，强制<code>curl</code>使用<code>SSL version 3</code>。</li><li><code>-4, --ipv4</code>: 如果<code>curl</code>能够将一个地址解析为多个<code>IP</code>版本(如果它支持<code>IPv6</code>)，则此选项告诉<code>curl</code>仅将名称解析为<code>IPv4</code>地址。</li><li><code>-6, --ipv6</code>: 如果<code>curl</code>能够将一个地址解析为多个<code>IP</code>版本(如果它支持<code>IPv6</code>)，则此选项告诉<code>curl</code>仅将名称解析为<code>IPv6</code>地址。</li><li><code>-a, --append</code>: <code>FTP/SFTP</code>，当在<code>FTP</code>上传中使用时，这将告诉<code>curl</code>追加到目标文件，而不是覆盖它，如果文件不存在，就创建它，注意，这个选项会被一些<code>SSH</code>服务器忽略，包括<code>OpenSSH</code>。</li><li><code>-A, --user-agent &lt;agent string&gt;</code>: <code>HTTP</code>，指定要发送到<code>HTTP</code>服务器的用户代理字符串，如果这个字段没有设置为<code>Mozilla/4.0</code>，一些做得不好的<code>cgi</code>就会失败，要对字符串中的空格进行编码，请用单引号将字符串括起来，当然，这也可以通过<code>-H，-header</code>选项进行设置，如果多次使用此选项，将使用最后一个选项。</li><li><code>--anyauth</code>: <code>HTTP</code>，告诉<code>curl</code>自己找出身份验证方法，并使用远程站点声称支持的最安全的方法，这是通过首先执行请求并检查响应头来完成的，因此可能会导致额外的网络往返，这是用来代替设置特定的身份验证方法的，您可以使用<code>--basic</code>、<code>--digest</code>、<code>--ntlm</code>和<code>--negotiate</code>来实现，请注意，如果从<code>stdin</code>上传数据，则不建议使用<code>--anyauth</code>，因为它可能需要发送两次数据，然后客户端必须能够倒带，如果从<code>stdin</code>上传时需要，上传操作将失败。</li><li><code>-b, --cookie &lt;name=data&gt;</code>: <code>HTTP</code>，将数据作为<code>cookie</code>传递到<code>HTTP</code>服务器，它应该是以前在<code>Set Cookie:</code>行中从服务器接收到的数据，数据格式应为<code>NAME1=VALUE1; NAME2=VALUE2</code>，如果行中没有使用<code>=</code>符号，则会将其视为用于读取以前存储的<code>cookie</code>行的文件名，如果这些行匹配，则应在此会话中使用，使用这个方法还可以激活<code>cookieparser</code>，它也会让<code>curl</code>记录传入的<code>cookie</code>，如果您将这个方法与<code>-L，-location</code>选项结合使用，这可能会很方便，要从中读取<code>cookie</code>的文件的文件格式应该是纯<code>HTTP</code>头或<code>Netscape/Mozilla cookie</code>文件格式，请注意，用<code>-b, --cookie</code>指定的文件仅用作输入，文件中不会存储<code>Cookie</code>，要存储<code>cookie</code>，请使用<code>-c, --cookiejar</code>选项，或者甚至可以使用<code>-D, --dump-header</code>将<code>HTTP</code>头保存到文件中，如果多次使用此选项，将使用最后一个选项。</li><li><code>-B, --use-ascii</code>: <code>FTP/LDAP</code>，启用<code>ASCII</code>传输，对于<code>FTP</code>，这也可以通过使用以<code>type=A</code>结尾的<code>URL</code>来实现，对于<code>win32</code>系统，此选项使发送到标准输出的数据处于文本模式。</li><li><code>--basic</code>: <code>HTTP</code>，告诉<code>curl</code>使用<code>HTTP</code>基本身份验证，这是默认值，并且此选项通常是无意义的，除非您使用它来重写先前设置的选项，该选项设置了不同的身份验证方法，例如<code>--ntlm</code>、<code>--digest</code>或<code>--negotiate</code>。</li><li><code>-c, --cookie-jar &lt;file name&gt;</code>: <code>HTTP</code>，指定在完成操作后要将所有<code>cookie</code>写入哪个文件，<code>curl</code>写入以前从指定文件读取的所有<code>cookie</code>以及从远程服务器接收的所有<code>cookie</code>，如果没有已知的<code>cookies</code>，则不会写入任何文件，文件将使用<code>Netscape cookie</code>文件格式写入，如果将文件名设置为单破折号<code>-</code>，则<code>cookie</code>将写入标准输出，此命令行选项将激活生成<code>curl</code>记录并使用<code>cookie</code>的<code>cookie</code>引擎，另一种激活它的方法是使用<code>-b, --cookie</code>选项，如果不能创建或写入<code>cookiejar</code>，整个<code>curl</code>操作不会失败，甚至不会清楚地报告错误，使用<code>-v</code>会显示一个警告，但这是关于这种可能致命的情况的唯一可见反馈，如果多次使用此选项，将使用最后指定的文件名。</li><li><code>-C, --continue-at &lt;offset&gt;</code>: 以给定的偏移量继续<code>/</code>恢复以前的文件传输，给定的偏移量是将被跳过的确切字节数，从源文件的开头开始计算，然后再将其传输到目标，如果与上载一起使用，<code>curl</code>将不使用<code>FTP</code>服务器命令大小，使用<code>-C -</code>告诉<code>curl</code>自动找出在哪里<code>/</code>如何继续传输，然后它使用给定的输出<code>/</code>输入文件来解决这个问题，如果多次使用此选项，将使用最后一个选项。</li><li><code>--ciphers &lt;list of ciphers&gt;</code>: <code>SSL</code>，指定要在连接中使用的密码，密码列表必须指定有效的密码，此为的<code>SSL</code>密码列表详细信息<code>http://www.openssl.org/docs/apps/ciphers.html</code>，<code>NSS</code>密码的实现方式与<code>OpenSSL</code>和<code>GnuTLS</code>不同，<code>NSS</code>密码的完整列表位于以下<code>URL</code>的<code>NSSCipherSuite</code>条目中<code>http://git.fedorahosted.org/cgit/mod_nss.git/plain/docs/mod_nss.html#Directives</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--compressed</code>: <code>HTTP</code>，使用<code>curl</code>支持的算法之一请求压缩响应，并保存未压缩的文档，如果使用此选项并且服务器发送不受支持的编码，<code>curl</code>将报告错误。</li><li><code>--connect-timeout &lt;seconds&gt;</code>: 允许连接到服务器的最长时间(秒)，这只会限制连接阶段，一旦<code>curl</code>连接了，这个选项就不再有用了，自<code>7.32.0</code>以来，此选项接受十进制值，但实际超时的精度将随着指定超时的十进制精度增加而降低，另请参见<code>-m, -max time</code>选项，如果多次使用此选项，将使用最后一个选项。</li><li><code>--create-dirs</code>: 当与<code>-o</code>选项结合使用时，<code>curl</code>将根据需要创建必要的本地目录层次结构，此选项创建与<code>-o</code>选项一起提到的<code>dir</code>，而不是其他选项，如果<code>-o</code>文件名不使用<code>dir</code>，或者它提到的<code>dir</code>已经存在，则不会创建<code>dir</code>，要在使用<code>FTP</code>或<code>SFTP</code>时创建远程目录，请尝试<code>--FTP create dirs</code>。</li><li><code>--crlf</code>: <code>FTP</code>，上传时将<code>LF</code>转换为<code>CRLF</code>，适用于<code>MVS (OS/390)</code>。</li><li><code>--crlfile &lt;file&gt;</code>: <code>HTTPS/FTPS</code>，提供一个使用<code>PEM</code>格式的文件，其中包含一个证书吊销列表，该列表可以指定要被视为吊销的对等证书，如果多次使用此选项，将使用最后一个选项，在<code>7.19.7</code>增加。</li><li><code>-d, --data &lt;data&gt;</code>: <code>HTTP</code>，将<code>POST</code>请求中指定的数据发送到<code>HTTP</code>服务器，就像用户填写<code>HTML</code>表单并按下<code>submit</code>按钮时浏览器所做的那样，这将导致<code>curl</code>使用内容类型<code>application/x-www-form-urlencoded</code>将数据传递给服务器，与<code>-F, --form</code>比较，<code>-d, --data</code>与<code>--data ascii</code>相同，要发布纯二进制的数据，应该改用<code>--data binary</code>选项，要对表单字段的值进行<code>URL</code>编码，可以使用<code>--data urlencode</code>，如果这些选项中的任何一个在同一命令行上被多次使用，则指定的数据段将与分隔的<code>&amp;</code>符号合并在一起，因此，使用<code>-d name=daniel -d skill=lousy</code>将生成一个类似<code>name=daniel&amp;skill=lousy</code>的<code>post</code>块，如果数据以<code>@</code>开头，其余的应该是从中读取数据的文件名，如果要从<code>stdin</code>读取数据，也可以指定多个文件，例如，从名为<code>foobar</code>的文件发布数据将使用<code>--data@foobar</code>完成，当<code>--data</code>被告知从这样的文件中读取时，回车符和换行符将被去除。</li><li><code>-D, --dump-header &lt;file&gt;</code>: 将协议头写入指定的文件，当您想存储<code>HTTP</code>站点发送给您的头文件时，使用此选项非常方便,通过使用<code>-b, -cookie</code>选项，可以在第二次<code>curl</code>调用中读取来自头的<code>cookie</code>，但是，<code>-c，-cookie jar</code>选项是存储<code>cookie</code>的更好方法，在<code>FTP</code>中使用时，<code>FTP</code>服务器响应行被认为是<code>headers</code>，因此保存在那里，如果多次使用此选项，将使用最后一个选项。</li><li><code>--data-ascii &lt;data&gt;</code>: 请参见<code>-d, --data</code>。</li><li><code>--data-binary &lt;data&gt;</code>: <code>HTTP</code>，这将完全按照指定的方式发布数据，无需任何额外处理，如果数据以<code>@</code>开头，其余的应该是文件名，数据的发布方式与<code>--dataascii</code>类似，只是保留了换行符和回车符，并且从不进行转换，如果多次使用此选项，则第一个选项后面的选项将附加<code>-d, -data</code>中所述的数据。</li><li><code>--data-urlencode &lt;data&gt;</code>: <code>HTTP</code>，这会发布数据，与其他<code>--data</code>选项类似，但会执行<code>URL</code>编码，在<code>7.18.0</code>中添加，为了符合<code>CGI</code>，<code>&lt;data&gt;</code>部分应以名称开头，后跟分隔符和内容规范，可以使用以下语法之一将<code>&lt;data&gt;</code>部分传递给<code>curl</code>:<ul><li><code>content</code>: 这将使<code>curl URL</code>编码内容并将其传递，请小心，使内容不包含任何<code>=</code>或<code>@</code>符号，因为这将使语法与以下其他情况之一匹配。</li><li><code>=content</code>: 这将使<code>curl URL-encode</code>编码内容并将其传递，前面的<code>=</code>符号不包括在数据中。</li><li><code>name=content</code>: 这将使<code>curl URL</code>编码内容部分并将其继续传递，请注意，名称部分应该已经过<code>URL</code>编码。</li><li><code>@filename</code>: 这将使卷曲加载来自给定文件(包括任何换行符)的数据，对该数据进行<code>URL</code>编码并在<code>POST</code>中传递。</li><li><code>name@filename</code>: 这将使<code>curl</code>从给定的文件(包括任何换行符)加载数据，<code>URL</code>对该数据进行编码并在<code>POST</code>中传递，名称部分附加了一个等号，结果是<code>name=urlencoded</code>文件内容，注意，名称应该已经是<code>URL</code>编码的。</li></ul></li><li><code>--delegation LEVEL</code>: 设置<code>LEVEL</code>，告诉服务器在处理用户凭据时允许委托什么，通常与<code>GSS/kerberos</code>一起使用。<ul><li><code>none</code>: 不允许任何授权。</li><li><code>policy</code>: 委托当且仅当<code>Kerberos</code>服务票证中设置了<code>OK-AS-DELEGATE</code>标志时，这是领域策略的问题。</li><li><code>always</code>: 无条件地允许服务器进行委托。</li></ul></li><li><code>--digest</code>: <code>HTTP</code>，启用<code>HTTP</code>摘要身份验证，这是一种身份验证方案，可防止密码以明文形式通过有线发送，将此选项与正常的<code>-u, -user</code>选项结合使用，以设置用户名和密码，如果多次使用此选项，则只使用第一个选项。</li><li><code>--disable-eprt</code>: <code>FTP</code>，告诉<code>curl</code>在执行活动<code>FTP</code>传输时禁用<code>EPRT</code>和<code>LPRT</code>命令，<code>curl</code>通常会首先尝试使用<code>EPRT</code>，然后在使用<code>PORT</code>之前使用<code>LPRT</code>，但是有了这个选项，它会立即使用<code>PORT</code>，<code>EPRT</code>和<code>LPRT</code>是原始<code>FTP</code>协议的扩展，可能无法在所有服务器上工作，但它们以比传统的<code>PORT</code>命令更好的方式实现了更多功能，<code>--eprt</code>可以用来再次显式地启用<code>eprt</code>，并且<code>--no eprt</code>是<code>--disable eprt</code>的别名，禁用<code>EPRT</code>只会更改活动行为，如果要切换到被动模式，则不需要使用<code>-P, -ftp</code>端口或强制使用<code>-ftp pasv</code>。</li><li><code>--dns-interface &lt;interface&gt;</code>: 告诉<code>curl</code>通过<code>&lt;interface&gt;</code>发送传出的<code>DNS</code>请求，此选项对应于<code>--interface</code>(不影响<code>DNS</code>)，提供的字符串必须是接口名称(不是地址)，此选项要求<code>libcurl</code>是使用支持此操作的解析器后端构建的，<code>c-ares</code>后端是唯一这样的，在<code>7.33.0</code>中添加。</li><li><code>--dns-ipv4-addr &lt;ip-address&gt;</code>: 告诉<code>curl</code>在发出<code>ipv4dns</code>请求时绑定到<code>&lt;ip address&gt;</code>，以便<code>DNS</code>请求源自此地址，参数应为单个<code>IPv4</code>地址，此选项要求<code>libcurl</code>是使用支持此操作的解析器后端构建的，<code>c-ares</code>后端是唯一这样的，在<code>7.33.0</code>中添加。</li><li><code>--dns-ipv6-addr &lt;ip-address&gt;</code>: 在发出<code>ipv6dns</code>请求时，告诉<code>curl</code>绑定到<code>&lt;ip address&gt;</code>，以便<code>DNS</code>请求源自此地址，参数应为单个<code>IPv6</code>地址，此选项要求<code>libcurl</code>是使用支持此操作的解析器后端构建的，<code>c-ares</code>后端是唯一这样的，在<code>7.33.0</code>中添加。</li><li><code>--dns-servers &lt;ip-address,ip-address&gt;</code>: 设置要使用的<code>DNS</code>服务器列表，而不是系统默认值，<code>IP</code>地址列表应以逗号分隔，端口号也可以选择在每个<code>IP</code>地址后给出<code>&lt;Port number&gt;</code>，此选项要求<code>libcurl</code>是使用支持此操作的解析器后端构建的，<code>c-ares</code>后端是唯一这样的，在<code>7.33.0</code>中添加。</li><li><code>-e, --referer &lt;URL&gt;</code>: <code>HTTP</code>，将<code>referer Page</code>信息发送到<code>HTTP</code>服务器，当然，这也可以用<code>-H, -header</code>标志来设置，当与<code>-L, -location</code>一起使用时，您可以在<code>--referer URL</code>后面附加<code>; auto</code>，使<code>curl</code>在<code>location:header</code>后面自动设置上一个<code>URL</code>，<code>auto</code>字符串可以单独使用，即使您没有设置初始<code>--referer</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>-E, --cert &lt;certificate[:password]&gt;</code>: <code>SSL</code>，告诉<code>curl</code>在使用<code>HTTPS</code>、<code>FTPS</code>或其他基于<code>SSL</code>的协议获取文件时使用指定的客户端证书文件，如果使用安全传输，证书必须为<code>PKCS#12</code>格式，如果使用任何其他引擎，证书必须为<code>PEM</code>格式，如果未指定可选密码，将在终端上查询该密码，注意，这个选项假设一个<code>certificate</code>是私钥和私钥连接在一起的，请参见<code>--cert</code>和<code>--key</code>以独立地指定它们。</li><li><code>--engine &lt;name&gt;</code>: 选择用于密码操作的<code>OpenSSL</code>加密引擎，使用<code>--engine list</code>打印构建时支持的引擎的列表，请注意，并非所有<code>engine</code>在运行时都可用。</li><li><code>--environment</code>: <code>RISC OS ONLY</code>，使用<code>-w</code>选项支持的名称设置一系列环境变量，以便在运行<code>curl</code>之后更容易地提取有用的信息。</li><li><code>--egd-file &lt;file&gt;</code>: <code>SSL</code>，指定守护进程套接字的路径名，套接字用于为<code>SSL</code>连接的随机引擎播种，另请参见<code>--random file</code>选项。</li><li><code>--cert-type &lt;type&gt;</code>: <code>SSL</code>，告诉<code>curl</code>提供的证书是什么类型的证书，<code>PEM</code>、<code>DER</code>和<code>ENG</code>是公认的类型，如果未指定，则假定为<code>PEM</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--cacert &lt;CA certificate&gt;</code>: <code>SSL</code>，告诉<code>curl</code>使用指定的证书文件来验证对等方，文件可能包含多个<code>CA</code>证书，证书必须采用<code>PEM</code>格式，通常情况下，<code>curl</code>是使用默认文件构建的，因此此选项通常用于更改默认文件。</li><li><code>--capath &lt;CA certificate directory&gt;</code>: <code>SSL</code>，告诉<code>curl</code>使用指定的证书目录来验证对等方，可以通过使用<code>:</code>分隔多条路径，例如<code>path1:path2:path3</code>，证书必须是<code>PEM</code>格式的，如果<code>curl</code>是基于<code>OpenSSL</code>构建的，那么目录必须使用<code>OpenSSL</code>提供的<code>c_rehash</code>程序进行处理，如果<code>--cacert</code>文件包含许多<code>CA</code>证书，那么使用<code>--capath</code>可以使<code>OpenSSL</code>支持的<code>curl</code>比使用<code>--cacert</code>更有效地建立<code>SSL</code>连接。如果设置了此选项，将忽略默认的<code>capath</code>值，如果多次使用，将使用最后一个值。</li><li><code>-f, --fail</code>: <code>HTTP</code>，服务器错误时无提示失败，即完全没有输出，这样做主要是为了更好地使脚本等更好地处理失败的尝试，在正常情况下，当<code>HTTP</code>服务器无法传递文档时，它会返回一个<code>HTML</code>文档，通常会描述原因，此标志将阻止<code>curl</code>输出该值并返回错误<code>22</code>，这种方法不是故障安全的，有时会出现不成功的响应代码，特别是在涉及身份验证时，例如响应代码<code>401</code>和<code>407</code>。</li><li><code>-F, --form &lt;name=content&gt;</code>: <code>HTTP</code>，这使得<code>curl</code>可以模拟用户按下<code>submit</code>按钮的填充表单，<code>curl</code>根据<code>rfc2388</code>使用内容类型<code>multipart/form</code>数据发布数据，这样就可以上传二进制文件等，若强制内容部分成为文件，在文件名前面加上<code>@</code>符号，若要仅从文件中获取内容部分，请在文件名前面加上<code>&lt;</code>符号，<code>@</code>和<code>&lt;</code>之间的区别是<code>@</code>使一个文件作为文件上传附加到<code>post</code>中，而<code>&lt;</code>使一个文本字段从一个文件中获取该文本字段的内容。</li><li><code>--ftp-account [data]</code>: <code>FTP</code>，当<code>FTP</code>服务器在提供用户名和密码后请求<code>account data</code>时，使用<code>ACCT</code>命令发送该数据，在<code>7.13.0</code>中添加，如果多次使用此选项，将使用最后一个选项。</li><li><code>--ftp-alternative-to-user &lt;command&gt;</code>: <code>FTP</code>，如果与用户的身份验证和<code>PASS</code>命令失败，则发送此命令，当使用客户端证书通过<code>FTPS</code>连接到<code>Tumbleweed</code>的安全传输服务器时，使用<code>SITE AUTH</code>将告诉服务器从证书中检索用户名，在<code>7.15.5</code>增加。</li><li><code>--ftp-create-dirs</code>: <code>FTP/SFTP</code>，当<code>FTP</code>或<code>sftp url/</code>操作使用服务器上当前不存在的路径时，<code>curl</code>的标准行为是失败，使用此选项，<code>curl</code>将尝试创建丢失的目录。</li><li><code>--ftp-method [method]</code>: <code>FTP</code>，控制<code>curl</code>应该使用什么方法访问<code>FTP(S)</code>服务器上的文件，在<code>7.15.1</code>添加，方法参数应该是以下选项之一：<ul><li><code>multicwd</code>: <code>curl</code>对给定<code>URL</code>中的每个路径部分执行一个<code>CWD</code>操作，对于深层层次结构，这意味着有很多命令，<code>RFC1738</code>就是这么说明的，这是默认但最慢的行为。</li><li><code>nocwd</code>: <code>curl</code>根本不做<code>CWD</code>，<code>curl</code>将执行<code>SIZE</code>、<code>RETR</code>、<code>STOR</code>等操作，并为所有这些命令提供到服务器的完整路径，这是最快的行为。</li><li><code>singlecwd</code>: <code>curl</code>对完整的目标目录执行一个<code>CWD</code>，然后正常地对文件进行操作，就像<code>multicwd</code>一样，这比<code>nocwd</code>更符合标准，但没有<code>multicwd</code>的全部处理。</li></ul></li><li><code>--ftp-pasv</code>: <code>FTP</code>，数据连接使用被动模式，被动是内部默认行为，但使用此选项可用于覆盖以前的<code>-P/-ftp</code>端口选项，在<code>7.11.0</code>中添加，如果多次使用此选项，则只使用第一个选项，撤消强制的被动端口确实是不可行的，但是您必须再次强制执行正确的<code>-P, --ftp</code>端口，被动模式意味着<code>curl</code>将首先尝试<code>EPSV</code>命令，然后再尝试<code>PASV</code>，除非使用<code>--disable EPSV</code>。</li><li><code>--ftp-skip-pasv-ip</code>: <code>FTP</code>，当<code>curl</code>连接数据连接时，告诉<code>curl</code>不要使用服务器在响应<code>curl</code>的<code>PASV</code>命令时建议的<code>IP</code>地址，相反，<code>curl</code>将重用它已经用于控制连接的相同<code>IP</code>地址，在<code>7.14.2</code>增加，如果使用<code>PORT</code>、<code>EPRT</code>或<code>EPSV</code>代替<code>PASV</code>，则此选项无效。</li><li><code>--ftp-pret</code>: <code>FTP</code>，告诉<code>curl</code>在<code>PASV</code>和<code>EPSV</code>之前发送<code>PRET</code>命令，某些<code>FTP</code>服务器(主要是<code>drftpd</code>)需要这个非标准的命令来显示目录列表，以及在<code>PASV</code>模式下进行更新和下载，在<code>7.20.x</code>中添加。</li><li><code>--ftp-ssl-ccc</code>: <code>FTP</code>，使用<code>CCC</code>(清除命令通道)在验证后关闭<code>SSL/TLS</code>层，控制信道通信的其余部分将是未加密的，这允许<code>NAT</code>路由器跟踪<code>FTP</code>事务，默认模式为被动模式，其他模式请参见<code>--ftp ssl ccc mode</code>，在<code>7.16.1</code>增加。</li><li><code>--ftp-ssl-ccc-mode [active/passive]</code>: <code>FTP</code>，使用<code>CCC</code>(清除命令通道)设置<code>CCC</code>模式，被动模式不会启动关闭，而是等待服务器执行，并且不会从服务器回复关闭，活动模式启动关机并等待服务器的回复，<code>7.16.2</code>增加。</li><li><code>--ftp-ssl-control</code>: <code>FTP</code>，<code>FTP</code>登录需要<code>SSL/TLS</code>，清除以进行传输，允许安全的身份验证，但非加密的数据传输效率，如果服务器不支持<code>SSL/TLS</code>，则传输失败，在<code>7.16.0</code>中添加，目前仍然可以使用，但将在将来的版本中删除。</li><li><code>--form-string &lt;name=string&gt;</code>: <code>HTTP</code>，类似于<code>--form</code>，只是命名参数的值字符串是按字面意思使用的，值中的前导<code>@</code>和<code>&lt;</code>字符以及<code>; type=</code>字符串没有特殊含义，如果字符串值可能意外触发<code>--form</code>的’<code>@</code>‘或’<code>&lt;</code>‘特性，请优先使用<code>--form</code>。</li><li><code>-g, --globoff</code>: 此选项关闭<code>URL globbing</code>解析器，设置此选项时，可以指定包含字母<code>&#123;&#125;[]</code>的<code>URL</code>，而无需<code>curl</code>本身对其进行解释，请注意，这些字母不是正常的合法<code>URL</code>内容，但它们应该根据<code>URI</code>标准进行编码。 </li><li><code>-G, --get</code>: 使用此选项时，将使用<code>-d</code>、<code>-data</code>、<code>-data binary</code>或<code>-data urlencode</code>指定的所有数据在<code>HTTP GET</code>请求中使用，而不是在其他情况下使用的<code>POST</code>请求，数据将附加到带有<code>?</code>的<code>URL</code>中分离器，如果与<code>-I</code>结合使用，<code>POST</code>数据将被附加到带有<code>HEAD</code>请求的<code>URL</code>中，如果多次使用此选项，则只使用第一个选项，这是因为撤消<code>GET</code>没有意义，但是您应该执行您喜欢的替代方法。</li><li><code>-H, --header &lt;header&gt;</code>: <code>HTTP</code>，向服务器发送<code>HTTP</code>时请求中包含的额外头，您可以指定任意数量的额外标头，请注意，如果您应该添加一个与<code>curl</code>将使用的内部头具有相同名称的自定义头，那么将使用外部设置的头而不是内部头，这使得你可以做比<code>curl</code>更复杂的东西，您不应该在不完全清楚自己在做什么的情况下替换内部设置的头文件，通过在冒号的右侧提供一个没有内容的替换来删除内部标题，如<code>: -H Host:</code>，如果发送没有值的自定义标头，则其标头必须以分号结尾，例如<code>-H X-custom-header;</code>以发送<code>X-custom-header:</code>，<code>curl</code>将确保您添加<code>/</code>替换的每个标题都使用正确的行尾标记发送，因此您不应将其添加为标题内容的一部分<code>:</code>不要添加换行符或回车符，它们只会为您带来麻烦，另请参见<code>-A, --user-agent</code>和<code>-e, --referer</code>选项。</li><li><code>--hostpubmd5 &lt;md5&gt;</code>: <code>SCP/SFTP</code>，传递包含<code>32</code>个十六进制数字的字符串，字符串应该是远程主机公钥的<code>128</code>位<code>MD5</code>校验和，除非<code>md5 sums</code>匹配，否则<code>curl</code>将拒绝与主机的连接，在<code>7.17.1</code>增加。</li><li><code>--ignore-content-length</code>: <code>HTTP</code>，忽略内容长度标题，这对于运行<code>Apache1.x</code>的服务器尤其有用，后者将报告大于<code>2G</code>的文件的不正确内容长度。</li><li><code>-i, --include</code>: <code>HTTP</code>，在输出中包括<code>HTTP</code>头，<code>HTTP</code>头包括服务器名称、文档日期、<code>HTTP</code>版本等内容。</li><li><code>-I, --head</code>: <code>HTTP/FTP/FILE</code>，仅获取<code>HTTP</code>头<code>HTTP</code>服务器的特点是响应头，它只用来获取文档的头，当用于<code>FTP</code>或文件时，<code>curl</code>仅显示文件大小和上次修改时间。</li><li><code>--interface &lt;name&gt;</code>: 使用指定的接口执行操作，您可以输入接口名、<code>IP</code>地址或主机名，例如<code>: curl</code>—接口<code>eth0:1 http://www.netscape.com/</code>如果多次使用此选项，将使用最后一个选项。</li><li><code>-j, --junk-session-cookies</code>: <code>HTTP</code>，当<code>curl</code>被告知从给定文件读取<code>cookies</code>时，此选项将使其放弃所有会话<code>cookies,</code>这将基本上具有与启动新会话相同的效果，典型的浏览器总是在关闭会话<code>cookie</code>时丢弃它们。</li><li><code>-J, --remote-header-name</code>: <code>HTTP</code>，此选项告诉<code>-O, -remote name</code>选项使用服务器指定的内容配置文件名，而不是从<code>URL</code>提取文件名，在提供的文件名中还没有尝试解码%<code>-</code>序列，因此此选项可能会为您提供意外的文件名。</li><li><code>-k, --insecure</code>: <code>SSL</code>，这个选项显式地允许<code>curl</code>执行不安全的<code>SSL</code>连接和传输，所有<code>SSL</code>连接都试图通过使用默认安装的<code>CA</code>证书捆绑包来确保安全，这使得所有被认为是不安全的连接失败，除非使用<code>-k, -unsecure</code>。</li><li><code>-K, --config &lt;config file&gt;</code>: 指定从哪个配置文件读取<code>curl</code>参数，配置文件是一个文本文件，可以在其中写入命令行参数，然后使用这些参数，就像它们被写入实际的命令行一样，选项及其参数必须在同一配置文件行中指定，并用空格、冒号或等号分隔，可以选择在配置文件中给出长选项名，而不使用初始双破折号，如果是这样，冒号或等号字符可以用作分隔符，如果使用一个或两个破折号指定选项，则选项与其参数之间不能有冒号或等号字符，如果参数要包含空格，则参数必须用引号括起来，在双引号中，下列转义序列可用: <code>\\</code>、<code>\&quot;</code>、<code>\t</code>、<code>\n</code>、<code>\r</code>、<code>\v</code>，任何其他字母前面的反斜杠将被忽略，如果配置行的第一列是<code>#</code>字符，则该行的其余部分将被视为注释，在配置文件中，每个物理行只写一个选项，将文件名指定为<code>-K, --config</code>为<code>-,</code>使<code>curl</code>从<code>stdin</code>读取文件。</li><li><code>--keepalive-time &lt;seconds&gt;</code>: 此选项设置在发送<code>keepalive</code>探测之前连接需要保持空闲的时间以及各个<code>keepalive</code>探测之间的时间，它目前在提供<code>TCP_KEEPIDLE</code>和<code>TCP_KEEPINTVL</code>套接字选项的操作系统上非常有效(指<code>Linux</code>、最近的<code>AIX</code>、<code>HP-UX</code>等)，如果使用<code>--no keepalive,</code>则此选项无效，(在<code>7.18.0</code>中添加)如果多次使用此选项，将使用最后一个选项，如果未指定，则该选项默认为<code>60</code>秒。</li><li><code>--key &lt;key&gt;</code>: <code>SSL/SSH</code>，私钥文件名，允许您在此单独的文件中提供私钥，如果多次使用此选项，将使用最后一个选项。</li><li><code>--key-type &lt;type&gt;</code>: <code>SSL</code>，私钥文件类型，指定<code>--key</code>提供的私钥是哪种类型，支持<code>DER</code>、<code>PEM</code>和<code>ENG,</code>如果未指定，则假定为<code>PEM</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--krb &lt;level&gt;</code>: <code>FTP</code>，启用<code>Kerberos</code>身份验证和使用，必须输入级别，并且级别应为<code>clear</code>、<code>safe</code>、<code>secretary</code>或<code>private</code>之一，如果您使用的级别不是这些级别之一，则将改用<code>private</code>，此选项需要使用<code>kerberos4</code>支持构建的库，这并不常见，使用<code>-V, -version</code>查看卷曲是否支持它，如果多次使用此选项，将使用最后一个选项。</li><li><code>-l, --list-only</code>: <code>FTP</code>，列出<code>FTP</code>目录时，此开关强制使用仅名称视图，如果用户希望机器解析<code>FTP</code>目录的内容，这尤其有用，因为普通目录视图不使用标准的外观或格式，这样使用时，该选项将导致向服务器发送<code>NLST</code>命令，而不是<code>LIST</code>，注意: 一些<code>FTP</code>服务器在响应<code>NLST</code>时只列出文件，它们不包括子目录和符号链接，<code>POP3</code>从<code>POP3</code>检索特定电子邮件时，此开关强制执行<code>LIST</code>命令而不是<code>RETR</code>，如果用户希望查看服务器上是否存在特定的消息<code>id</code>以及它的大小，那么这一点特别有用，注意: 当与<code>-X, -request&lt;command&gt;</code>组合使用时，此选项可用于发送<code>UIDL</code>命令，因此用户可以使用电子邮件的唯一标识符而不是其消息<code>id</code>来发出请求，在<code>7.21.5</code>增加。</li><li><code>-L, --location</code>: <code>HTTP/HTTPS</code>，如果服务器报告请求的页面已移动到其他位置(用<code>location:header</code>和<code>3XX</code>响应代码表示)，此选项将使<code>curl</code>在新位置上重做请求，如果与<code>-i, --include</code>或<code>-i, --head</code>一起使用，将显示所有请求页面的标题，使用身份验证时，<code>curl</code>只将其凭据发送到初始主机，如果重定向将<code>curl</code>带到另一个主机，它将无法截获用户<code>+</code>密码，另请参见<code>--location trusted</code>，了解如何更改此设置，您可以使用<code>--max redirs</code>选项来限制要遵循的重定向数量，当<code>curl</code>遵循重定向并且请求不是纯<code>GET</code>(例如<code>POST</code>或<code>PUT</code>)时，如果<code>HTTP</code>响应是<code>301</code>、<code>302</code>或<code>303</code>，它将使用<code>GET</code>执行以下请求，如果响应代码是任何其他<code>3xx</code>代码，<code>curl</code>将使用相同的未修改方法重新发送以下请求，您可以告诉<code>curl</code>不要更改<code>non-GET</code>请求方法，以便在<code>30x</code>响应之后使用专用选项<code>--post301</code>、<code>-post302</code>和<code>-post303</code>获取。</li><li><code>--libcurl &lt;file&gt;</code>: 将此选项附加到任何普通的<code>curl</code>命令行，您将获得一个<code>libcurl</code>，它使用<code>C</code>源代码编写到文件中，执行与命令行操作相同的操作！如果多次使用此选项，将使用最后给定的文件名，<code>7.16.1</code>增加。</li><li><code>--limit-rate &lt;speed&gt;</code>: 指定您希望<code>curl</code>使用的最大传输速率<code>-</code>用于下载和上载，如果您有一个有限的管道，并且希望您的传输不使用整个带宽，则此功能非常有用，使它比其他情况下慢，给定的速度以字节<code>/</code>秒为单位，除非附加后缀，加上<code>k</code>或<code>k</code>将把数字计为千字节，<code>m</code>或<code>m</code>表示兆字节，而<code>g</code>或<code>g</code>表示千兆字节，例如<code>: 200K</code>、<code>3m</code>和<code>1G</code>，给定的速率是整个传输过程中计算的平均速度，这意味着<code>curl</code>可能在短脉冲中使用更高的传输速度，但随着时间的推移，它使用的传输速度不会超过给定的速率，如果您还使用<code>-Y, -speed limit</code>选项，则该选项将优先，并可能略微削弱速率限制，以帮助保持速度限制逻辑正常工作，如果多次使用此选项，将使用最后一个选项。</li><li><code>--local-port &lt;num&gt;[-num]</code>: 设置用于连接的本地端口号的首选数目或范围，请注意，端口号本质上是一种稀缺资源，有时会很忙，因此将此范围设置为太窄可能会导致不必要的连接设置失败，在<code>7.15.2</code>增加。</li><li><code>--location-trusted</code>: <code>HTTP/HTTPS</code>，与<code>-L, --location</code>类似，但允许向站点可能重定向到的所有主机发送名称<code>+</code>密码，如果站点将您重定向到要向其发送身份验证信息的站点(在<code>HTTP</code>基本身份验证的情况下是明文)，则这可能会或可能不会导致安全漏洞。</li><li><code>-m, --max-time &lt;seconds&gt;</code>: 允许整个操作所用的最长时间(秒)，这有助于防止批处理作业因网络或链接运行缓慢而挂起数小时，自<code>7.32.0</code>以来，此选项接受十进制值，但实际超时的精度将随着指定超时的十进制精度增加而降低，另请参见<code>--connect timeout</code>选项，如果多次使用此选项，将使用最后一个选项。</li><li><code>--login-options &lt;options&gt;</code>: 指定服务器身份验证期间要使用的登录选项，您可以使用登录选项指定身份验证期间可能使用的特定于协议的选项，目前只有<code>IMAP</code>、<code>POP3</code>和<code>SMTP</code>支持登录选项，有关登录选项的更多信息，请参阅<code>RFC 2384</code>、<code>RFC 5092</code>和<code>IETF</code>草稿<code>draft-earhart-url-smtp-00.txt</code>(在<code>7.34.0</code>中添加)，如果多次使用此选项，将使用最后一个选项。</li><li><code>--mail-auth &lt;address&gt;</code>: <code>SMTP</code>，指定单个地址，这将用于指定正在中继到另一个服务器的已提交邮件的身份验证地址(标识)，在<code>7.25.0</code>中添加。</li><li><code>--mail-from &lt;address&gt;</code>: <code>SMTP</code>，指定发送给定邮件的单一地址，在<code>7.20.0</code>中添加。</li><li><code>--max-filesize &lt;bytes&gt;</code>: 指定要下载的文件的最大大小(以字节为单位)，如果请求的文件大于这个值，传输将不会开始，<code>curl</code>将返回退出代码<code>63</code>，注意<code>:</code>文件大小在下载之前并不总是已知的，对于这样的文件，即使文件传输最终超过这个给定的限制，这个选项也不起作用，这涉及到<code>FTP</code>和<code>HTTP</code>传输。</li><li><code>--mail-rcpt &lt;address&gt;</code>: (<code>SMTP</code>)指定单个地址、用户名或邮件列表名称，在执行邮件传输时，收件人应指定要将邮件发送到的有效电子邮件地址，(在<code>7.20.0</code>中添加)执行地址验证(<code>VRFY</code>命令)时，应将收件人指定为用户名或用户名和域(根据<code>RFC5321</code>第<code>3.5</code>节)，(在<code>7.34.0</code>中添加)在执行邮件列表扩展(<code>EXPN</code>命令)时，应该使用邮件列表名称指定收件人，例如<code>Friends</code>或<code>London Office</code>，在<code>7.34.0</code>中添加。</li><li><code>--max-redirs &lt;num&gt;</code>: 设置允许的最大重定向次数，如果使用<code>-L, --location</code>，这个选项可以用来防止<code>curl</code>不断地遵循重定向，默认情况下，限制设置为<code>50</code>个重定向，将此选项设置为<code>-1</code>以使其无限，如果多次使用此选项，将使用最后一个选项。</li><li><code>--metalink</code>: 此选项可以告诉<code>curl</code>将给定的<code>URI</code>作为<code>Metalink</code>文件进行解析和处理(支持版本<code>3</code>和版本<code>4</code>(<code>RFC 5854</code>))，并在出现错误(例如文件或服务器不可用)时使用中列出的镜像进行故障转移，它还将在下载完成后验证文件的哈希值，<code>Metalink</code>文件本身在内存中下载和处理，而不是存储在本地文件系统中。</li><li><code>-n, --netrc</code>: 使<code>curl</code>扫描用户主目录中的<code>.netrc</code>(<code>netrc on Windows</code>)文件以获取登录名和密码，这通常用于<code>UNIX</code>上的<code>FTP</code>，如果与<code>HTTP</code>一起使用，<code>curl</code>将启用用户身份验证，有关文件格式的详细信息，请参阅<code>netrc(4)</code>或<code>ftp(1)</code>，如果文件没有正确的权限，<code>curl</code>不会报错，环境变量<code>HOME</code>用于查找主目录，一个快速且非常简单的示例，说明如何设置<code>.netrc</code>以允许<code>curl</code>通过<code>FTP</code>传输到机器<code>host.domain.com</code>网站用户名为<code>myself</code>和密码为<code>secret</code>的应类似于<code>:</code>机器<code>host.domain.com</code>网站登录密码密码。</li><li><code>-N, --no-buffer</code>: 禁用输出流的缓冲，在正常的工作环境中，<code>curl</code>将使用一个标准的缓冲输出流，它将以块的形式输出数据，而不一定是在数据到达时，使用此选项将禁用该缓冲，请注意，这是已记录的否定选项名称，因此，可以使用<code>--buffer</code>来强制执行缓冲。</li><li><code>--netrc-file</code>: 此选项类似于<code>--netrc</code>，只是您提供了<code>curl</code>应该使用的<code>netrc</code>文件的路径(绝对或相对)，每次调用只能指定一个<code>netrc</code>文件，如果提供了多个<code>--netrc</code>文件选项，则只使用最后一个选项，(<code>7.21.5</code>增加)此选项会覆盖<code>--netrc</code>的任何用法，因为它们是互斥的，如果指定，它还将遵循<code>--netrc optional</code>。</li><li><code>--netrc-optional</code>: 与<code>--netrc</code>非常相似，但此选项使<code>.netrc</code>的用法成为可选的，而不是像<code>--netrc</code>选项那样是强制性的。</li><li><code>--negotiate</code>: <code>HTTP</code>，启用协商(<code>SPNEGO</code>)身份验证，如果要为代理身份验证启用协商(<code>SPNEGO</code>)，请使用<code>--proxy Negotiate</code>，此选项需要使用<code>GSS-API</code>或<code>SSPI</code>支持构建的库，使用<code>-V, -version</code>查看<code>curl</code>是否支持<code>GSS-API/SSPI</code>和<code>SPNEGO</code>，使用此选项时，还必须提供假<code>-u, -user</code>选项以正确激活身份验证代码，发送<code>-u</code>就足够了，因为实际上没有使用<code>-u</code>选项中的用户名和密码，如果多次使用此选项，则只使用第一个选项。</li><li><code>--no-keepalive</code>: 禁用在<code>TCP</code>连接上使用<code>keepalive</code>消息，因为默认情况下<code>curl</code>会启用它们，请注意，这是已记录的否定选项名称，因此，可以使用<code>--keepalive</code>来强制执行<code>keepalive</code>。</li><li><code>--no-sessionid</code>: <code>SSL</code>，禁用<code>curl</code>对<code>SSL</code>会话<code>ID</code>缓存的使用，默认情况下，所有传输都使用缓存完成，请注意，尽管尝试重用<code>SSL</code>会话<code>id</code>不会对任何事情造成伤害，但在野外似乎存在损坏的<code>SSL</code>实现，可能需要您禁用它才能成功，(在<code>7.16.0</code>中添加)请注意，这是已记录的否定选项名称，因此，您可以使用<code>--sessionid</code>来强制执行会话<code>ID</code>缓存。</li><li><code>--noproxy &lt;no-proxy-list&gt;</code>: 不使用代理(如果指定了代理)的主机的逗号分隔列表，唯一的通配符是一个<code>*</code>字符，它匹配所有主机，并有效地禁用代理，此列表中的每个名称都匹配为包含主机名的域或主机名本身，例如，本地网站将匹配本地网站，<code>7.19.4</code>中增加。</li><li><code>--ntlm</code>: <code>HTTP</code>，启用<code>NTLM</code>身份验证，<code>NTLM</code>身份验证方法是由<code>Microsoft</code>设计的，用于<code>IIS web</code>服务器，它是一个专有的协议，由聪明的人逆向设计，并根据他们的努力在<code>curl</code>中实现，这种行为不应该被认可，您应该鼓励每个使用<code>NTLM</code>的人转而使用公共的和文档化的身份验证方法，比如<code>Digest</code>，如果要为代理身份验证启用<code>NTLM</code>，请使用<code>--proxy NTLM</code>，此选项需要使用<code>SSL</code>支持构建的库，使用<code>-V, -version</code>查看<code>curl</code>是否支持<code>NTLM</code>，如果多次使用此选项，则只使用第一个选项。</li><li><code>-o, --output &lt;file&gt;</code>: 将输出写入<code>&lt;file&gt;</code>而不是标准输出，如果使用<code>&#123;&#125;</code>或<code>[]</code>获取多个文档，则可以在<code>&lt;file&gt;</code>说明符中使用<code>#</code>后跟数字，该变量将替换为正在获取的<code>URL</code>的当前字符串。</li><li><code>-O, --remote-name</code>: 将输出写入名为的本地文件，就像我们得到的远程文件一样，仅使用远程文件的文件部分，路径被切断，用于保存的远程文件名是从给定的<code>URL</code>提取的，而不是从其他<code>URL</code>提取的，因此，文件将保存在当前工作目录中，如果要将文件保存在其他目录中，请确保在使用<code>-O, -remote name</code>标志调用<code>curl</code>之前更改当前工作目录，没有对文件名执行<code>URL</code>解码，如果名称中有%<code>20</code>或其他<code>URL</code>编码的部分，它们将以文件名的形式结束，您可以使用此选项的次数与您拥有的<code>URL</code>数量相同。</li><li><code>--oauth2-bearer</code>: <code>IMAP、POP3、SMTP</code>，指定<code>OAUTH 2.0</code>服务器身份验证的承载令牌，承载令牌与用户名一起使用，用户名可以指定为<code>--url</code>或<code>-u, -user</code>选项的一部分，承载令牌和用户名根据<code>rfc6750</code>格式化，如果多次使用此选项，将使用最后一个选项。</li><li><code>--proxy-header &lt;header&gt;</code>: <code>HTTP</code>，向代理发送<code>HTTP</code>时请求中包含的额外头，您可以指定任意数量的额外标头，这是与<code>-H, -header</code>等效的选项，但仅适用于代理通信，就像在连接请求中一样，当您希望将单独的头发送到代理时，它将发送到实际的远程主机，<code>curl</code>将确保您添加<code>/</code>替换的每个标题都使用正确的行尾标记发送，因此您不应将其添加为标题内容的一部分<code>:</code>不要添加换行符或回车符，它们只会为您带来麻烦，使用此选项指定的头不会包含在<code>curl</code>知道不会发送到代理的请求中，此选项可多次用于添加<code>/</code>替换<code>/</code>删除多个标头，在<code>7.37.0</code>中添加。</li><li><code>-p, --proxytunnel</code>: 当使用<code>HTTP</code>代理(<code>-x, --proxy</code>)时，此选项将导致非<code>HTTP</code>协议尝试通过代理进行隧道传输，而不是仅使用它来执行类似<code>HTTP</code>的操作，隧道方法是通过<code>HTTP</code>代理连接请求来实现的，并且要求代理允许直接连接到<code>curl</code>希望通过隧道连接到的远程端口号。</li><li><code>-P, --ftp-port &lt;address&gt;</code>: <code>FTP</code>，在连接<code>FTP</code>时反转默认的发起程序<code>/</code>侦听程序角色，此开关使<code>curl</code>使用活动模式，在实践中，<code>curl</code>然后告诉服务器连接回客户机指定的地址和端口，而被动模式则要求服务器设置一个<code>IP</code>地址和端口以供连接。</li><li><code>--pass &lt;phrase&gt;</code>: <code>SSL/SSH</code>，私钥的密码短语，如果多次使用此选项，将使用最后一个选项。</li><li><code>--post301</code>: <code>HTTP</code>，告诉<code>curl</code>遵守<code>rfc2616/10.3.2</code>，在执行<code>301</code>重定向时不要将<code>POST</code>请求转换为<code>GET</code>请求，非<code>RFC</code>行为在<code>web</code>浏览器中无处不在，因此<code>curl</code>默认情况下进行转换以保持一致性，然而，服务器可能需要在这样的重定向之后保持<code>POST</code>，此选项仅在使用<code>-L, -location</code>(在<code>7.17.1</code>中添加)时才有意义。</li><li><code>--post302</code>: <code>HTTP</code>，告诉<code>curl</code>遵守<code>rfc2616/10.3.2</code>，在执行<code>302</code>重定向时不要将<code>POST</code>请求转换为<code>GET</code>请求，非<code>RFC</code>行为在<code>web</code>浏览器中无处不在，因此<code>curl</code>默认情况下进行转换以保持一致性，然而，服务器可能需要在这样的重定向之后保持<code>POST</code>，此选项仅在使用<code>-L, -location</code>(在<code>7.19.1</code>中添加)时才有意义。</li><li><code>--post303</code>: <code>HTTP</code>，告诉<code>curl</code>遵守<code>rfc2616/10.3.2</code>，在执行<code>303</code>重定向时不要将<code>POST</code>请求转换为<code>GET</code>请求，非<code>RFC</code>行为在<code>web</code>浏览器中无处不在，因此<code>curl</code>默认情况下进行转换以保持一致性，然而，服务器可能需要在这样的重定向之后保持<code>POST</code>，此选项仅在使用<code>-L, -location</code>(在<code>7.26.0</code>中添加)时才有意义。</li><li><code>--proto &lt;protocols&gt;</code>: 告诉<code>curl</code>使用列出的协议进行初始检索，协议从左到右求值，以逗号分隔，每个协议都是一个协议名或<code>all</code>，可以选择以零个或多个修饰符作为前缀。</li><li><code>--proto-redir &lt;protocols&gt;</code>: 告诉<code>curl</code>在重定向后使用列出的协议，有关协议的表示方式，请参见<code>--proto</code>，(<code>7.20.2</code>增加)。</li><li><code>--proxy-anyauth</code>: 告诉<code>curl</code>在与给定代理通信时选择合适的身份验证方法，这可能会导致额外的请求<code>/</code>响应往返，(<code>7.13.2</code>增加)。</li><li><code>--proxy-basic</code>: 告诉<code>curl</code>在与给定代理通信时使用<code>HTTP</code>基本身份验证，使用<code>--basic</code>对远程主机启用<code>HTTP basic</code>，<code>Basic</code>是<code>curl</code>用于代理的默认身份验证方法。</li><li><code>--proxy-digest</code>: 告诉<code>curl</code>在与给定代理通信时使用<code>HTTP</code>摘要身份验证，使用<code>--digest</code>对远程主机启用<code>HTTP</code>摘要。</li><li><code>--proxy-negotiate</code>: 告诉<code>curl</code>在与给定代理通信时使用<code>HTTP</code>协商(<code>SPNEGO</code>)身份验证，使用<code>--negotiate</code>启用与远程主机的<code>HTTP</code>协商(<code>SPNEGO</code>)，<code>7.17.1</code>增加。</li><li><code>--proxy-ntlm</code>: 告诉<code>curl</code>在与给定代理通信时使用<code>httpntlm</code>身份验证，使用<code>--ntlm</code>启用远程主机的<code>ntlm</code>。</li><li><code>--proxy1.0 &lt;proxyhost[:port]&gt;</code>: 使用指定的<code>HTTP 1.0</code>代理，如果未指定端口号，则假定在端口<code>1080</code>处，此选项与<code>HTTP proxy</code>选项<code>-x, --proxy</code>之间的唯一区别是，尝试通过代理使用<code>CONNECT</code>将指定<code>HTTP 1.0</code>协议，而不是默认的<code>HTTP 1.1</code>。</li><li><code>--pubkey &lt;key&gt;</code>: <code>SSH</code>，公钥文件名，允许您在此单独的文件中提供公钥，如果多次使用此选项，将使用最后一个选项。</li><li><code>-q</code>: 如果用作命令行上的第一个参数，则不会读取和使用<code>curlrc config</code>文件，有关默认配置文件搜索路径的详细信息，请参见<code>-K, --config</code>。</li><li><code>-Q, --quote &lt;command&gt;</code>: <code>FTP/SFTP</code>，向远程<code>FTP</code>或<code>SFTP</code>服务器发送任意命令，<code>Quote</code>命令在传输发生之前发送(确切地说，是在<code>FTP</code>传输中的初始<code>PWD</code>命令之后)，若要使命令在成功传输后执行，请在其前面加一个短划线<code>-</code>，要使命令在<code>curl</code>更改工作目录后发送，就在传输命令之前，在命令前面加上<code>+</code>(这仅适用于<code>FTP</code>)，您可以指定任意数量的命令，如果服务器返回其中一个命令失败，则整个操作将中止，必须按照<code>RFC 959</code>的定义将语法正确的<code>FTP</code>命令发送到<code>FTP</code>服务器，或将下面列出的命令之一发送到<code>SFTP</code>服务器，此选项可以多次使用，在与<code>FTP</code>服务器通信时，在命令前面加一个星号<code>*</code>，使<code>curl</code>即使失败也能继续，因为默认情况下，<code>curl</code>会在第一次失败时停止，<code>SFTP</code>是一种二进制协议，与<code>FTP</code>不同，<code>curl</code>在将<code>SFTP quote</code>命令发送到服务器之前会自己解释它们，文件名可以用<code>shell</code>样式引用以嵌入空格或特殊字符。</li><li><code>-r, --range &lt;range&gt;</code>: <code>HTTP/FTP/SFTP/FILE</code>，从<code>HTTP/1.1</code>、<code>FTP</code>或<code>SFTP</code>服务器或本地文件检索字节范围(即部分文档)，可以通过多种方式指定范围。</li><li><code>-R, --remote-time</code>: 使用时，这将使<code>curl</code>尝试找出远程文件的时间戳，如果该时间戳可用，则使本地文件获得相同的时间戳。</li><li><code>--random-file &lt;file&gt;</code>: <code>SSL</code>，指定包含随机数据的文件的路径名，数据用于为<code>SSL</code>连接的随机引擎播种，另请参见<code>--egd</code>文件选项。</li><li><code>--raw</code>: <code>HTTP</code>，使用时，它会禁用所有内容或传输编码的内部<code>HTTP</code>解码，而是让它们原封不动地传递，<code>7.16.2</code>增加。</li><li><code>--remote-name-all</code>: 此选项将更改所有给定<code>URL</code>的默认操作，使其处理方式与每个<code>URL</code>使用<code>-O</code>、<code>-remote name</code>一样，因此，如果要在使用<code>--remote name all</code>之后对特定<code>URL</code>禁用该选项，则必须使用<code>-o-</code>或<code>--no remote name</code>，在<code>7.19.0</code>中添加。</li><li><code>--resolve &lt;host:port:address&gt;</code>: 为特定主机和端口对提供自定义地址，使用此方法，可以使<code>curl</code>请求使用指定的地址，并防止使用通常解析的地址，将其视为命令行上提供的一种<code>/etc/hosts</code>替代方案，端口号应该是用于主机将用于的特定协议的编号，这意味着，如果要为同一主机提供不同端口的地址，则需要多个条目，可以多次使用此选项添加许多要解析的主机名，在<code>7.21.3</code>增加。</li><li><code>--retry &lt;num&gt;</code>: 如果<code>curl</code>尝试执行传输时返回暂时性错误，它将在放弃之前重试此次数，将数字设置为<code>0</code>将使<code>curl</code>不重试(这是默认值)，瞬时错误表示<code>:</code>超时、<code>ftp4xx</code>响应代码或<code>http5xx</code>响应代码，当<code>curl</code>将要重试传输时，它将首先等待一秒钟，然后对于所有即将进行的重试，它将加倍等待时间，直到达到<code>10</code>分钟，这将是其余重试之间的延迟，通过使用<code>--retry delay</code>可以禁用这个指数退避算法，另请参见<code>--retry max time</code>以限制允许重试的总时间，(<code>7.12.3</code>增加)如果多次使用此选项，将使用最后一个选项。</li><li><code>--retry-delay &lt;seconds&gt;</code>: 当传输因暂时性错误而失败时，在每次重试之前使<code>curl</code>休眠此时间量(它会更改重试之间的默认退避时间算法)，只有同时使用<code>--retry</code>时，此选项才有意义，将此延迟设置为零将使<code>curl</code>使用默认回退时间，(<code>7.12.3</code>增加)如果多次使用此选项，将使用最后一个选项。</li><li><code>--retry-max-time &lt;seconds&gt;</code>: 重试计时器在第一次传输尝试之前重置，只要计时器没有达到这个给定的限制，重试就会照常进行(请参阅<code>--retry</code>)，请注意，如果计时器尚未达到限制，则会发出请求，并且在执行时，可能需要比给定的时间段更长的时间，要限制单个请求的最长时间，请使用<code>-m, -max time</code>，将此选项设置为零以不超时重试，(<code>7.12.3</code>增加)如果多次使用此选项，将使用最后一个选项。</li><li><code>-s, --silent</code>: 安静或安静模式，不显示进度表或错误消息，使卷发静音，它仍然会输出您请求的数据，甚至可能输出到终端<code>/stdout</code>，除非您重定向它。</li><li><code>--sasl-ir</code>: 在<code>SASL</code>身份验证中启用初始响应，在<code>7.31.0</code>增加。</li><li><code>-S, --show-error</code>: 当与<code>-s</code>一起使用时，如果<code>curl</code>失败，它将显示一条错误消息。</li><li><code>--ssl</code>: <code>FTP, POP3, IMAP, SMTP</code>，尝试使用<code>SSL/TLS</code>进行连接，如果服务器不支持<code>SSL/TLS</code>，则还原为非安全连接，另请参见<code>--ftp ssl control</code>和<code>--ssl reqd</code>以了解所需的不同加密级别，(在<code>7.20.0</code>中添加)此选项以前称为<code>--ftp ssl</code>(在<code>7.11.0</code>中添加)，该选项名称仍可以使用，但将在将来的版本中删除。</li><li><code>--ssl-reqd</code>: <code>FTP, POP3, IMAP, SMTP</code>，连接需要<code>SSL/TLS</code>，如果服务器不支持<code>SSL/TLS</code>，则终止连接，(在<code>7.20.0</code>中添加)此选项以前称为<code>--ftp ssl reqd</code>(在<code>7.15.5</code>中添加)，该选项名称仍可以使用，但将在将来的版本中删除。</li><li><code>--ssl-allow-beast</code>: <code>SSL</code>，此选项告诉<code>curl</code>不要绕过<code>SSL3</code>和<code>TLS1.0</code>协议中称为<code>BEAST</code>的安全缺陷，如果不使用此选项，<code>SSL</code>层可能会使用已知的解决方法来解决某些较旧的<code>SSL</code>实现的互操作性问题，警告<code>:</code>此选项会降低<code>SSL</code>安全性，通过使用此标志，您会要求完全相同的安全性，在<code>7.25.0</code>中添加。</li><li><code>--socks4 &lt;host[:port]&gt;</code>: 使用指定的<code>SOCKS4</code>代理，如果未指定端口号，则假定在端口<code>1080</code>处，(<code>7.15.2</code>增加)此选项将覆盖以前使用的任何<code>-x, --proxy</code>，因为它们是互斥的，从<code>7.21.7</code>开始，此选项是多余的，因为您可以使用<code>socks4://</code>协议前缀指定具有<code>-x, --proxy</code>的<code>socks4</code>代理，如果多次使用此选项，将使用最后一个选项。</li><li><code>--socks4a &lt;host[:port]&gt;</code>: 使用指定的<code>SOCKS4a</code>代理，如果未指定端口号，则假定在端口<code>1080</code>处，(在<code>7.18.0</code>中添加)此选项将覆盖以前使用的任何<code>-x, --proxy</code>，因为它们是互斥的，从<code>7.21.7</code>开始，此选项是多余的，因为您可以使用<code>socks4a://</code>协议前缀指定具有<code>-x, -proxy</code>的<code>socks4a</code>代理，如果多次使用此选项，将使用最后一个选项。</li><li><code>--socks5-hostname &lt;host[:port]&gt;</code>: 使用指定的<code>SOCKS5</code>代理(并让代理解析主机名)，如果未指定端口号，则假定在端口<code>1080</code>处，(在<code>7.18.0</code>中添加)此选项将覆盖以前使用的任何<code>-x, --proxy</code>，因为它们是互斥的，从<code>7.21.7</code>开始，此选项是多余的，因为您可以使用<code>socks5h://</code>协议前缀指定带有<code>-x, -proxy</code>的<code>socks5</code>主机名代理，如果多次使用此选项，将使用最后一个选项，(此选项以前被错误地记录并用作<code>--socks</code>，但没有附加数字)。</li><li><code>--socks5 &lt;host[:port]&gt;</code>: 使用指定的<code>SOCKS5</code>代理<code>-</code>但在本地解析主机名，如果未指定端口号，则假定在端口<code>1080</code>处，此选项将覆盖以前使用的任何<code>-x, --proxy</code>，因为它们是互斥的，从<code>7.21.7</code>开始，此选项是多余的，因为您可以使用<code>socks5://</code>协议前缀指定带有<code>-x, -proxy</code>的<code>socks5</code>代理，如果多次使用此选项，将使用最后一个选项，(此选项以前被错误地记录并用作<code>--socks</code>，但没有附加数字)，此选项(以及<code>--socks4</code>)不适用于<code>IPV6</code>、<code>FTPS</code>或<code>LDAP</code>。</li><li><code>--socks5-gssapi-service &lt;servicename&gt;</code>: <code>socks</code>服务器的默认服务名称是<code>rcmd/server fqdn</code>，此选项允许您更改它，示例<code>: ---socks5 proxy name--socks5 gssapi service sockd</code>将使用<code>sockd/proxy name--socks5 proxy name--socks5 gssapi service sockd/real name</code>将在代理名称与主体名称不匹配的情况下使用<code>sockd/real name</code>，在<code>7.19.4</code>中增加。</li><li><code>--socks5-gssapi-nec</code>: 作为<code>GSS-API</code>协商的一部分，将协商保护模式，<code>RFC1961</code>在第<code>4.3/4.4</code>节中说它应该受到保护，但<code>NEC</code>参考实施没有，选项<code>--socks5 gssapi nec</code>允许保护模式协商的无保护交换，在<code>7.19.4</code>中增加。</li><li><code>--stderr &lt;file&gt;</code>: 将对<code>stderr</code>的所有写入重定向到指定的文件，如果文件名是一个普通的<code>-</code>，则改为写入标准输出，如果多次使用此选项，将使用最后一个选项。</li><li><code>-t, --telnet-option &lt;OPT=val&gt;</code>: 将选项传递给<code>telnet</code>协议，支持的选项包括<code>: TTYPE=&lt;term&gt;</code>设置终端类型，<code>XDISPLOC=&lt;X display&gt;</code>设置<code>X</code>显示位置，<code>NEW_ENV=&lt;var, val&gt;</code>设置环境变量。</li><li><code>-T, --upload-file &lt;file&gt;</code>: 这会将指定的本地文件传输到远程<code>URL</code>，如果指定的<code>URL</code>中没有文件部分，<code>curl</code>将附加本地文件名，请注意，您必须在最后一个目录上使用尾随<code>/</code>来真正证明<code>curl</code>没有文件名，否则<code>curl</code>会认为您的最后一个目录名是要使用的远程文件名，这很可能会导致上载操作失败，如果在<code>HTTP</code>(<code>S</code>)服务器上使用，则将使用<code>PUT</code>命令，使用文件名<code>-</code>来使用<code>stdin</code>而不是给定的文件，或者，可以指定文件名<code>.</code>(单个句点)而不是<code>-</code>，以便在非阻塞模式下使用<code>stdin</code>，以便在上载<code>stdin</code>时读取服务器输出。</li><li><code>--tcp-nodelay</code>: 打开<code>TCP_NODELAY</code>选项，有关此选项的详细信息，请参阅<code>curl_easy_setopt</code>手册页，在<code>7.11.2</code>增加。</li><li><code>--tftp-blksize &lt;value&gt;</code>: <code>TFTP</code>，设置<code>TFTP BLKSIZE</code>选项(必须大于<code>512</code>)，这是<code>curl</code>在向<code>TFTP</code>服务器传输数据或从<code>TFTP</code>服务器传输数据时尝试使用的块大小，默认情况下，将使用<code>512</code>字节，如果多次使用此选项，将使用最后一个选项，在<code>7.20.0</code>中添加。</li><li><code>--tlsauthtype &lt;authtype&gt;</code>: 设置<code>TLS</code>身份验证类型，目前，<code>TLS-SRP</code>(<code>RFC 5054</code>)唯一支持的选项是<code>SRP</code>，如果指定了<code>--tlsuser</code>和<code>--tlspassword</code>，但未指定<code>--tlsauthtype</code>，则此选项默认为<code>SRP</code>，在<code>7.21.4</code>增加。</li><li><code>--tlspassword &lt;password&gt;</code>: 设置密码以用于用<code>--tlsauthtype</code>指定的<code>TLS</code>身份验证方法，要求同时设置<code>--tlsuser</code>，在<code>7.21.4</code>增加。</li><li><code>--tlsuser &lt;user&gt;</code>: 设置用户名以便与用<code>--tlsauthtype</code>指定的<code>TLS</code>身份验证方法一起使用，要求同时设置<code>--tlspassword</code>，在<code>7.21.4</code>增加。</li><li><code>--tlsv1.0</code>: <code>SSL</code>，强制<code>curl</code>在与远程<code>TLS</code>服务器协商时使用<code>TLS</code>版本<code>1.0</code>，在<code>7.34.0</code>中添加。</li><li><code>--tlsv1.1</code>: <code>SSL</code>，强制<code>curl</code>在与远程<code>TLS</code>服务器协商时使用<code>TLS</code>版本<code>1.1</code>，在<code>7.34.0</code>中添加。</li><li><code>--tlsv1.2</code>: <code>SSL</code>，强制<code>curl</code>在与远程<code>TLS</code>服务器协商时使用<code>TLS</code>版本<code>1.2</code>，在<code>7.34.0</code>中添加。</li><li><code>--tr-encoding</code>: <code>HTTP</code>，使用<code>curl</code>支持的算法之一请求压缩传输编码响应，并在接收数据时解压缩数据，在<code>7.21.6</code>增加。</li><li><code>--trace &lt;file&gt;</code>: 启用所有传入和传出数据(包括描述性信息)到给定输出文件的完整跟踪转储，使用<code>-</code>作为文件名将输出发送到<code>stdout</code>，此选项覆盖以前使用的<code>-v, -verbose</code>或<code>-trace ascii</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--trace-ascii &lt;file&gt;</code>: 启用所有传入和传出数据(包括描述性信息)到给定输出文件的完整跟踪转储，使用<code>-</code>作为文件名将输出发送到<code>stdout</code>，这与<code>--trace</code>非常相似，但是省略了十六进制部分，只显示转储的<code>ASCII</code>部分，它使较小的输出，可能更容易阅读未经训练的人，此选项覆盖以前使用的<code>-v</code>、<code>-verbose</code>或<code>-trace</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--trace-time</code>: 为<code>curl</code>显示的每个跟踪或详细行预先准备一个时间戳，在<code>7.14.0</code>中添加。</li><li><code>-u, --user &lt;user:password&gt;</code>: 指定用于服务器身份验证的用户名和密码，重写<code>-n</code>、<code>-netrc</code>和<code>--netrc</code>可选，如果只指定用户名，<code>curl</code>将提示输入密码，用户名和密码在第一个冒号上分开，这样就不可能在用户名中使用带有此选项的冒号，密码仍然可以，将<code>Kerberos V5</code>与基于<code>Windows</code>的服务器一起使用时，应在用户名中包含<code>Windows</code>域名，以便服务器成功获取<code>Kerberos</code>票证，如果不这样做，那么初始身份验证握手可能会失败，当使用<code>NTLM</code>时，可以简单地将用户名指定为用户名，而不指定域。</li><li><code>-U, --proxy-user &lt;user:password&gt;</code>: 指定用于代理身份验证的用户名和密码，如果您使用启用了<code>Windows SSPI</code>的<code>curl</code>二进制文件并进行协商或<code>NTLM</code>身份验证，那么您可以通过指定一个冒号来告诉<code>curl</code>从您的环境中选择用户名和密码，该冒号带有以下选项:<code>-U</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>--url &lt;URL&gt;</code>: 指定要获取的<code>URL</code>，当您要在配置文件中指定<code>URL</code>时，此选项非常方便，此选项可以使用任意次数，要控制此<code>URL</code>的写入位置，请使用<code>-o, --output</code>或<code>-o, --remote name</code>选项。</li><li><code>-v, --verbose</code>: 输出详细信息，主要用于调试，以<code>&gt;</code>开头的行表示<code>curl</code>发送的头数据，<code>&lt;</code>表示<code>curl</code>接收的在正常情况下隐藏的头数据，以*开头的行表示<code>curl</code>提供的附加信息，请注意，如果您只希望在输出中使用<code>HTTP</code>头，那么您可能需要<code>-i, -include</code>选项，如果您认为此选项仍然不能提供足够的详细信息，请考虑改用<code>--trace</code>或<code>--trace ascii</code>，此选项覆盖以前使用的<code>--trace ascii</code>或<code>--trace</code>，使用<code>-s, --silent</code>使<code>curl</code>安静。</li><li><code>-w, --write-out &lt;format&gt;</code>: 定义操作完成并成功后在标准输出上显示的内容，格式是一个字符串，可以包含纯文本和任意数量的变量，字符串可以指定为<code>string</code>，要从特定文件中读取，您可以将其指定为<code>@filename</code>，并告诉<code>curl</code>从<code>stdin</code>中读取格式，您可以编写<code>@-</code>，输出格式中的变量将被<code>curl</code>认为合适的值或文本替换，如下所述，所有变量都指定为%<code>&#123;variable_name&#125;</code>，要输出一个普通的%只需将它们写为%%，您可以使用<code>\n</code>、带<code>\r</code>的回车符和带<code>\t</code>的制表符来输出换行符，可能的值为<code>content_type</code>、<code>filename_effective</code>、<code>ftp_entry_path</code>、<code>http_code</code>、<code>http_connect</code>、<code>local_ip</code>、<code>local_port</code>、<code>num_connects</code>、<code>num_redirects</code>、<code>redirect_url</code>、<code>remote_ip</code>、<code>remote_port</code>、<code>size_download</code>、<code>size_header</code>、<code>size_request</code>、<code>size_upload</code>、<code>speed_download</code>、<code>speed_upload</code>、<code>ssl_verify_result</code>、<code>time_appconnect</code>、<code>time_connect</code>、<code>time_namelookup</code>、<code>time_pretransfer</code>、<code>time_redirect</code>、<code>time_starttransfer</code>、<code>time_total</code>、<code>url_effective</code>。</li><li><code>-x, --proxy &lt;[protocol://][user:password@]proxyhost[:port]&gt;</code>: 使用指定的代理，可以使用<code>protocol://</code>前缀指定代理字符串，以指定备用代理协议，使用<code>socks4://</code>、<code>socks4a://</code>、<code>socks5://</code>或<code>socks5h://</code>请求要使用的特定<code>SOCKS</code>版本，没有指定协议，<code>http://</code>和所有其他协议都将被视为<code>http</code>代理，(在<code>curl7.21.7</code>中添加了协议支持)如果代理字符串中未指定端口号，则假定端口号为<code>1080</code>，此选项将覆盖将代理设置为使用的现有环境变量，如果有环境变量设置代理，则可以将代理设置为以覆盖它，通过<code>HTTP</code>代理执行的所有操作都将透明地转换为<code>HTTP</code>，这意味着某些特定于协议的操作可能不可用，如果您可以通过代理进行隧道传输(如使用<code>-p</code>、<code>-proxytunnel</code>选项时)，则情况并非如此，代理字符串中可能提供的用户和密码由<code>curl</code>进行<code>URL</code>解码，这允许您通过使用<code>%40</code>传入特殊字符，如<code>@</code>，或用<code>%3a</code>传入冒号，可以使用与代理环境变量完全相同的方式指定代理主机，包括协议前缀(<code>http://</code>)和嵌入的用户<code>+</code>密码，如果多次使用此选项，将使用最后一个选项。</li><li><code>-X, --request &lt;command&gt;</code>: <code>HTTP</code>，指定与<code>HTTP</code>服务器通信时要使用的自定义请求方法，将使用指定的请求，而不是使用其他方法(默认为<code>GET</code>)，有关详细信息和解释，请阅读<code>HTTP1.1</code>规范，常见的附加<code>HTTP</code>请求包括<code>PUT</code>和<code>DELETE</code>，但<code>WebDAV</code>等相关技术提供了<code>PROPFIND</code>、<code>COPY</code>、<code>MOVE</code>等功能，通常你不需要这个选项，各种<code>GET</code>、<code>HEAD</code>、<code>POST</code>和<code>PUT</code>请求都是通过使用专用的命令行选项来调用的，此选项仅更改<code>HTTP</code>请求中使用的实际单词，不改变<code>curl</code>的行为方式，因此，例如，如果您想要发出一个正确的<code>HEAD</code>请求，那么使用<code>-X HEAD</code>将是不够的，你需要使用<code>-I, -head</code>选项。</li><li><code>--xattr</code>: 将输出保存到文件时，此选项告诉<code>curl</code>将某些文件元数据存储在扩展文件属性中，当前，<code>URL</code>存储在<code>xdg.origin.url</code>属性，对于<code>HTTP</code>，内容类型存储在<code>mime</code>类型属性中，如果文件系统不支持扩展属性，将发出警告。</li><li><code>-y, --speed-time &lt;time&gt;</code>: 如果在某个速度时间段内下载速度低于每秒的速度限制字节数，则下载将被中止，如果使用速度时间，则默认速度限制将为<code>1</code>，除非使用<code>-Y</code>设置，此选项控制传输，因此不会影响慢速连接等，如果您担心此问题，请尝试<code>--connect timeout</code>选项，如果多次使用此选项，将使用最后一个选项。</li><li><code>-Y, --speed-limit &lt;speed&gt;</code>: 如果下载速度低于此给定速度(以字节<code>/</code>秒为单位)达数秒，则会中止下载，速度时间设置为<code>-y</code>，如果未设置，则为<code>30</code>，如果多次使用此选项，将使用最后一个选项。</li><li><code>-z, --time-cond &lt;date expression&gt;|&lt;file&gt;</code>: (<code>HTTP/FTP</code>)请求在给定的时间和日期之后修改的文件，或在该时间之前修改的文件，<code>&lt;date expression&gt;</code>可以是各种日期字符串，或者如果它与任何内部字符串都不匹配，则将其作为文件名并尝试从<code>&lt;file&gt;</code>获取修改日期<code>mtime</code>，有关日期表达式的详细信息，请参阅<code>getdate</code>手册页，以破折号<code>-</code>开始日期表达式，使其请求比给定日期<code>/</code>时间早的文档，默认值是比指定日期<code>/</code>时间新的文档，如果多次使用此选项，将使用最后一个选项。</li><li><code>-h, --help</code>: 输出帮助信息。</li><li><code>-M, --manual</code>: 手动模式，显示详细的帮助文本。</li><li><code>-V, --version</code>: 输出版本信息。</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>使用环境变量设置代理与使用<code>--proxy</code>选项具有相同的效果。</p><ul><li><code>http_proxy [protocol://]&lt;host&gt;[:port]</code>: 设置用于<code>HTTP</code>的代理服务器。</li><li><code>HTTPS_PROXY [protocol://]&lt;host&gt;[:port]</code>: 设置用于<code>HTTPS</code>的代理服务器。</li><li><code>[url-protocol]_PROXY [protocol://]&lt;host&gt;[:port]</code>: 设置要用于<code>[url protocol]</code>的代理服务器，其中协议是<code>curl</code>支持的协议，并在<code>url</code>中指定，<code>FTP</code>、<code>FTPS</code>、<code>POP3</code>、<code>IMAP</code>、<code>SMTP</code>、<code>LDAP</code>等。</li><li><code>ALL_PROXY [protocol://]&lt;host&gt;[:port]</code>: 如果未设置协议特定的代理，则设置要使用的代理服务器。</li><li><code>NO_PROXY &lt;comma-separated list of hosts&gt;</code>: 不应通过任何代理的主机名列表，如果仅设置为星号<code>*</code>，则与所有主机匹配。</li></ul><h2 id="代理协议前缀"><a href="#代理协议前缀" class="headerlink" title="代理协议前缀"></a>代理协议前缀</h2><ul><li><code>socks4://</code>: 使其等效于<code>--socks4</code>。</li><li><code>socks4a://</code>: 使其相当于<code>--socks4a</code>。</li><li><code>socks5://</code>: 使其相当于<code>--socks5</code>。</li><li><code>socks5h://</code>: 使其相当于<code>--socks5-hostname</code>。</li></ul><h2 id="退出代码"><a href="#退出代码" class="headerlink" title="退出代码"></a>退出代码</h2><ul><li><code>1</code>: 不支持的协议，<code>curl</code>的这个版本不支持这个协议。</li><li><code>2</code>: 初始化失败。</li><li><code>3</code>: <code>URL</code>格式不正确，语法不正确。</li><li><code>4</code>: 执行所需请求所需的功能或选项在生成时未启用或显式禁用，要使<code>curl</code>能够做到这一点，您可能需要另一个<code>libcurl</code>构建。</li><li><code>5</code>: 无法解析代理，无法解析给定的代理主机。</li><li><code>6</code>: 无法解析主机，未解析给定的远程主机。</li><li><code>7</code>: 无法连接到主机。</li><li><code>8</code>: <code>FTP</code>服务器回复，服务器发送的数据无法解析。</li><li><code>9</code>: <code>FTP</code>访问被拒绝，服务器拒绝登录或拒绝访问您要访问的特定资源或目录，通常，您试图更改到服务器上不存在的目录。</li><li><code>11</code>: 通过回复，<code>curl</code>无法分析发送给<code>PASS</code>请求的回复。</li><li><code>13</code>: <code>FTP</code>奇怪的<code>PASV</code>回复，<code>curl</code>无法解析发送到<code>PASV</code>请求的回复。</li><li><code>14</code>: <code>FTP-227</code>格式，<code>curl</code>无法解析服务器发送的<code>227</code>行。</li><li><code>15</code>: <code>FTP</code>无法获取主机，无法解析<code>227</code>行中的主机<code>IP</code>。</li><li><code>17</code>: <code>FTP</code>无法设置二进制文件，无法将传输方法更改为二进制。</li><li><code>18</code>: 部分文件，只传输了文件的一部分。</li><li><code>19</code>: <code>FTP</code>无法下载<code>/</code>访问给定文件，<code>RETR</code>(或类似)命令失败。</li><li><code>21</code>: <code>FTP</code>报价错误，<code>quote</code>命令从服务器返回错误。</li><li><code>22</code>: 未检索到<code>HTTP</code>页，找不到请求的<code>url</code>或返回另一个错误，<code>HTTP</code>错误代码为<code>400</code>或更高，此返回代码仅在使用<code>-f, -fail</code>时出现。</li><li><code>23</code>: 写入错误，<code>curl</code>无法将数据写入本地文件系统或类似文件系统。</li><li><code>25</code>: <code>FTP</code>无法保存文件，服务器拒绝了用于<code>FTP</code>上载的<code>STOR</code>操作。</li><li><code>26</code>: 读取错误，各种各样的阅读问题。</li><li><code>27</code>: 内存不足，内存分配请求失败。</li><li><code>28</code>: 操作超时，已根据条件达到指定的超时期限。</li><li><code>30</code>: <code>FTP</code>端口失败，端口命令失败，并非所有<code>FTP</code>服务器都支持<code>PORT</code>命令，请尝试使用<code>PASV</code>进行传输。</li><li><code>31</code>: <code>FTP</code>无法使用<code>REST</code>，<code>REST</code>命令失败，此命令用于恢复<code>FTP</code>传输。</li><li><code>33</code>: <code>HTTP</code>范围错误，范围命令不起作用。</li><li><code>34</code>: <code>HTTP post</code>错误，内部<code>post</code>请求生成错误。</li><li><code>35</code>: <code>SSL</code>连接错误，<code>SSL</code>握手失败。</li><li><code>36</code>: <code>FTP</code>错误下载恢复，无法继续先前中止的下载。</li><li><code>37</code>: <code>FILE</code>无法读取文件，无法打开文件，可能是权限问题。</li><li><code>38</code>: <code>LDAP</code>无法绑定，<code>LDAP</code>绑定操作失败。</li><li><code>39</code>: <code>LDAP</code>搜索失败。</li><li><code>41</code>: 未找到函数，找不到所需的<code>LDAP</code>函数。</li><li><code>42</code>: 被回调中止，一个应用程序告诉<code>curl</code>中止操作。</li><li><code>43</code>: 内部错误，使用错误的参数调用了函数。</li><li><code>45</code>: 接口错误，无法使用指定的传出接口。</li><li><code>47</code>: 重定向过多，跟随重定向时，<code>curl</code>达到最大数量。</li><li><code>48</code>: 为<code>libcurl</code>指定了未知选项，这表示您向<code>curl</code>传递了一个奇怪的选项，该选项被传递给<code>libcurl</code>并被拒绝，仔细阅读手册。</li><li><code>49</code>: <code>telnet</code>选项格式错误。</li><li><code>51</code>: 对等方的<code>SSL</code>证书或<code>SSH MD5</code>指纹不正常。</li><li><code>52</code>: 服务器没有回复任何内容，这被认为是一个错误。</li><li><code>53</code>: 找不到<code>SSL</code>加密引擎。</li><li><code>54</code>: 无法将<code>SSL</code>加密引擎设置为默认值。</li><li><code>55</code>: 发送网络数据失败。</li><li><code>56</code>: 接收网络数据失败。</li><li><code>58</code>: 本地证书有问题。</li><li><code>59</code>: 无法使用指定的<code>SSL</code>密码。</li><li><code>60</code>: 对等证书不能用已知的<code>CA</code>证书进行身份验证。</li><li><code>61</code>: 无法识别的传输编码。</li><li><code>62</code>: <code>LDAP URL</code>无效。</li><li><code>63</code>: 超过最大文件大小。</li><li><code>64</code>: 请求的<code>FTP SSL</code>级别失败。</li><li><code>65</code>: 发送数据需要倒带失败。</li><li><code>66</code>: 无法初始化<code>SSL</code>引擎。</li><li><code>67</code>: 用户名、密码或类似内容未被接受，<code>curl</code>无法登录。</li><li><code>68</code>: 在<code>TFTP</code>服务器上找不到文件。</li><li><code>69</code>: <code>TFTP</code>服务器上的权限问题。</li><li><code>70</code>: <code>TFTP</code>服务器上的磁盘空间不足。</li><li><code>71</code>: <code>TFTP</code>操作非法。</li><li><code>72</code>: 未知的<code>TFTP</code>传输<code>ID</code>。</li><li><code>73</code>: 文件已存在<code>TFTP</code>。</li><li><code>74</code>: 没有这样的用户<code>TFTP</code>。</li><li><code>75</code>: 字符转换失败。</li><li><code>76</code>: 需要字符转换函数。</li><li><code>77</code>: 读取<code>SSL CA</code>证书(路径)时出现问题，可能是访问权限问题。</li><li><code>78</code>: <code>URL</code>中引用的资源不存在。</li><li><code>79</code>: <code>SSH</code>会话期间发生未指定的错误。</li><li><code>80</code>: 无法关闭<code>SSL</code>连接。</li><li><code>82</code>: 无法加载<code>CRL</code>文件，缺少或格式错误，在<code>7.19.0</code>中添加。</li><li><code>83</code>: 发卡机构检查失败，在<code>7.19.0</code>中添加。</li><li><code>84</code>: <code>FTP PRET</code>命令失败。</li><li><code>85</code>: <code>RTSP:CSeq</code>编号不匹配。</li><li><code>86</code>: <code>RTSP</code>会话标识符不匹配。</li><li><code>87</code>: 无法解析<code>FTP</code>文件列表。</li><li><code>88</code>: <code>FTP</code>区块回调报告错误。</li><li><code>89</code>: 没有可用的连接，会话将排队。</li><li><code>XX</code>: 更多的错误代码将出现在这里，在未来的版本，现有的是永远不会改变的。</li></ul><h2 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h2><p>对网站发起一个<code>HTTP</code>请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.baidu.com</span><br></pre></td></tr></table></figure><p>使<code>curl</code>显示进度表，以指示传输速率、传输的数据量、剩余时间等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -# -o ftp://ftp.example.com/file.zip</span><br></pre></td></tr></table></figure><p>指定请求的网络接口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --interface ppp0 192.168.113.131</span><br></pre></td></tr></table></figure><p>将文件下载到本地并命名为<code>1.zip</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o 1.zip ftp://ftp.example.com/file.zip</span><br></pre></td></tr></table></figure><p>让<code>curl</code>使用地址重定向。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://www.google.com</span><br></pre></td></tr></table></figure><p>此选项限制数据传输速率的上限，并将其保持在以字节为单位的给定值附近。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --limit-rate 1000K -O ftp://speedtest.tele2.net/1MB.zip</span><br></pre></td></tr></table></figure><p><code>curl</code>还提供了从用户认证的<code>FTP</code>服务器下载文件的选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u username:password -O ftp://test.rebex.net/readme.txt</span><br></pre></td></tr></table></figure><p>显示详细信息，例如连接的<code>ip</code>地址、请求头与响应头等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure><p>设置请求头信息，此处由于响应信息过多将其存储在<code>baidu.html</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -v \</span><br><span class="line">-H &quot;Accept-Language: zh-cn&quot; \</span><br><span class="line">-H &quot;Host: www.baidu.com&quot; \</span><br><span class="line">-H &quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&quot; \</span><br><span class="line">-o baidu.html https://www.baidu.com</span><br></pre></td></tr></table></figure><h1 id="csplit命令"><a href="#csplit命令" class="headerlink" title="csplit命令"></a>csplit命令</h1><p><code>csplit</code>命令将用<code>PATTERN</code>分隔的<code>FILE</code>文件输出到文件<code>xx00</code>、<code>xx01</code>、<code>...</code>，并将每个文件的字节数输出到标准输出。</p><h2 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csplit [OPTION]... FILE PATTERN...</span><br></pre></td></tr></table></figure><h2 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --suffix-format=FORMAT</code>: 使用<code>sprintf FORMAT</code>格式而不是<code>%02d</code>。</li><li><code>-f, --prefix=PREFIX</code>: 使用<code>PREFIX</code>代替<code>xx</code>。</li><li><code>-k, --keep-files</code>: 出错时不要删除输出文件。</li><li><code>-m, --suppress-matched</code>: 取消匹配<code>PATTERN</code>的行。</li><li><code>-n, --digits=DIGITS</code>: 使用指定的数字位数，而不是<code>2</code>。</li><li><code>-s, --quiet, --silent</code>: 不要打印输出文件大小的计数。</li><li><code>-z, --elide-empty-files</code>: 删除空输出文件。</li><li><code>--help</code>: 输出帮助信息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>如果文件被指定为破折号<code>-</code>，<code>csplit</code>将读取标准输入，每种模式可能是：</p><ul><li><code>INTEGER</code>: 复制到指定行号，但不包括指定行号。</li><li><code>/REGEXP/[OFFSET]</code>: 复制到但不包括匹配行。</li><li><code>%REGEXP%[OFFSET]</code>: 跳至但不包括匹配行。</li><li><code>&#123;INTEGER&#125;</code>: 重复上一个模式指定的次数。</li><li><code>&#123;*&#125;</code>: 尽可能多次重复前面的模式。</li></ul><h2 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h2><p><code>list.txt</code>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Apples</span><br><span class="line">2. Bananas</span><br><span class="line">3. Oranges</span><br><span class="line">4. Pineapples</span><br><span class="line">5. Guava</span><br></pre></td></tr></table></figure><p>使用<code>csplit</code>命令将此文件分为两部分，第二部分从第三行开始。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">csplit list.txt 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">21</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">34</span></span><br><span class="line"></span><br><span class="line">cat xx00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. Apples</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. Bananas</span></span><br><span class="line"></span><br><span class="line">cat xx01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. Oranges</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. Pineapples</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. Guava</span></span><br></pre></td></tr></table></figure><p>使用<code>csplit</code>命令将此文件分为三部分。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">csplit list.txt 2 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">21</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">34</span></span><br><span class="line"></span><br><span class="line">cat xx00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. Apples</span></span><br><span class="line"></span><br><span class="line">cat xx01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. Bananas</span></span><br><span class="line"></span><br><span class="line">cat xx02</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. Oranges</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. Pineapples</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. Guava</span></span><br></pre></td></tr></table></figure><p>使用自定义的分割前缀<code>aa</code>代替<code>xx</code>分割前缀。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csplit list.txt -f aa 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">21</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">34</span></span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">aa00  aa01 list.txt</span></span><br></pre></td></tr></table></figure><p>使用三位数字代替默认的两位数字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csplit list.txt -n 3 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">21</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">34</span></span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list.txt  xx000  xx001</span></span><br></pre></td></tr></table></figure><p>使用模式定义分割规则，重复上一个模式指定的次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csplit list.txt 2 &#123;1&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">22</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">23</span></span><br><span class="line"></span><br><span class="line">ls xx*</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xx00  xx01  xx02</span></span><br></pre></td></tr></table></figure><h1 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h1><p> <code>cp</code>命令主要用于复制文件或目录。</p><h2 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp [OPTION]... [-T] SOURCE DEST</span><br><span class="line">cp [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">cp [OPTION]... -t DIRECTORY SOURCE...</span><br></pre></td></tr></table></figure><h2 id="参数-19"><a href="#参数-19" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-a, --archive</code>: 与<code>-dR --preserve = ALL</code>相同，执行复制时，尝试保留尽可能多的原始文件结构，属性和关联的元数据。</li><li><code>--attributes-only</code>: 不复制文件数据，仅创建具有相同属性的文件，如果目标文件已经存在，不更改其内容，并且可以使用<code>--preserve</code>选项精确控制要复制的属性。</li><li><code>--backup[=CONTROL]</code>: 对每个现有目标文件进行备份，否则将被覆盖或删除，该控制参数<code>CONTROL</code>指定了版本控制的方法来使用：<code>none, off</code>，不进行备份；<code>numbered, t</code>，进行编号备份；<code>existing, nil</code>，简单的说明编号是否存在编号备份；<code>simple, never</code>， 始终进行简单的备份。有一种特殊情况，当<code>source</code>和<code>dest</code>是相同的常规文件时，<code>cp --force --backup</code>将对源进行备份。</li><li><code>-b</code>: 类似于<code>--backup</code>，但不接受控制参数，始终使用默认的控制方法。</li><li><code>--copy-contents</code>: 递归操作时，复制特殊文件的内容，例如<code>FIFO</code>和<code>/dev</code>中的设备，通常适用于专业用途。</li><li><code>-d</code>: 复制符号链接本身而不是它们引用的文件，并保留副本中源文件之间的硬链接，与<code>--no-dereference --preserve = links</code>相同。</li><li><code>-f, --force</code>: 如果无法打开现有的目标文件，将其删除，然后重试。如果使用<code>n / --no-clobber</code>选项，则此选项无效，但是其独立于<code>-i / --interactive</code>来应用，这两个选项都不能消除另一个的影响。</li><li><code>-i, --interactive</code>: 覆盖前提示，覆盖先前的<code>-n</code>选项。</li><li><code>-H</code>: 遵循命令行上指定的符号链接，但保留发现的链接。如果命令行上的参数之一是符号链接，请复制引用的文件，而不是链接本身。但是如果在递归遍历过程中发现了符号链接，它将被复制为符号链接，而不是常规文件。</li><li><code>-l, --link</code>: 创建指向文件的硬链接，而不是复制它们。</li><li><code>-L, --dereference</code>: 始终遵循源文件中的符号链接，如果<code>source</code>是符号链接，请复制链接到的文件，而不是符号链接本身，指定此选项后，<code>cp</code>无法在目标副本中创建符号链接。</li><li><code>-n, --no-clobber</code>: 不要覆盖现有文件。如果先前指定了<code>-i / --interactive</code>，则此选项将覆盖它，不能使用<code>-b / --backup</code>来指定此选项，因为仅在文件将被覆盖时才创建备份。</li><li><code>-P, --no-dereference</code>: 不遵循源代码中的符号链接，将符号链接复制为符号链接，但是仍然可以遵循目标中遇到的现有符号链接。</li><li><code>-p</code>: 与<code>--preserve=mode,ownership,timestamps</code>相同。</li><li><code>--preserve[=ATTR_LIST]</code>: 保留指定的属性，以逗号分隔。属性是：<code>mode</code>，保留文件模式位（由<code>chmod</code>设置）和任何<code>ACL</code>；<code>ownership</code>，保留所有者和组（按<code>chown</code>设置），保留这些属性的能力与使用<code>chown</code>相同；<code>timestamps</code>，如果可能的话，保留最后一次文件访问和修改的时间（<code>atime</code>和<code>mtime</code>，由<code>touch</code>设置）；<code>links</code>，在目标文件中保留源文件之间的所有链接，使用<code>-L</code>或<code>-H</code>时，此选项可能会将符号链接复制为硬链接；<code>context</code>，保留源文件的<code>SELinux</code>安全上下文，否则将由于详细的诊断而失败；<code>xattr</code>，保留源文件的扩展属性，否则将因详细诊断而失败；<code>all</code>，保留以上所有内容，与单独指定上述所有属性相同，不同之处在于无法复制<code>context</code>或<code>xattr</code>不会给出失败的退出状态。如果未指定，则<code>attr_list</code>的默认值为<code>mode</code>，<code>ownership</code>，<code>timestamps</code>。</li><li><code>-c</code>: 已弃用，与<code>--preserve=context</code>相同。</li><li><code>--no-preserve=ATTR_LIST</code>: 不要保留指定的属性。</li><li><code>--parents</code>: 在目录下使用完整的源文件名，即在复制到目标目录时，根据<code>source</code>中指定的路径名，在目标中创建丢失的父目录。</li><li><code>-R, -r, --recursive</code>: 递归复制目录。</li><li><code>--reflink[=WHEN]</code>: 如果目标文件系统支持，请执行优化的<code>CoW</code>（写时复制）克隆，生成的副本将在磁盘上与原始文件共享相同的字节，直到修改副本为止，请注意这意味着如果源字节已损坏，则目标将共享损坏的数据。</li><li><code>--remove-destination</code>: 尝试打开每个目标文件之前，先删除它，与<code>--force</code>选项相反，该选项仅在尝试打开失败后才删除目标文件。</li><li><code>--sparse=WHEN</code>: 控制稀疏文件的创建。稀疏文件包含空洞，其中空洞是零字节序列，不占用物理磁盘空间，读取文件时，孔将读取为零。由于许多文件包含长的零序列，因此可以节省磁盘空间，默认情况下，<code>cp</code>检测稀疏文件并创建稀疏目标文件。在当参数定义了<code>cp</code>当检测到源文件是稀疏的行为：<code>auto</code>，如果源稀疏，尝试使目标稀疏，如果目标存在并且是非常规文件，请不要尝试使其稀疏，这是默认值；<code>always</code>，对于源中每个零字节的足够长的序列，即使输入文件不是稀疏的，也要尝试在目标中打稀疏，如果源文件系统不支持稀疏文件，这将可以在目标文件系统上适当地创建一个稀疏文件；<code>never</code>，不使输出文件稀疏，某些特殊文件（例如交换文件）绝对不能稀疏。</li><li><code>--strip-trailing-slashes</code>: 删除每个源参数中的所有尾部斜杠。</li><li><code>-s, --symbolic-link</code>: 进行符号链接，而不是复制文件本身。除非目标文件位于当前目录中，否则所有源文件都必须是以斜杠开头的绝对路径名。</li><li><code>-S, --suffix=SUFFIX</code>: 覆盖通常的备份后缀。</li><li><code>-t, --target-directory=DIRECTORY</code>: 将所有源参数复制到目录中。</li><li><code>-T, --no-target-directory</code>: 将目的地视为普通文件。</li><li><code>-u, --update</code>: 仅在源文件比目标文件新或缺少目标文件时复制。</li><li><code>-v, --verbose</code>: 详细模式，解释正在做什么。</li><li><code>-x, --one-file-system</code>: 仅在执行命令的文件系统上操作，如果<code>cp</code>试图越过边界到另一个文件系统，则这些文件将被跳过。这包括网络驱动器，驻留在具有不同安装点的文件系统上的任何文件。代表安装点本身的目录将被复制，但不会被遍历。如果指定了<code>-v</code>，则将确切显示已跳过的文件。</li><li><code>-Z, --context[=CTX]</code>: 设置目标的<code>SELinux</code>安全上下文，文件为默认类型，或<code>CTX</code>（如果指定）。</li><li><code>--help</code>: 显示帮助信息。</li><li><code>--version</code>: 显示版本信息。</li></ul><h2 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h2><p>将文件<code>file.txt</code>复制为<code>file2.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file.txt file2.txt</span><br></pre></td></tr></table></figure><p>递归复制文件夹，将<code>tmp</code>文件夹内容全部复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R ./tmp ./tmp2</span><br></pre></td></tr></table></figure><p>创建对<code>file.txt</code>的符号链接而不是复制文件，当然使用<code>ln</code>命令是专门为文件创建符号链接的，<code>cp</code>同样是创建符号链接的好方法，注意要在另一个目录中创建符号链接，<code>cp</code>需要在源文件名中指定完整路径名，包括完整目录名，相对路径将不起作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -s file.txt file-link1</span><br></pre></td></tr></table></figure><h1 id="comm命令"><a href="#comm命令" class="headerlink" title="comm命令"></a>comm命令</h1><p><code>comm</code>命令用于比较两个已排过序的文件，该命令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成<code>3</code>列显示：第<code>1</code>列仅是在第<code>1</code>个文件中出现过的列，第<code>2</code>列是仅在第<code>2</code>个文件中出现过的列，第<code>3</code>列则是在第<code>1</code>与第<code>2</code>个文件里都出现过的列，若给予的文件名称为<code>-</code>，则<code>comm</code>命令会从标准输入设备读取数据。</p><h2 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comm [OPTION]... FILE1 FILE2</span><br></pre></td></tr></table></figure><h2 id="参数-20"><a href="#参数-20" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-1</code>: 禁止列<code>1</code>(<code>FILE1</code>唯一的行)。</li><li><code>-2</code>: 禁止列<code>2</code> (<code>FILE2</code>唯一的行)。</li><li><code>-3</code>: 禁止列3(出现在两个文件中的行)。</li><li><code>--check-order</code>: 检查输入是否正确排序，即使所有输入行都是可配对的。</li><li><code>--nocheck-order</code>: 不检查输入是否正确排序。</li><li><code>--output-delimiter=STR</code>: 用字符串<code>STR</code>分隔列。</li><li><code>-z, --zero-terminated</code>: 指定行分隔符是<code>NUL</code>，不是换行符。</li><li><code>--help</code>: 显示帮助消息。</li><li><code>--version</code>: 输出版本信息。</li></ul><h2 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h2><p><code>recipe.txt</code>文件与<code>shopping-list.txt</code>文件内容，这两个文件不同，但许多行是相同的，并非所有的配方成分都在购物清单上，也不是购物清单上的所有成分都是食谱的一部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># recipe.txt</span><br><span class="line">All-Purpose Flour</span><br><span class="line">Baking Soda</span><br><span class="line">Bread</span><br><span class="line">Brown Sugar</span><br><span class="line">Chocolate Chips</span><br><span class="line">Eggs</span><br><span class="line">Milk</span><br><span class="line">Salt</span><br><span class="line">Vanilla Extract</span><br><span class="line">White Sugar</span><br><span class="line"></span><br><span class="line"># shopping-list.txt</span><br><span class="line">All-Purpose Flour</span><br><span class="line">Bread</span><br><span class="line">Brown Sugar</span><br><span class="line">Chicken Salad</span><br><span class="line">Chocolate Chips</span><br><span class="line">Eggs</span><br><span class="line">Milk</span><br><span class="line">Onions</span><br><span class="line">Pickles</span><br><span class="line">Potato Chips</span><br><span class="line">Soda Pop</span><br><span class="line">Tomatoes</span><br><span class="line">White Sugar</span><br></pre></td></tr></table></figure><p>使用<code>comm</code>命令，其将读取这两个文件并给我们三列输出，在这里，每行输出的开头都有<code>0</code>、<code>1</code>或<code>2</code>个制表符，将输出分成三列：</p><ul><li>第一列<code>zero tabs</code>是只出现在第一个文件中的行。</li><li>第二列<code>one tabs</code>是只出现在第二个文件中的行。</li><li>第三列<code>two tabs</code>是出现在两个文件中的行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">comm recipe.txt shopping-list.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               All-Purpose Flour</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Baking Soda</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               Bread</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               Brown Sugar</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Chicken Salad</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               Chocolate Chips</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               Eggs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               Milk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Onions</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Pickles</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Potato Chips</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Salt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Soda Pop</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Tomatoes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Vanilla Extract</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">               White Sugar</span></span><br></pre></td></tr></table></figure><p>比较<code>recipe.txt</code>文件与<code>shopping-list.txt</code>文件，并禁用第<code>1</code>与第<code>2</code>列的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comm -12 recipe.txt shopping-list.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">All-Purpose Flour</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bread</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Brown Sugar</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Chocolate Chips</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Eggs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Milk</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">White Sugar</span></span><br></pre></td></tr></table></figure><h1 id="col命令"><a href="#col命令" class="headerlink" title="col命令"></a>col命令</h1><p>在很多<code>UNIX</code>说明文件里，都有<code>RLF</code>控制字符，当我们把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，<code>col</code>命令则能有效滤除这些控制字符。</p><h2 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col [options]</span><br></pre></td></tr></table></figure><h2 id="参数-21"><a href="#参数-21" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-b, --no-backspaces</code>: 过滤掉所有的控制字符，包括<code>RLF</code>和<code>HRLF</code>。</li><li><code>-f, --fine</code>: 允许前半行换行，通常在半行边界上打印的字符会在下一行上打印，滤除<code>RLF</code>字符，但允许将<code>HRLF</code>字符呈现出来。</li><li><code>-p, --pass</code>: 传递未知控制序列，通常<code>col</code>将从输入中过滤出除自身识别和解释的以外的任何控制序列。</li><li><code>-h, --tabs</code>: 将空格转换为制表符，这是默认设置。</li><li><code>-x, --spaces</code>: 将制表符转换为空格。</li><li><code>-l, --lines NUM</code>: 在内存中至少缓冲<code>num</code>行，默认情况下缓存<code>128</code>行。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-H, --help</code>: 输出帮助信息。</li></ul><h2 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h2><p>将<code>col</code>的帮助文档过滤掉反向换行符<code>RLF</code>后保存到<code>col.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col --help | col &gt; col.txt</span><br></pre></td></tr></table></figure><p>将<code>col</code>的帮助文档过滤掉控制字符后保存到<code>col.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col --help | col -b &gt; col.txt</span><br></pre></td></tr></table></figure><p>将<code>col</code>的帮助文档的制表符转换为空格后保存到<code>col.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col --help | col -x &gt; col.txt</span><br></pre></td></tr></table></figure><h1 id="colrm命令"><a href="#colrm命令" class="headerlink" title="colrm命令"></a>colrm命令</h1><p><code>colrm</code>命令用于编辑源代码文件，脚本文件或常规文本文件中的文本，此命令从文件中删除选定的列，列定义为一行中的单个字符。索引总是从<code>1</code>开始，而不是<code>0</code>。如果同时指定了开始和结束，则它们之间的列包括开始和结束将被删除。如果只需要删除一列，则开始和结束必须相同。<code>colrm</code>也可以从<code>stdin</code>接受输入。如果不加任何参数，则该指令不会过滤任何一行。</p><h2 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colrm [start] [stop]</span><br></pre></td></tr></table></figure><h2 id="参数-22"><a href="#参数-22" class="headerlink" title="参数"></a>参数</h2><ul><li><code>start</code>： 指定要删除的列的起始编号。</li><li><code>stop</code>： 指定要删除的列的结束编号，省略则删除从<code>start</code>开始的所有列。</li><li><code>-V, --version</code>: 输出版本信息。</li><li><code>-h, --help</code>: 输出帮助信息。</li></ul><h2 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h2><p>从标准输入中获取输入，删除<code>start</code>和<code>stop</code>之间的所有字符，包括<code>start</code>和<code>stop</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colrm 3 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">123456</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">127</span></span><br></pre></td></tr></table></figure><p>从标准输入中获取输入，删除<code>start</code>之后所有的字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">colrm 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1234567</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">12</span></span><br></pre></td></tr></table></figure><p>读<code>file.txt</code>文件中的内容，并将删除后的内容写入<code>file2.txt</code>中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | colrm 3 6 &gt; file2.txt</span><br></pre></td></tr></table></figure><h1 id="cmp命令"><a href="#cmp命令" class="headerlink" title="cmp命令"></a>cmp命令</h1><p><code>cmp</code>命令用来比较两个文件是否有差异，当相互比较的两个文件完全一样时，则该指令不会输出任何信息，若发现有差异，预设会标示出第一个不同之处的字符和列数编号，若不指定任何文件名称或是所给予的文件名为<code>-</code>，则<code>cmp</code>指令会从标准输入设备读取数据。</p><h2 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [-clsv][-i &lt;number of characters&gt;][--help][file][file]</span><br></pre></td></tr></table></figure><h2 id="参数-23"><a href="#参数-23" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-c</code>或<code>--print-chars</code>: 除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</li><li><code>-i &lt;number of characters&gt;</code>或<code>--ignore-initial=&lt;number of characters&gt;</code>: 指定跳过的数目。</li><li><code>-l</code>或<code>--verbose</code>: 标示出所有不一样的地方。</li><li><code>-s</code>或<code>--quiet</code>或<code>--silent</code>: 不显示错误信息。</li><li><code>-v</code>或<code>--version</code>: 显示版本信息。</li><li><code>--help</code>: 在线帮助。</li></ul><h2 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h2><p>比较<code>file.txt</code>与<code>file2.txt</code>文件的差异，如果文件相同，则不显示消息，如果文件不同，则显示第一个不同的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp file.txt file2.txt</span><br></pre></td></tr></table></figure><p>比较<code>file.txt</code>与<code>file2.txt</code>文件的差异，标出所有不同之处。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp -l file.txt file2.txt</span><br></pre></td></tr></table></figure><p>比较<code>file.txt</code>与自定义输入内容的差异，输入内容后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp file.txt -</span><br></pre></td></tr></table></figure><h1 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h1><p><code>chown</code>命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组，用户可以是用户或者是用户<code>D</code>，用户组可以是组名或组<code>id</code>，文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。一般来说，这个指令只有是由系统管理者<code>root</code>所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人，只有系统管理者<code>root</code>才有这样的权限。</p><h2 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file</span><br></pre></td></tr></table></figure><h2 id="参数-24"><a href="#参数-24" class="headerlink" title="参数"></a>参数</h2><ul><li><code>user</code>: 新的文件拥有者的使用者。</li><li><code>group</code>: 新的文件拥有者的使用者组。</li><li><code>--help</code>: 在线帮助。</li><li><code>--version</code>: 显示版本信息。</li><li><code>-c</code>或<code>--changes</code>: 效果类似<code>-v</code>参数，但仅回报更改的部分。</li><li><code>-f</code>或<code>--quite</code>或<code>--silent</code>: 不显示错误信息。</li><li><code>-h</code>或<code>--no-dereference</code>: 只对符号连接的文件作修改，而不更改其他任何相关文件。</li><li><code>-R</code>或<code>--recursive</code>: 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li><code>-v</code>或<code>--version</code>: 显示指令执行过程。</li><li><code>--dereference</code>: 效果和<code>-h</code>参数相同。</li><li><code>--reference=&lt;file or folder&gt;</code>: 把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同。</li></ul><h2 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h2><p>将<code>file.txt</code>文件拥有者设置为<code>www</code>，所属群组设置为<code>web</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown www:web file.txt</span><br></pre></td></tr></table></figure><p>将<code>file.txt</code>文件的所属群组设置为<code>web</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown :web file.txt</span><br></pre></td></tr></table></figure><p>将<code>example</code>文件夹下所有文件文件与目录的拥有者设置为<code>www</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www example</span><br></pre></td></tr></table></figure><h1 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h1><p><code>chmod</code>命令用来变更文件或目录的权限，文件或目录权限的控制分别以读取、写入、执行<code>3</code>种一般权限来区分，另有<code>3</code>种特殊权限可供运用。用户可以使用<code>chmod</code>指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可，此外符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。</p><h2 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [option] [ugoa...][[+-=][rwxX]...][,...] file</span><br></pre></td></tr></table></figure><h2 id="参数-25"><a href="#参数-25" class="headerlink" title="参数"></a>参数</h2><ul><li><code>u</code>: 表示该文件的拥有者。</li><li><code>g</code>: 表示与该文件的拥有者属于同组<code>group</code>的用户。</li><li><code>o</code>: 表示其他以外的人。</li><li><code>a</code>: 表示这三者皆是。</li><li><code>+</code>: 表示增加权限。</li><li><code>-</code>: 表示取消权限。</li><li><code>=</code>: 表示唯一设定权限。</li><li><code>r</code>: 表示可读取。</li><li><code>w</code>: 表示可写入。</li><li><code>x</code>: 表示可执行。</li><li><code>X</code>: 表示可执行当且仅当这个文件是个目录或者已经被设定过为可执行。</li><li><code>-c</code>或<code>--changes</code>: 效果类似<code>-v</code>参数，但仅回报更改的部分。</li><li><code>-f</code>或<code>--quiet</code>或<code>--silent</code>: 不显示错误信息。</li><li><code>-R</code>或<code>--recursive</code>: 递归处理，将指令目录下的所有文件及子目录一并处理。</li><li><code>-v</code>或<code>--verbose</code>: 显示指令执行过程。</li><li><code>--reference=&lt;folder/file&gt;</code>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>使用<code>ll</code>命令查看文件与文件夹相关信息，对于其权限信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--</span><br></pre></td></tr></table></figure><p>首符号为<code>-</code>代表该文件为普通文件，为<code>d</code>则代表目录，紧接着三个字符<code>rw-</code>代表用户<code>u</code>权限属性，接下来三个字符<code>r--</code>代表用户组<code>g</code>权限属性，最后三个字符<code>r--</code>代表其他人<code>o</code>权限属性。</p><ul><li><code>r</code>: 读取属性，值为<code>4</code>。</li><li><code>w</code>: 写入属性，值为<code>2</code>。</li><li><code>x</code>: 执行属性，值为<code>1</code>。</li></ul><h2 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h2><p>将文件<code>file.txt</code>设为所有人可读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r file.txt</span><br></pre></td></tr></table></figure><p>撤销组用户的对于<code>file.txt</code>的写入权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g-w file.txt</span><br></pre></td></tr></table></figure><p>将文件夹下所有目录与文件设为所有人可读取。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure><p>将文件<code>file.txt</code>设为拥有者有写权限，其他用户只有读权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rw,go=r file.txt</span><br></pre></td></tr></table></figure><p>将文件<code>file.py</code>设为拥有者有执行权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x file.py</span><br></pre></td></tr></table></figure><p>将文件<code>file.py</code>设为拥有者拥有所有权限，其他用户无任何权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 file.py</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,go= file.py</span><br></pre></td></tr></table></figure><h1 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h1><p><code>chattr</code>命令可改变存放在<code>ext2</code>文件系统上的文件或目录属性。</p><h2 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr [-vRV] [mode] [files]</span><br></pre></td></tr></table></figure><h2 id="参数-26"><a href="#参数-26" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-R</code>: 递归处理，将指定目录下的所有文件及子目录一并处理。</li><li><code>-v &lt;version num&gt;</code>: 设置文件或目录版本。</li><li><code>-V</code>: 显示指令执行过程。</li><li><code>+ &lt;attribute&gt;</code>: 开启文件或目录的该项属性。</li><li><code>- &lt;attribute&gt;</code>: 关闭文件或目录的该项属性。</li><li><code>= &lt;attribute&gt;</code>: 指定文件或目录的该项属性。</li></ul><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><ul><li><code>a</code>: 使文件或目录仅供附加用途。</li><li><code>b</code>: 不更新文件或目录的最后存取时间。</li><li><code>c</code>: 将文件或目录压缩后存放。</li><li><code>d</code>: 将文件或目录排除在倾倒操作之外。</li><li><code>i</code>: 不得任意更动文件或目录。</li><li><code>s</code>: 保密性删除文件或目录。</li><li><code>S</code>: 即时更新文件或目录。</li><li><code>u</code>: 预防意外删除。</li></ul><h2 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h2><p>防止<code>file.txt</code>文件被修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +i file.txt</span><br></pre></td></tr></table></figure><p>同时对<code>file.txt</code>文件增加两种属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr +ac file.txt</span><br></pre></td></tr></table></figure><p>指定<code>file.txt</code>文件的属性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr =i file.txt</span><br></pre></td></tr></table></figure><h1 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h1><p><code>cat</code>命令属于文件管理，用于连接文件并打印到标准输出设备上，<code>cat</code>经常用来显示文件的内容，注意，当文件较大时，文本在屏幕上迅速闪过，会出现滚屏现象，此时往往看不清所显示的内容，为了控制滚屏，可以按<code>Ctrl+S</code>键停止滚屏，按<code>Ctrl+Q</code>键可以恢复滚屏，此外可以用<code>more</code>等命令进行读文件并分页显示。</p><h2 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure><h2 id="参数-27"><a href="#参数-27" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-n</code>或<code>--number</code>: 由<code>1</code>开始对所有输出的行数编号。</li><li><code>-b</code>或<code>--number-nonblank</code>: 和<code>-n</code>相似，只不过对于空白行不编号。</li><li><code>-s</code>或<code>--squeeze-blank</code>: 当遇到有连续两行以上的空白行，就代换为一行的空白行。</li><li><code>-v</code>或<code>--show-nonprinting</code>: 使用<code>^</code>和<code>M-</code>符号，除了<code>LFD</code>和<code>TAB</code>之外。</li><li><code>-E</code>或<code>--show-ends</code>: 在每行结束处显示<code>$</code>。</li><li><code>-T</code>或<code>--show-tabs</code>: 将<code>TAB</code>字符显示为<code>^I</code>。</li><li><code>-A</code>或<code>--show-all</code>: 等价于<code>-vET</code>。</li><li><code>-e</code>: 等价于<code>-vE</code>选项。</li><li><code>-t</code>: 等价于<code>-vT</code>选项。</li></ul><h2 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h2><p>使用<code>cat</code>命令创建一个文件，输入文件信息后按<code>Ctrl+D</code>输出<code>EOF</code>标识后结束输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; file.txt</span><br></pre></td></tr></table></figure><p>输出<code>file.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt</span><br></pre></td></tr></table></figure><p>同时输出<code>file.txt</code>与<code>file2.txt</code>文件中的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt</span><br></pre></td></tr></table></figure><p>把<code>file.txt</code>文件的内容加上行号后追加到<code>file2.txt</code>文件中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n file.txt &gt;&gt; file2.txt</span><br></pre></td></tr></table></figure><p>清空<code>file2.txt</code>文件，<code>/dev/null</code>称为空设备，是一个特殊的设备文件，其会丢弃一切写入其中的数据，但报告写入操作成功，读取它则会立即得到一个<code>EOF</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; file2.txt</span><br></pre></td></tr></table></figure><p>将<code>file.txt</code>与<code>file2.txt</code>文件内容合并输出到<code>file3.txt</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt file2.txt &gt; file3.txt</span><br></pre></td></tr></table></figure><h1 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h1><p><code>Awk</code>是一种用于高级文本处理的通用脚本语言，其主要用作报告和分析工具，与大多数其他程序性编程语言不同，<code>Awk</code>是数据驱动的，也就是说需要定义一组针对输入文本要执行的操作，然后其获取输入数据，对其进行转换，然后将结果发送到标准输出。</p><h2 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [ -F fs ] [ -v var=value ] [ &#x27;prog&#x27; | -f progfile ] [ file ... ]</span><br></pre></td></tr></table></figure><h2 id="参数-28"><a href="#参数-28" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-F fs</code>: 将输入字段分隔符设置为正则表达式<code>fs</code>。</li><li><code>-v var=value</code>: 在执行<code>awk</code>程序之前，将值赋值给变量<code>var</code>。</li><li><code>&#39;prog&#39;</code>: <code>awk</code>程序。</li><li><code>-f progfile</code>: 指定文件<code>progfile</code>，其中包含要执行的<code>awk</code>程序。</li><li><code>file ...</code>: 由指定的<code>awk</code>程序处理的文件。</li></ul><h2 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h2><p>示例文件<code>example.txt</code>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bucks Milwaukee    60 22 0.732 </span><br><span class="line">Raptors Toronto    55 24 0.707 </span><br><span class="line">76ers Philadelphia 51 31 0.622</span><br><span class="line">Celtics Boston     33 33 0.598</span><br><span class="line">Pacers Indiana     30 34 0.585</span><br></pre></td></tr></table></figure><p>输出<code>example.txt</code>的第<code>3</code>个字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; print $3 &#125;&#x27; example.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">60</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">55</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">51</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">33</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">30</span></span><br></pre></td></tr></table></figure><p>使用正则表达式匹配出以<code>R</code>开头的组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/^R/ &#123; print $1,$2,$3,$4 &#125;&#x27; example.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Raptors Toronto 55 24</span></span><br></pre></td></tr></table></figure><p>使用<code>BEGIN</code>以及<code>END</code>输出在处理记录之前与之后执行的操作，处理过程为输出第二个字段包含<code>Tor</code>的组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123; print &quot;Start Processing&quot; &#125;; $2 ~ /Tor/ &#123;print $1,$2,$3,$4 &#125;; END &#123; print &quot;End Processing&quot; &#125;&#x27; example.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Start Processing</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Raptors Toronto 55 24</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">End Processing</span></span><br></pre></td></tr></table></figure><h1 id="aspell命令"><a href="#aspell命令" class="headerlink" title="aspell命令"></a>aspell命令</h1><p><code>aspell</code>命令是一个交互式拼写检查器，其会扫描指定的文件或任何标准输入的文件，检查拼写错误，并允许交互式地纠正单词。</p><h2 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aspell [options] command</span><br></pre></td></tr></table></figure><h2 id="参数-29"><a href="#参数-29" class="headerlink" title="参数"></a>参数</h2><ul><li><code>usage, -?</code>: 显示常用拼写检查命令和选项的简短摘要。</li><li><code>help</code>: 输出帮助信息。</li><li><code>version, -v</code>: 输出版本信息。</li><li><code>check file, -c file</code>: 拼写检查单个文件。</li><li><code>list</code>: 产生标准输入中拼写错误的单词的列表。</li><li><code>[dump] config</code>: 将所有当前配置选项转储到标准输出。</li><li><code>config key</code>: 将键的当前值发送到标准输出。</li><li><code>soundslike</code>: 输出输入的每个单词的等效声音。</li><li><code>munch</code>: 从单词输入列表中生成可能的词根和词缀。</li><li><code>expand [1-4]</code>: 扩展输入的每个词缀压缩词的词缀标志。</li><li><code>clean [strict]</code>: 清除输入单词列表，以便每一行都是有效单词。</li><li><code>munch-list [simple] [single|multi] [keep]</code>: 通过词缀压缩减小单词列表的大小。</li><li><code>conv from to [norm-form]</code>: 从一种编码转换为另一种编码。</li><li><code>norm (norm-map|from norm-map to) [norm-form]</code>: 执行<code>Unicode</code>规范化。</li><li><code>[dump] dicts|filters|modes</code>: 列出可用的字典，过滤器或模式。</li><li><code>dump|create|merge master|personal|repl wordlist</code>: 转储，创建或合并主，个人或替换单词列表。</li><li><code>-mode=mode</code>: 检查文件时使用的模式，可用的模式有<code>none</code>、<code>url</code>、<code>email</code>、<code>sgml</code>、<code>tex</code>、<code>texinfo</code>、<code>nroff</code>和系统上可用的任何其他模式。</li><li><code>-dont-backup</code>: 不要创建备份文件，通常如果有任何更正，则<code>aspell</code>程序会将<code>.bak</code>附加到现有文件名后，然后创建一个新的带有更正的文件，该文件是在拼写检查期间进行的。</li><li><code>--backup, -b, -x</code>: <code>aspell</code>程序通过复制并在文件名后附加<code>.bak</code>来创建备份文件，仅当命令是检查文件并且仅在进行任何拼写修改时才创建备份文件时，这才适用。</li><li><code>--sug-mode=mode</code>: 建议模式<code>=ultra|fast|normal|bad-spellers</code>。</li><li><code>-encoding=name</code>: 预期将对文档进行编码，默认值取决于当前的语言环境。</li><li><code>--master=name, -d name</code>: 要使用的词典的基本名称，如果指定了此选项，则<code>aspell</code>将使用此词典或退出。</li><li><code>--keymapping=aspell, --keymapping=ispell</code>: 要使用的键映射，默认设置为<code>aspell</code>或<code>ispell</code>使用与<code>Ispell</code>程序相同的映射。</li><li><code>--lang=string, -l string</code>: 要使用的语言，它遵循大多数系统上<code>LANG</code>环境变量的相同格式，由两个字母的<code>ISO639</code>语言代码和短划线或下划线后的可选两个字母的<code>ISO3166</code>国家代码组成，默认值基于<code>LC\u MESSAGES</code>区域设置的值。</li><li><code>--dict-dir=directory</code>: 主词典单词列表的位置。</li><li><code>--size=string</code>: 字典单词列表的首选大小，它由两个字符的数字代码组成，用于描述列表的大小，典型值为：<code>10=tiny</code>、<code>20=really small</code>、<code>30=small</code>、<code>40=somewhat small</code>、<code>50=med</code>、<code>60=kinda large</code>、<code>70=large</code>、<code>80=huge</code>、<code>90=enormous</code>。</li><li><code>--variety=string</code>: 任何额外的信息，以区分这种类型的字典与其他可能具有相同的数量和大小的字典。</li><li><code>--jargon=string</code>: 请使用多样性选项，因为它取代术语作为一个更好的选择，这些术语将来会被删除。</li><li><code>--word-list-path=list of directories</code>: 单词列表信息文件的搜索路径。</li><li><code>--personal=file, -p file</code>: 要使用的个人单词列表的文件名。</li><li><code>--repl=file</code>: 替换列表文件名。</li><li><code>--extra-dicts=list</code>: 使用额外的字典。</li><li><code>--ignore=integer, -W integer</code>: 忽略长度大于或等于整数字符的单词。</li><li><code>--ignore-case, --dont-ignore-case</code>: 检查单词时忽略大小写。</li><li><code>--ignore-repl, --dont-ignore-repl</code>: 忽略存储替换对的命令。</li><li><code>--save-repl, --dont-save-repl</code>: 在全部保存中保存替换单词列表。</li><li><code>--conf=filename</code>: 主配置文件，此文件覆盖<code>aspell</code>的全局默认值。</li><li><code>--conf-dir=directory</code>: 主配置文件的位置。</li><li><code>--data-dir=directory</code>: 语言数据文件的位置。</li><li><code>--keyboard=keyboard</code>: 使用此键盘布局建议可能的单词，如果用户不小心按了所需正确键旁边的键，就会发生这些拼写错误。</li><li><code>--local-data-dir=directory</code>: 语言数据文件的替代位置，在数据目录之前搜索此目录。</li><li><code>--home-dir=directory</code>: 个人单词表文件的目录位置。</li><li><code>--per-conf=filename</code>: 个人配置文件，此文件覆盖全局配置文件中的选项。</li><li><code>--byte-offsets, --dont-byte-offsets</code>: 使用字节偏移量而不是字符偏移量。</li><li><code>--guess, --dont-guess, -m, -P</code>: 在管道模式下，创建不在字典中的缺少的词根/词缀组合。</li><li><code>--reverse, --dont-reverse</code>: 在管道模式下，反转建议列表的顺序。</li><li><code>--suggest, --dont-suggest</code>: 建议在管道模式下进行可能的替换，如果为假，则<code>aspell</code>将报告拼写错误，并且不尝试任何建议或可能的更正。</li><li><code>--time, --dont-time</code>: 给加载时间计时，并建议在管道模式下的时间。</li></ul><h2 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h2><p><code>example.txt</code>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumped over the extraordinarily lazy dog.</span><br></pre></td></tr></table></figure><p>检查文件<code>example.txt</code>是否存在拼写错误，如果有拼写错误则出现选择式交互选项，如果没有拼写错误则不会出现交互式选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aspell -c sample.txt</span><br></pre></td></tr></table></figure><p>使用<code>aspell</code>大量检查单词。运行时将等待用户输入，添加任意数量的单词，完成后按<code>Ctrl + D</code>完成输入，然后即可看到<code>aspell</code>将在输入的下方显示拼写错误的单词。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aspell list</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;journalctl命令&quot;&gt;&lt;a href=&quot;#journalctl命令&quot; class=&quot;headerlink&quot; title=&quot;journalctl命令&quot;&gt;&lt;/a&gt;journalctl命令&lt;/h1&gt;&lt;p&gt;&lt;code&gt;journalctl&lt;/code&gt;命令是&lt;cod</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Linux" scheme="https://blog.haodene.love/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>带你了解Linux系统</title>
    <link href="https://blog.haodene.love/2023/06/30/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Linux/"/>
    <id>https://blog.haodene.love/2023/06/30/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Linux/</id>
    <published>2023-06-30T04:30:00.000Z</published>
    <updated>2023-10-17T03:33:02.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、带你了解Linux系统"><a href="#一、带你了解Linux系统" class="headerlink" title="一、带你了解Linux系统"></a>一、带你了解Linux系统</h1><h2 id="1-1-Linux系统的文件结构🎉"><a href="#1-1-Linux系统的文件结构🎉" class="headerlink" title="1.1 Linux系统的文件结构🎉"></a>1.1 Linux系统的文件结构🎉</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/bin        二进制文件，系统常规命令</span><br><span class="line">/boot       系统启动分区，系统启动时读取的文件</span><br><span class="line">/dev        设备文件</span><br><span class="line">/etc        大多数配置文件</span><br><span class="line">/home       普通用户的家目录</span><br><span class="line">/lib        32位函数库</span><br><span class="line">/lib64      64位库</span><br><span class="line">/media      手动临时挂载点</span><br><span class="line">/mnt        手动临时挂载点</span><br><span class="line">/opt        第三方软件安装位置</span><br><span class="line">/proc       进程信息及硬件信息</span><br><span class="line">/root       临时设备的默认挂载点</span><br><span class="line">/sbin       系统管理命令</span><br><span class="line">/srv        数据</span><br><span class="line">/var        数据</span><br><span class="line">/sys        内核相关信息</span><br><span class="line">/tmp        临时文件</span><br><span class="line">/usr        用户相关设定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-Linux系统命令行的含义"><a href="#1-2-Linux系统命令行的含义" class="headerlink" title="1.2 Linux系统命令行的含义"></a>1.2 Linux系统命令行的含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：root@app00:~# </span><br><span class="line">root    //用户名，root为超级用户</span><br><span class="line">@       //分隔符</span><br><span class="line">app00   //主机名称</span><br><span class="line">~       //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）</span><br><span class="line">#       //表示当前用户是超级用户，普通用户为$，例如：（&quot;yao@app00:/root$&quot; ，表示使用用户&quot;yao&quot;访问/root文件夹）</span><br></pre></td></tr></table></figure><h2 id="1-3-命令的组成"><a href="#1-3-命令的组成" class="headerlink" title="1.3 命令的组成"></a>1.3 命令的组成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：命令 参数名 参数值</span><br></pre></td></tr></table></figure><h1 id="二、基础操作"><a href="#二、基础操作" class="headerlink" title="二、基础操作"></a>二、基础操作</h1><h2 id="2-1-关闭系统"><a href="#2-1-关闭系统" class="headerlink" title="2.1 关闭系统"></a>2.1 关闭系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)立刻关机</span><br><span class="line">  shutdown -h now 或者 poweroff</span><br><span class="line">(2)两分钟后关机</span><br><span class="line">  shutdown -h 2</span><br></pre></td></tr></table></figure><h2 id="2-2-关闭重启"><a href="#2-2-关闭重启" class="headerlink" title="2.2 关闭重启"></a>2.2 关闭重启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)立刻重启</span><br><span class="line">  shutdown -r now 或者 reboot</span><br><span class="line">(2)两分钟后重启</span><br><span class="line">  shutdown -r 2 </span><br></pre></td></tr></table></figure><h2 id="2-3-帮助命令（help）"><a href="#2-3-帮助命令（help）" class="headerlink" title="2.3 帮助命令（help）"></a>2.3 帮助命令（help）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig  --help     //查看 ifconfig 命令的用法</span><br></pre></td></tr></table></figure><h2 id="2-4-命令说明书（man）"><a href="#2-4-命令说明书（man）" class="headerlink" title="2.4 命令说明书（man）"></a>2.4 命令说明书（man）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man shutdown         //打开命令说明后，可按&quot;q&quot;键退出</span><br></pre></td></tr></table></figure><h2 id="2-5-切换用户（su）"><a href="#2-5-切换用户（su）" class="headerlink" title="2.5 切换用户（su）"></a>2.5 切换用户（su）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su yao               //切换为用户&quot;yao&quot;,输入后回车需要输入该用户的密码</span><br><span class="line">exit                 //退出当前用户</span><br></pre></td></tr></table></figure><h1 id="三、目录操作"><a href="#三、目录操作" class="headerlink" title="三、目录操作"></a>三、目录操作</h1><h2 id="3-1-切换目录（cd）"><a href="#3-1-切换目录（cd）" class="headerlink" title="3.1 切换目录（cd）"></a>3.1 切换目录（cd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /                 //切换到根目录</span><br><span class="line">cd /bin              //切换到根目录下的bin目录</span><br><span class="line">cd ../               //切换到上一级目录 或者使用命令：cd ..</span><br><span class="line">cd ~                 //切换到home目录</span><br><span class="line">cd -                 //切换到上次访问的目录</span><br><span class="line">cd xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错</span><br><span class="line">cd /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全</span><br></pre></td></tr></table></figure><h2 id="3-2-查看目录（ls）"><a href="#3-2-查看目录（ls）" class="headerlink" title="3.2 查看目录（ls）"></a>3.2 查看目录（ls）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls                   //查看当前目录下的所有目录和文件</span><br><span class="line">ls -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line">ls -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令&quot;ll&quot;效果一样</span><br><span class="line">ls /bin              //查看指定目录下的所有目录和文件 </span><br></pre></td></tr></table></figure><h2 id="3-3-创建目录（mkdir）"><a href="#3-3-创建目录（mkdir）" class="headerlink" title="3.3 创建目录（mkdir）"></a>3.3 创建目录（mkdir）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tools          //在当前目录下创建一个名为tools的目录</span><br><span class="line">mkdir /bin/tools     //在指定目录下创建一个名为tools的目录</span><br></pre></td></tr></table></figure><h2 id="3-4-修改目录（mv）"><a href="#3-4-修改目录（mv）" class="headerlink" title="3.4 修改目录（mv）"></a>3.4 修改目录（mv）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv 当前目录名 新目录名        //修改目录名，同样适用与文件操作</span><br><span class="line">mv /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面</span><br><span class="line">mv -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹</span><br></pre></td></tr></table></figure><h2 id="3-5-拷贝目录（cp）"><a href="#3-5-拷贝目录（cp）" class="headerlink" title="3.5 拷贝目录（cp）"></a>3.5 拷贝目录（cp）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面</span><br><span class="line">cp -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹</span><br></pre></td></tr></table></figure><h2 id="3-6-搜索目录（find）"><a href="#3-6-搜索目录（find）" class="headerlink" title="3.6 搜索目录（find）"></a>3.6 搜索目录（find）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /bin -name &#x27;a*&#x27;        //查找/bin目录下的所有以a开头的文件或者目录</span><br></pre></td></tr></table></figure><h2 id="3-7-查看当前目录（pwd）"><a href="#3-7-查看当前目录（pwd）" class="headerlink" title="3.7 查看当前目录（pwd）"></a>3.7 查看当前目录（pwd）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd                         //显示当前位置路径</span><br></pre></td></tr></table></figure><h1 id="四、文件操作"><a href="#四、文件操作" class="headerlink" title="四、文件操作"></a>四、文件操作</h1><h2 id="4-1-新增文件（touch）"><a href="#4-1-新增文件（touch）" class="headerlink" title="4.1 新增文件（touch）"></a>4.1 新增文件（touch）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间</span><br></pre></td></tr></table></figure><h2 id="4-2-删除文件（rm）"><a href="#4-2-删除文件（rm）" class="headerlink" title="4.2 删除文件（rm）"></a>4.2 删除文件（rm）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm 文件名              //删除当前目录下的文件</span><br><span class="line">rm -f 文件名           //删除当前目录的的文件（不询问）</span><br></pre></td></tr></table></figure><h2 id="4-3-编辑文件（vi、vim）"><a href="#4-3-编辑文件（vi、vim）" class="headerlink" title="4.3 编辑文件（vi、vim）"></a>4.3 编辑文件（vi、vim）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名              //打开需要编辑的文件</span><br><span class="line">--进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）</span><br><span class="line">命令模式</span><br><span class="line">-刚进入文件就是命令模式，通过方向键控制光标位置，</span><br><span class="line">-使用命令&quot;dd&quot;删除当前整行</span><br><span class="line">-使用命令&quot;/字段&quot;进行查找</span><br><span class="line">-按&quot;i&quot;在光标所在字符前开始插入</span><br><span class="line">-按&quot;a&quot;在光标所在字符后开始插入</span><br><span class="line">-按&quot;o&quot;在光标所在行的下面另起一新行插入</span><br><span class="line">-按&quot;：&quot;进入底行模式</span><br><span class="line">插入模式</span><br><span class="line">-此时可以对文件内容进行编辑，左下角会显示 &quot;-- 插入 --&quot;&quot;</span><br><span class="line">-按&quot;ESC&quot;进入底行模式</span><br><span class="line">底行模式</span><br><span class="line">-退出编辑：      :q</span><br><span class="line">-强制退出：      :q!</span><br><span class="line">-保存并退出：    :wq</span><br><span class="line">## 操作步骤示例 ##</span><br><span class="line">1.保存文件：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;wq&quot;,回车     //保存并退出编辑</span><br><span class="line">2.取消操作：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;q!&quot;,回车     //撤销本次修改并退出编辑</span><br><span class="line">## 补充 ##</span><br><span class="line">vim +10 filename.txt                   //打开文件并跳到第10行</span><br><span class="line">vim -R /etc/passwd                     //以只读模式打开文件</span><br></pre></td></tr></table></figure><h2 id="4-4-查看文件"><a href="#4-4-查看文件" class="headerlink" title="4.4 查看文件"></a>4.4 查看文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt          //查看文件最后一屏内容</span><br><span class="line">less a.txt         //PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看</span><br><span class="line">more a.txt         //显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看</span><br><span class="line">tail -100 a.txt    //查看文件的后100行，&quot;Ctrl+C&quot;退出查看</span><br></pre></td></tr></table></figure><h1 id="五、文件权限"><a href="#五、文件权限" class="headerlink" title="五、文件权限"></a>五、文件权限</h1><h2 id="5-1-权限说明"><a href="#5-1-权限说明" class="headerlink" title="5.1 权限说明"></a>5.1 权限说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件权限简介：&#x27;r&#x27; 代表可读（4），&#x27;w&#x27; 代表可写（2），&#x27;x&#x27; 代表执行权限（1），括号内代表&quot;8421法&quot;</span><br><span class="line">##文件权限信息示例：-rwxrw-r--</span><br><span class="line">-第一位：&#x27;-&#x27;就代表是文件，&#x27;d&#x27;代表是文件夹</span><br><span class="line">-第一组三位：拥有者的权限</span><br><span class="line">-第二组三位：拥有者所在的组，组员的权限</span><br><span class="line">-第三组三位：代表的是其他用户的权限</span><br></pre></td></tr></table></figure><h2 id="5-2-文件权限"><a href="#5-2-文件权限" class="headerlink" title="5.2 文件权限"></a>5.2 文件权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通授权    chmod +x a.txt    </span><br><span class="line">8421法     chmod 777 a.txt     //1+2+4=7，&quot;7&quot;说明授予所有权限</span><br></pre></td></tr></table></figure><h1 id="六、打包与解压"><a href="#六、打包与解压" class="headerlink" title="六、打包与解压"></a>六、打包与解压</h1><h2 id="6-1-说明"><a href="#6-1-说明" class="headerlink" title="6.1 说明"></a>6.1 说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.zip、.rar        //windows系统中压缩文件的扩展名</span><br><span class="line">.tar              //Linux中打包文件的扩展名</span><br><span class="line">.gz               //Linux中压缩文件的扩展名</span><br><span class="line">.tar.gz           //Linux中打包并压缩文件的扩展名</span><br></pre></td></tr></table></figure><h2 id="6-2-打包文件"><a href="#6-2-打包文件" class="headerlink" title="6.2 打包文件"></a>6.2 打包文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;</span><br><span class="line">示例：</span><br><span class="line">tar -zcvf a.tar file1 file2,...      //多个文件压缩打包</span><br></pre></td></tr></table></figure><h2 id="6-3-解压文件"><a href="#6-3-解压文件" class="headerlink" title="6.3 解压文件"></a>6.3 解压文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf a.tar                      //解包至当前目录</span><br><span class="line">tar -zxvf a.tar -C /usr------        //指定解压的位置</span><br><span class="line">unzip test.zip             //解压*.zip文件 </span><br><span class="line">unzip -l test.zip          //查看*.zip文件的内容 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、带你了解Linux系统&quot;&gt;&lt;a href=&quot;#一、带你了解Linux系统&quot; class=&quot;headerlink&quot; title=&quot;一、带你了解Linux系统&quot;&gt;&lt;/a&gt;一、带你了解Linux系统&lt;/h1&gt;&lt;h2 id=&quot;1-1-Linux系统的文件结构🎉&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Linux" scheme="https://blog.haodene.love/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git使用笔记</title>
    <link href="https://blog.haodene.love/2023/06/25/Git%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.haodene.love/2023/06/25/Git%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-25T07:30:00.000Z</published>
    <updated>2023-10-19T15:11:57.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的介绍"><a href="#Git的介绍" class="headerlink" title="Git的介绍"></a>Git的介绍</h1><p><img src="https://bu.dusays.com/2023/08/25/64e7fcf33ba85.png" alt=""></p><p>[toc]</p><h3 id="1-1、什么是Git"><a href="#1-1、什么是Git" class="headerlink" title="1.1、什么是Git"></a>1.1、什么是Git</h3><p>Git 是一个开源的分布式版本控制系统。</p><ul><li><p>分布式 ：</p><ul><li>你的文件可以存放在多个不同的系统(或者位置)，相互之间来自于一个 原本，单个副本修改，不影响其他副本。</li><li>但是可以通过从一个指定地方（比如Github,或者自己构建的gitlab）上传与拉取来获得更新。</li></ul></li><li><p>版本控制系统： 顾名思义</p><ul><li>相比于 集中式版本控制系统，他更小巧，更快捷，更方便。</li><li>不依赖中央服务器，本质上继承了他的创造者的 一切皆文件的想法。</li><li>其实他就是你随处可以带走的文件，只不过加了一套逻辑，可以配合Git来控制，从而进行版本控制。</li></ul></li></ul><h3 id="1-2、Git的安装"><a href="#1-2、Git的安装" class="headerlink" title="1.2、Git的安装"></a>1.2、Git的安装</h3><h4 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux 下使用如下命令安装</span><br><span class="line">sudo yum install git//适用于 RedHat 系的 Linux</span><br><span class="line">或者</span><br><span class="line">sudo apt-get install git//适用于 Ubuntu 系的 Linux</span><br><span class="line">或者</span><br><span class="line">sudo apt-get install git-core//适用于 老版本 Ubuntu 系的 Linux</span><br></pre></td></tr></table></figure><p>一般情况下当下的Linux都自带了 git </p><p>对于更多Linux的安装方法参考  <a href="http://git-scm.com/download/linux">http://git-scm.com/download/linux</a></p><h4 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h4><ul><li>使用homebrew安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><ul><li>二进制安装程序。</li></ul><p>官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a></p><h4 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h4><p>请直接前往 <a href="https://git-scm.com/">git官网</a> 下载，辅之以图形界面工具(可以考虑fork)，另外终端操作以后值得学习。</p><p>在win10 1709版本以上的，可以辅之使用 windows subsystem的Linux来配合使用</p><h3 id="1-3、查看是否有git或者安装是否成功"><a href="#1-3、查看是否有git或者安装是否成功" class="headerlink" title="1.3、查看是否有git或者安装是否成功"></a>1.3、查看是否有git或者安装是否成功</h3><h4 id="查看git版本"><a href="#查看git版本" class="headerlink" title="查看git版本"></a>查看git版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h1 id="Git的配置"><a href="#Git的配置" class="headerlink" title="Git的配置"></a>Git的配置</h1><p>[toc]</p><h3 id="2-1、单词"><a href="#2-1、单词" class="headerlink" title="2.1、单词"></a>2.1、单词</h3><ul><li><code>config</code> : 设置与查看 Git 外观和行为的配置变量<ul><li><code>--system</code> : <ul><li>对应<code>/etc/gitconfig</code> 文件，包含系统上每一个用户及他们仓库的通用配置。 </li></ul></li><li><code>--global</code> : <ul><li>对应<code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件，只针对当前用户。</li></ul></li><li><code>--local</code> : <ul><li>对应 <code>.git/config</code>，即当前使用仓库的 Git 目录中的 <code>config</code> 文件</li></ul></li><li><code>--list</code> : 列举配置</li><li>每一个级别会覆盖上一级别的配置</li></ul></li></ul><h3 id="2-2、语法"><a href="#2-2、语法" class="headerlink" title="2.2、语法"></a>2.2、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --local//当前Git工作区的配置</span><br><span class="line">git config --global//全局Git工作区的配置</span><br><span class="line">git config --system//系统Git工作区的配置</span><br><span class="line"></span><br><span class="line">git config --list//Git配置列举</span><br><span class="line">git config --unset --local//Git配置重置</span><br></pre></td></tr></table></figure><h3 id="2-3、语义"><a href="#2-3、语义" class="headerlink" title="2.3、语义"></a>2.3、语义</h3><h4 id="Git最小化配置"><a href="#Git最小化配置" class="headerlink" title="Git最小化配置"></a>Git最小化配置</h4><ul><li>配置用户名与邮箱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#x27;name&#x27;              //配置全局的 名称</span><br><span class="line">git config --global user.email &#x27;email@address&#x27;    //配置全局的 邮件地址</span><br><span class="line"></span><br><span class="line">// 比如 git config --global user.name &#x27;leo&#x27;</span><br><span class="line">// 比如 git config --global user.email &#x27;leobod@eside.cn&#x27;</span><br></pre></td></tr></table></figure><ul><li>git 的 配置 分为<ul><li>当前工作区  <code>--local</code><ul><li>当前工作区只对 单个Git工作区 有效</li></ul></li><li>全局 <code>--global</code><ul><li>全局配置，对当前所有 Git有效，</li><li>但是当工作区本身有 local 配置时，以 local 为准</li></ul></li><li>系统 <code>--system</code></li></ul></li></ul><p>一般为了方便都是配置的 全局(global)配置，若没有配置，后期用户在使用git 时会提示要求你配置</p><h4 id="Git-配置查看"><a href="#Git-配置查看" class="headerlink" title="Git 配置查看"></a>Git 配置查看</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br><span class="line">git config --list --global//--排名不分先后</span><br><span class="line">git config --list --local</span><br><span class="line"></span><br><span class="line">git config --global user.name//查看单条配置</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure><h4 id="查看配置及所在的文件"><a href="#查看配置及所在的文件" class="headerlink" title="查看配置及所在的文件"></a>查看配置及所在的文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list --show-origin</span><br></pre></td></tr></table></figure><h4 id="配置默认文本编辑器"><a href="#配置默认文本编辑器" class="headerlink" title="配置默认文本编辑器"></a>配置默认文本编辑器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><h3 id="3-1、单词"><a href="#3-1、单词" class="headerlink" title="3.1、单词"></a>3.1、单词</h3><ul><li><code>clone</code></li></ul><h3 id="3-2、语法"><a href="#3-2、语法" class="headerlink" title="3.2、语法"></a>3.2、语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;address&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3、语义"><a href="#3-3、语义" class="headerlink" title="3.3、语义"></a>3.3、语义</h3><h4 id="克隆一个仓库"><a href="#克隆一个仓库" class="headerlink" title="克隆一个仓库"></a>克隆一个仓库</h4><ul><li>最简洁指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/leobod/GitGuide.git</span><br><span class="line">或者也可以使用 git:// 协议或者使用 SSH 传输协议</span><br><span class="line">git clone git@gitee.com:leobod/GitGuide.git</span><br></pre></td></tr></table></figure><ul><li>克隆并指定文件名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/leobod/GitGuide.git GGuide</span><br></pre></td></tr></table></figure><h1 id="git理解图示"><a href="#git理解图示" class="headerlink" title="git理解图示"></a>git理解图示</h1><p><img src="https://bu.dusays.com/2023/08/27/64eb6922d410b.jpg" alt=""></p><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="5-1、单词"><a href="#5-1、单词" class="headerlink" title="5.1、单词"></a>5.1、单词</h2><ul><li>init</li><li>add</li><li>commit</li></ul><h2 id="5-2、语法"><a href="#5-2、语法" class="headerlink" title="5.2、语法"></a>5.2、语法</h2><h3 id="Git的初始化"><a href="#Git的初始化" class="headerlink" title="Git的初始化"></a>Git的初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init        //将当前目录 初始化成 Git仓库</span><br><span class="line">git init &lt;project_name&gt;//在当前目录下 创建 project_name 的目录 并初始化成 Git仓库</span><br></pre></td></tr></table></figure><h3 id="Git添加文件到暂存区"><a href="#Git添加文件到暂存区" class="headerlink" title="Git添加文件到暂存区"></a>Git添加文件到暂存区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;path/file&gt;//Git 初始化后 使用 add 来 将file添加到暂存区</span><br><span class="line">git add -u    //Git 添加 中所有tracked文件中被修改过或已删除文件的信息</span><br><span class="line">git add -A    //Git 添加 所有文件中被修改过或已删除文件的信息 和 未追踪的文件</span><br><span class="line">git add -h    //Git add 帮助说明</span><br></pre></td></tr></table></figure><h3 id="Git-提交文件到-版本库"><a href="#Git-提交文件到-版本库" class="headerlink" title="Git 提交文件到 版本库"></a>Git 提交文件到 版本库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;tips_message&#x27;//Git 将暂存区修改 提交到版本库 并给commit标识 提示语</span><br><span class="line">git commit -am &#x27;tips_message&#x27;//Git 将所有修改的文件 提交到版本库，不管是否添加到暂存区</span><br><span class="line">等同于</span><br><span class="line">git add -a</span><br><span class="line">git commit -m &#x27;tips_message&#x27;</span><br><span class="line"></span><br><span class="line">git commit -h //Git commit 帮助信息</span><br><span class="line">git commit --amend//将最近的修改 附加到 最近一次的 commit 上</span><br></pre></td></tr></table></figure><h2 id="5-3、语义"><a href="#5-3、语义" class="headerlink" title="5.3、语义"></a>5.3、语义</h2><h3 id="创建一个Git仓库，初始化并提交一些commit"><a href="#创建一个Git仓库，初始化并提交一些commit" class="headerlink" title="创建一个Git仓库，初始化并提交一些commit"></a>创建一个Git仓库，初始化并提交一些commit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /path/……/project_01//shell 下切换到 指定目录（根据具体情况）</span><br><span class="line">git init//Git 仓库初始化</span><br><span class="line">vi README.md//vi 新建或编辑一个 文件</span><br><span class="line">git add README.md//添加 README.md 到 暂存区</span><br><span class="line">git commit -m &#x27;Write a README to introduce the project!&#x27;//提交修改到 版本库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">或者</span><br><span class="line">cd /path/……///shell 下切换到 指定目录（根据具体情况）</span><br><span class="line">git init project_02//Git 仓库初始化</span><br><span class="line">vi README.md//vi 新建或编辑一个 文件</span><br><span class="line">git commit -am &#x27;Write a README to introduce the project!&#x27;//提交修改到 版本库</span><br></pre></td></tr></table></figure><h1 id="Git-状态查看"><a href="#Git-状态查看" class="headerlink" title="Git 状态查看"></a>Git 状态查看</h1><h2 id="6-1、单词"><a href="#6-1、单词" class="headerlink" title="6.1、单词"></a>6.1、单词</h2><ul><li>version</li><li>status</li><li>log</li></ul><h2 id="6-2、语法"><a href="#6-2、语法" class="headerlink" title="6.2、语法"></a>6.2、语法</h2><h3 id="查看Git版本"><a href="#查看Git版本" class="headerlink" title="查看Git版本"></a>查看Git版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="查看-工作区-暂存区文件状态"><a href="#查看-工作区-暂存区文件状态" class="headerlink" title="查看 工作区 暂存区文件状态"></a>查看 工作区 暂存区文件状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="查看-commit-历史记录"><a href="#查看-commit-历史记录" class="headerlink" title="查看 commit 历史记录"></a>查看 commit 历史记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">--oneline//一条 commit 在一行显示</span><br><span class="line">--graph//显示 路径 线条</span><br></pre></td></tr></table></figure><h2 id="6-3、语义"><a href="#6-3、语义" class="headerlink" title="6.3、语义"></a>6.3、语义</h2><h3 id="查看-本机git-版本号"><a href="#查看-本机git-版本号" class="headerlink" title="查看 本机git 版本号"></a>查看 本机git 版本号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>结果：</p><p>git version 2.17.1</p><h3 id="查看-工作区-暂存区文件状态-1"><a href="#查看-工作区-暂存区文件状态-1" class="headerlink" title="查看 工作区 暂存区文件状态"></a>查看 工作区 暂存区文件状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>结果1：</p><p>On branch master                                </p><p>Your branch is up to date with ‘origin/master’.        </p><p>nothing to commit, working tree clean</p><p>// 当前 处于 master 分支。分支具体请查看分支管理</p><p>// 你的分支 已经是最新的了， 包含了远端分支，若未连接Github 一般无这条提示</p><p>// 没有什么克提交的， 工作区 暂存区 无变化</p><p>结果2：</p><p>On branch master</p><p>No commits yet</p><p>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)</p><pre><code>    README.md</code></pre><p>nothing added to commit but untracked files present (use “git add” to track)</p><p>// 当前分支 master</p><p>// 还没有 commit</p><p>//为追踪的文件 有 README.md 可以使用 git add <file> 来添加 到 暂存区</p><p>结果3：</p><p>On branch master</p><p>No commits yet</p><p>Changes to be committed:<br>  (use “git rm —cached <file>…” to unstage)</p><pre><code>    new file:   README.md</code></pre><p>// 当前分支 master</p><p>// 还没有 commit</p><p>//新的改变 等待提交， 如果想 取消，可以使用 git rm —cached <file> 从 暂存区中移除 指定文件</p><p>// 若没有问题 在合适的时候 可以 使用 git commit 来提交到 版本库</p><h3 id="查看-commit-的日志-方式1"><a href="#查看-commit-的日志-方式1" class="headerlink" title="查看 commit 的日志 方式1"></a>查看 commit 的日志 方式1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>结果:</p><p>commit 58a8145557cab8a08eedc0877f6fabe419fa84d9 (HEAD -&gt; master, origin/master, origin/c1, origin/HEAD, c1)<br>Author: leobod <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#49;&#x33;&#x39;&#53;&#x32;&#x33;&#x34;&#x38;&#x33;&#51;&#55;&#64;&#115;&#x69;&#110;&#97;&#46;&#99;&#x6e;">&#49;&#x33;&#x39;&#53;&#x32;&#x33;&#x34;&#x38;&#x33;&#51;&#55;&#64;&#115;&#x69;&#110;&#97;&#46;&#99;&#x6e;</a><br>Date:   Fri Feb 8 20:56:01 2019 +0800</p><pre><code>Git的介绍与安装，以及简单配置</code></pre><p>commit efddeada1f93ba9a822ac208cfdf4915b6d406c2<br>Author: leobod <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x31;&#51;&#57;&#x35;&#x32;&#x33;&#52;&#x38;&#51;&#51;&#x37;&#x40;&#115;&#105;&#x6e;&#97;&#x2e;&#x63;&#110;">&#x31;&#51;&#57;&#x35;&#x32;&#x33;&#52;&#x38;&#51;&#51;&#x37;&#x40;&#115;&#105;&#x6e;&#97;&#x2e;&#x63;&#110;</a><br>Date:   Fri Feb 8 19:10:43 2019 +0800</p><pre><code>修改GitGuide的README.md，来说明如如何学习与记录Git的使用</code></pre><p>commit 920f45c5909c33b49f0da5eba413c02d8d85faee<br>Author: leobod <a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#58;&#49;&#x33;&#57;&#x35;&#x32;&#x33;&#x34;&#56;&#x33;&#x33;&#x37;&#x40;&#115;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;">&#49;&#x33;&#57;&#x35;&#x32;&#x33;&#x34;&#56;&#x33;&#x33;&#x37;&#x40;&#115;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;</a><br>Date:   Fri Feb 8 15:52:09 2019 +0800</p><pre><code>Git 使用指南的 书写格式</code></pre><p>commit cb5b26d8271c1fe4871094b66b8f7469e3c59859<br>Author: 差三岁Lee <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#49;&#x33;&#57;&#53;&#x32;&#51;&#x34;&#x38;&#51;&#x33;&#55;&#x40;&#x73;&#x69;&#x6e;&#x61;&#46;&#x63;&#x6e;">&#49;&#x33;&#57;&#53;&#x32;&#51;&#x34;&#x38;&#51;&#x33;&#55;&#x40;&#x73;&#x69;&#x6e;&#x61;&#46;&#x63;&#x6e;</a><br>Date:   Thu Jan 10 13:54:05 2019 +0800</p><pre><code>Initial commit</code></pre><p>// commit 后跟 提交的 hash 值，后期可以 使用 前 7位值来定位， 也可以多选 几位， 一般 7位就够</p><p>//Author 显示 commit 的提交是谁，以及邮箱号，用于对 commit 有问题 或疑问时，责任到人，一般在本机都是 用户 在 git config 处设置的值，如果没有设置，每次提交时 都会 提示要求输入</p><p>// Date 后跟 这个提交的日期</p><h3 id="查看-commit-的日志-方式2"><a href="#查看-commit-的日志-方式2" class="headerlink" title="查看 commit 的日志 方式2"></a>查看 commit 的日志 方式2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --graph</span><br><span class="line">// --oneline与 --graph 可以单独使用</span><br></pre></td></tr></table></figure><p>结果：</p><ul><li>58a8145 (HEAD -&gt; master, origin/master, origin/c1, origin/HEAD, c1) Git的介绍与安装，以及简单配置</li><li>efddead 修改GitGuide的README.md，来说明如如何学习与记录Git的使用</li><li>920f45c Git 使用指南的 书写格式</li><li>cb5b26d Initial commit</li></ul><p>//一条 commit 缩在 一行 前7位显示 commit的 hash值，后面跟 &lt;分支名称&gt; 在跟 <message></p><ul><li><p>号 其实 在终端一般 显示为 * ,在图形端一般是 平滑的线条连接，</p><p>此处 分支都在一条线上，理论上多分支时，可以向树 （或者 森林）一样延展，多数情况下是树，一般不建议搞成 &lt;森林&gt;</p></li></ul><p>何为 树 何为 森林 请 查看数据结构 树的相关内容。</p><h1 id="Git-状态重置-或者-回滚"><a href="#Git-状态重置-或者-回滚" class="headerlink" title="Git 状态重置 或者 回滚"></a>Git 状态重置 或者 回滚</h1><h2 id="7-1、单词"><a href="#7-1、单词" class="headerlink" title="7.1、单词"></a>7.1、单词</h2><ul><li>reset</li><li>checkout</li><li>HEAD     HEAD^    HEAD~n</li></ul><h2 id="7-2、语法"><a href="#7-2、语法" class="headerlink" title="7.2、语法"></a>7.2、语法</h2><h3 id="git-工作区还原到-暂存区的状态，也就是说-取消最近新添加的文件修改"><a href="#git-工作区还原到-暂存区的状态，也就是说-取消最近新添加的文件修改" class="headerlink" title="git 工作区还原到 暂存区的状态，也就是说 取消最近新添加的文件修改"></a>git 工作区还原到 暂存区的状态，也就是说 取消最近新添加的文件修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout .//还原工作区 &lt;所有&gt; 文件 为暂存区状态暂存区状态</span><br><span class="line"></span><br><span class="line">git checkout -- filename//还原工作区 &lt;指定&gt; 文件 为暂存区状态暂存区状态</span><br><span class="line"></span><br><span class="line">补充说明：暂存区状态（最近一次commit 或者 暂存区回滚到的 commit 状态） </span><br></pre></td></tr></table></figure><h3 id="git暂存区-恢复到-commit-状态"><a href="#git暂存区-恢复到-commit-状态" class="headerlink" title="git暂存区 恢复到 commit 状态"></a>git暂存区 恢复到 commit 状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD// 恢复暂存区到 HEAD 指针指向的位置</span><br><span class="line">git reset HEAD^// 恢复暂存区到 HEAD 的上一次 commit</span><br><span class="line">git reset HEAD~4// 恢复暂存区到 HEAD 的上第4次 commit</span><br><span class="line"></span><br><span class="line">git reset &lt;hash&gt;// 恢复暂存区到 指定hash commit处</span><br><span class="line"></span><br><span class="line">git reset 缺省值为 mixed //将HEAD reset 没有修改 工作区 但是修改了 暂存区</span><br><span class="line"></span><br><span class="line">git reset --soft  //将HEAD reset 没有修改 工作区 与 暂存区</span><br><span class="line"></span><br><span class="line">git reset --hard  //将HEAD reset 同时修改工作区与暂存区</span><br></pre></td></tr></table></figure><p>git reset 后 git log 只显示到 HEAD commit 处，以往的不显示，但是 可以到 项目的 <code>.git/logs/refs</code>中去寻找 一般记录保存 30天</p><p>找到后可以 使用 git reset <hash>，来重置</p><h2 id="7-3、语义"><a href="#7-3、语义" class="headerlink" title="7.3、语义"></a>7.3、语义</h2><h3 id="单线型-版本迭代演进-与回滚演示"><a href="#单线型-版本迭代演进-与回滚演示" class="headerlink" title="单线型 版本迭代演进 与回滚演示"></a>单线型 版本迭代演进 与回滚演示</h3><h3 id="演示前的准备"><a href="#演示前的准备" class="headerlink" title="演示前的准备"></a>演示前的准备</h3><ol><li><p><code>git init Test</code> 初始化 一个Test 用于 git 演示</p></li><li><p>建立 <code>hello.c</code>文件 用于版本迭代</p></li><li><p><code>git ad hello.c</code> 且 <code>git commit -m ‘Write a Hello World C Language file&#39;</code></p></li><li><p><code>git log --oneline</code> 结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2e1368 Write a Hello World C Language filWrite a Hello World C Language fil</span><br></pre></td></tr></table></figure></li><li><p><code>vi hello.c</code> 在文件里面 return 0 前 补充 getchar()  并提交</p></li><li><p><code>git log --oneline</code> 结果：</p><pre><code>eb96dee At the end insert getchar() to make a waitb2e1368 Write a Hello World C Language fil</code></pre></li><li><p><code>vi hello.c</code> 在文件里面 补上 // Author： XXXX    提交</p></li><li><p><code>git log --oneline</code> 结果：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">550f417 (HEAD -&gt; master) insert author information into the file</span><br><span class="line">eb96dee At the end insert getchar() to make a wait</span><br><span class="line">b2e1368 Write a Hello World C Language fil</span><br></pre></td></tr></table></figure><hr><hr><h3 id="修改开始"><a href="#修改开始" class="headerlink" title="修改开始"></a>修改开始</h3><p>代码最初为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &#x27;stido.h&#x27;</span><br><span class="line">int main（） &#123;</span><br><span class="line">        printf(&#x27;Hello World! \n&#x27;);</span><br><span class="line">        return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li><p>当前 hello.c 源码 如下：</p></li><li><p>```</p><h1 id="include-‘stido-h’"><a href="#include-‘stido-h’" class="headerlink" title="include ‘stido.h’"></a>include ‘stido.h’</h1><p>// Author: Leobod<br>int main（） {</p><pre><code>    printf(&#39;Hello World! \n&#39;);    getchar();    return 0;</code></pre><p>} </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 修改后 </span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   #include &#x27;stido.h&#x27;</span><br><span class="line">   // Author: Leobod</span><br><span class="line">   // Description: A C language demo</span><br><span class="line">   int main（） &#123;</span><br><span class="line">           printf(&#x27;Hello World! \n&#x27;);</span><br><span class="line">           getchar();</span><br><span class="line">           return 0;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>若 使用 <code>git checkout .</code> 或者 <code>git checkout -- Hello.c</code> 后 恢复到 2处样式</p><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p>若 使用  <code>git reset --hard b2e1368</code> 恢复到  代码最初样子 且 工作区 暂存区代码都一样</p><p><code>git log</code> 为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2e1368 Write a Hello World C Language fil</span><br></pre></td></tr></table></figure><p>可以使用 <code>git reset --hard 550f417</code> 返回 最后一次修改状态</p><p>找不到 hash 请前往 <code>.git/logs/refs</code> 中寻找</p><h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>若使用 <code>git reset b2e1368</code>  工作区 代码 仍为 4处 样式， 暂存区与版本库为 代码最初样式</p><p>此时 使用 <code>git status</code> 可以发现提示</p><p>若想 工作区也 还原 多执行一步  <code>git checkout .</code></p><p>回到 最新状态 依然是  <code>git reset 550f417</code></p><p>此处 <code>550f417</code> 对应最后一次commit的 hash 值</p></li></ol><blockquote><p>本文部分内容参考引用了 <a href="https://www.domon.cn/2018/09/06/Git-reset-used-in-coding/">Domon-Git Reset 三种模式</a></p></blockquote><h1 id="Git-Diff-差异分析"><a href="#Git-Diff-差异分析" class="headerlink" title="Git Diff 差异分析"></a>Git Diff 差异分析</h1><h2 id="虽然命名交-Git-diff-但是实际上-diff-可以是一个单独的工具，专门用来进行-文本比较"><a href="#虽然命名交-Git-diff-但是实际上-diff-可以是一个单独的工具，专门用来进行-文本比较" class="headerlink" title="虽然命名交 Git diff 但是实际上 diff 可以是一个单独的工具，专门用来进行 文本比较"></a>虽然命名交 Git diff 但是实际上 diff 可以是一个单独的工具，专门用来进行 文本比较</h2><h2 id="diff-是Linux-自带的命令，同样-git-中也集成了这个命令"><a href="#diff-是Linux-自带的命令，同样-git-中也集成了这个命令" class="headerlink" title="diff 是Linux 自带的命令，同样 git 中也集成了这个命令"></a>diff 是Linux 自带的命令，同样 git 中也集成了这个命令</h2><p>命令格式：</p><p><code>diff &lt;参数&gt;  &lt;文件1或目录1&gt;  &lt;文件2或目录2&gt;</code></p><p>详情可以参考 <a href="http://www.runoob.com/linux/linux-comm-diff.html">菜鸟教程—Linux diff</a> 或者参考 <a href="https://www.cnblogs.com/newcaoguo/p/5896390.html">博客园中的信息</a></p><h2 id="git-的-diff"><a href="#git-的-diff" class="headerlink" title="git 的 diff"></a>git 的 diff</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git diff 谁 与 谁 比较</span><br><span class="line">git diff --cached //省略HEAD HEAD与暂存区比较</span><br><span class="line">git diff //工作区 与暂存区 比较</span><br><span class="line">=diff --git a/   b/</span><br><span class="line"></span><br><span class="line">假定：HEAD、缓存区、工作区中的readme.md文件内容均不相同。</span><br><span class="line">git diff HEAD -- readme.md //工作区 &lt;===&gt; HEAD</span><br><span class="line">git diff -- readme.md //工作区 &lt;===&gt; 缓存区</span><br><span class="line">git diff --cached -- readme.md //缓存区 &lt;===&gt; HEAD</span><br><span class="line"></span><br><span class="line">git diff &lt;branch_name1&gt; &lt;branch_name2&gt; -- &lt;file_name&gt; //分支 指定文件 比较</span><br></pre></td></tr></table></figure><p>具体可以参考 <a href="https://www.yiibai.com/git/git_diff.html">Git-diff</a></p><h1 id="Git-文件删除、重命名"><a href="#Git-文件删除、重命名" class="headerlink" title="Git 文件删除、重命名"></a>Git 文件删除、重命名</h1><h2 id="9-1、单词"><a href="#9-1、单词" class="headerlink" title="9.1、单词"></a>9.1、单词</h2><ul><li>rm</li><li>mv</li></ul><h2 id="9-2、语法"><a href="#9-2、语法" class="headerlink" title="9.2、语法"></a>9.2、语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm file//删除指定文件，同时 实现 rm</span><br><span class="line">git mv &lt;old&gt; &lt;new&gt;//修改 Git仓库 里面的文件名，会同时实现 mv</span><br></pre></td></tr></table></figure><h2 id="gitignore的使用"><a href="#gitignore的使用" class="headerlink" title=".gitignore的使用"></a><code>.gitignore</code>的使用</h2><p>[toc]</p><h3 id="gitignore配置文件规则"><a href="#gitignore配置文件规则" class="headerlink" title=".gitignore配置文件规则"></a>.gitignore配置文件规则</h3><p>在 .gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log</span><br><span class="line">*.temp</span><br><span class="line">/vendor</span><br></pre></td></tr></table></figure><h3 id="定义全局的-gitignore-文件"><a href="#定义全局的-gitignore-文件" class="headerlink" title="定义全局的 .gitignore 文件"></a>定义全局的 .gitignore 文件</h3><p>除了可以在项目中定义 .gitignore 文件外，还可以设置全局的 git .gitignore 文件来管理所有Git项目的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.excludesfile ~/.gitignore</span><br></pre></td></tr></table></figure><h3 id="Git-忽略规则优先级"><a href="#Git-忽略规则优先级" class="headerlink" title="Git 忽略规则优先级"></a>Git 忽略规则优先级</h3><p>在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源<br>优先级如下（由高到低）：</p><ul><li>从命令行中读取可用的忽略规则</li><li>当前目录定义的规则</li><li>父级目录定义的规则，依次地推</li><li>$GIT_DIR/info/exclude 文件中定义的规则</li><li>core.excludesfile中定义的全局规则</li></ul><h3 id="Git-忽略规则匹配语法"><a href="#Git-忽略规则匹配语法" class="headerlink" title="Git 忽略规则匹配语法"></a>Git 忽略规则匹配语法</h3><p>在 .gitignore 文件中，每一行的忽略规则的语法如下：</p><ul><li><code>空格</code>   不匹配任意文件，可作为分隔符，可用反斜杠转义</li><li><code># 开头</code> 的模式标识注释，可以使用反斜杠进行转义</li><li><code>! 开头</code> 的模式标识否定，该文件将会再次被包含，<ul><li>如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义</li></ul></li><li><code>/ 结束</code> 的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件</li><li><code>/ 开始</code> 的模式匹配项目跟目录<ul><li>如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录</li></ul></li><li><code>**匹配</code> 多级目录，可在开始，中间，结束</li><li><code>?</code> 通用匹配单个字符</li><li><code>[]</code> 通用匹配单个字符列表</li></ul><h3 id="gitignore常用规则"><a href="#gitignore常用规则" class="headerlink" title=".gitignore常用规则"></a>.gitignore常用规则</h3><h4 id="常用匹配示例："><a href="#常用匹配示例：" class="headerlink" title="常用匹配示例："></a>常用匹配示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件</span><br><span class="line">/bin: 忽略根目录下的bin文件</span><br><span class="line">/*.c: 忽略 cat.c，不忽略 build/cat.c</span><br><span class="line">debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj</span><br><span class="line">**/foo: 忽略/foo, a/foo, a/b/foo等</span><br><span class="line">a/**/b: 忽略a/b, a/x/b, a/x/y/b等</span><br><span class="line">!/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件</span><br><span class="line">*.log: 忽略所有 .log 文件</span><br><span class="line">config.php: 忽略当前路径的 config.php 文件</span><br></pre></td></tr></table></figure><h4 id="gitignore常用规则-JAVA"><a href="#gitignore常用规则-JAVA" class="headerlink" title=".gitignore常用规则-JAVA"></a>.gitignore常用规则-JAVA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Operating System Files</span><br><span class="line"></span><br><span class="line">*.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">*.sw?</span><br><span class="line">.#*</span><br><span class="line">*#</span><br><span class="line">*~</span><br><span class="line">*.sublime-*</span><br><span class="line"></span><br><span class="line"># Build Artifacts</span><br><span class="line"></span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line">target/</span><br><span class="line">bin/</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line"></span><br><span class="line"># Eclipse Project Files</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings/</span><br><span class="line"></span><br><span class="line"># IntelliJ IDEA Files</span><br><span class="line"></span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line">*.iws</span><br><span class="line">*.idea</span><br></pre></td></tr></table></figure><h4 id="ignore规则配置-C"><a href="#ignore规则配置-C" class="headerlink" title=".ignore规则配置-C++"></a>.ignore规则配置-C++</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"># User ================================</span><br><span class="line"># 用户自定义的其他忽略文件</span><br><span class="line"></span><br><span class="line"># Clion ================================</span><br><span class="line"># Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and WebStorm</span><br><span class="line"># Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839</span><br><span class="line"></span><br><span class="line"># User-specific stuff</span><br><span class="line">.idea/**/workspace.xml</span><br><span class="line">.idea/**/tasks.xml</span><br><span class="line">.idea/**/usage.statistics.xml</span><br><span class="line">.idea/**/dictionaries</span><br><span class="line">.idea/**/shelf</span><br><span class="line"></span><br><span class="line"># Generated files</span><br><span class="line">.idea/**/contentModel.xml</span><br><span class="line"></span><br><span class="line"># Sensitive or high-churn files</span><br><span class="line">.idea/**/dataSources/</span><br><span class="line">.idea/**/dataSources.ids</span><br><span class="line">.idea/**/dataSources.local.xml</span><br><span class="line">.idea/**/sqlDataSources.xml</span><br><span class="line">.idea/**/dynamic.xml</span><br><span class="line">.idea/**/uiDesigner.xml</span><br><span class="line">.idea/**/dbnavigator.xml</span><br><span class="line"></span><br><span class="line"># Gradle</span><br><span class="line">.idea/**/gradle.xml</span><br><span class="line">.idea/**/libraries</span><br><span class="line"></span><br><span class="line"># Gradle and Maven with auto-import</span><br><span class="line"># When using Gradle or Maven with auto-import, you should exclude module files,</span><br><span class="line"># since they will be recreated, and may cause churn.  Uncomment if using</span><br><span class="line"># auto-import.</span><br><span class="line"># .idea/modules.xml</span><br><span class="line"># .idea/*.iml</span><br><span class="line"># .idea/modules</span><br><span class="line"># *.iml</span><br><span class="line"># *.ipr</span><br><span class="line"></span><br><span class="line"># CMake</span><br><span class="line">cmake-build-*/</span><br><span class="line"></span><br><span class="line"># Mongo Explorer plugin</span><br><span class="line">.idea/**/mongoSettings.xml</span><br><span class="line"></span><br><span class="line"># File-based project format</span><br><span class="line">*.iws</span><br><span class="line"></span><br><span class="line"># IntelliJ</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"># mpeltonen/sbt-idea plugin</span><br><span class="line">.idea_modules/</span><br><span class="line"></span><br><span class="line"># JIRA plugin</span><br><span class="line">atlassian-ide-plugin.xml</span><br><span class="line"></span><br><span class="line"># Cursive Clojure plugin</span><br><span class="line">.idea/replstate.xml</span><br><span class="line"></span><br><span class="line"># Crashlytics plugin (for Android Studio and IntelliJ)</span><br><span class="line">com_crashlytics_export_strings.xml</span><br><span class="line">crashlytics.properties</span><br><span class="line">crashlytics-build.properties</span><br><span class="line">fabric.properties</span><br><span class="line"></span><br><span class="line"># Editor-based Rest Client</span><br><span class="line">.idea/httpRequests</span><br><span class="line"></span><br><span class="line"># Android studio 3.1+ serialized cache file</span><br><span class="line">.idea/caches/build_file_checksums.ser</span><br><span class="line"></span><br><span class="line"># vscode ================================</span><br><span class="line">.vscode/*</span><br><span class="line">!.vscode/settings.json</span><br><span class="line">!.vscode/tasks.json</span><br><span class="line">!.vscode/launch.json</span><br><span class="line">!.vscode/extensions.json</span><br><span class="line"></span><br><span class="line"># C++ ================================</span><br><span class="line"> Prerequisites</span><br><span class="line">*.d</span><br><span class="line"></span><br><span class="line"># Compiled Object files</span><br><span class="line">*.slo</span><br><span class="line">*.lo</span><br><span class="line">*.o</span><br><span class="line">*.obj</span><br><span class="line"></span><br><span class="line"># Precompiled Headers</span><br><span class="line">*.gch</span><br><span class="line">*.pch</span><br><span class="line"></span><br><span class="line"># Compiled Dynamic libraries</span><br><span class="line">*.so</span><br><span class="line">*.dylib</span><br><span class="line">*.dll</span><br><span class="line"></span><br><span class="line"># Fortran module files</span><br><span class="line">*.mod</span><br><span class="line">*.smod</span><br><span class="line"></span><br><span class="line"># Compiled Static libraries</span><br><span class="line">*.lai</span><br><span class="line">*.la</span><br><span class="line">*.a</span><br><span class="line">*.lib</span><br><span class="line"></span><br><span class="line"># Executables</span><br><span class="line">*.exe</span><br><span class="line">*.out</span><br><span class="line">*.app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># CMake ================================</span><br><span class="line">bin/</span><br><span class="line">build/</span><br><span class="line">CMakeLists.txt.user</span><br><span class="line">CMakeCache.txt</span><br><span class="line">CMakeFiles</span><br><span class="line">CMakeScripts</span><br><span class="line">Testing</span><br><span class="line">Makefile</span><br><span class="line">cmake_install.cmake</span><br><span class="line">install_manifest.txt</span><br><span class="line">compile_commands.json</span><br><span class="line">CTestTestfile.cmake</span><br></pre></td></tr></table></figure><h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><h2 id="10-1、单词"><a href="#10-1、单词" class="headerlink" title="10.1、单词"></a>10.1、单词</h2><ul><li>branch</li><li>checkout</li><li>merge</li></ul><h2 id="10-2、语法"><a href="#10-2、语法" class="headerlink" title="10.2、语法"></a>10.2、语法</h2><h3 id="Git-分支建立与切换"><a href="#Git-分支建立与切换" class="headerlink" title="Git 分支建立与切换"></a>Git 分支建立与切换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch_name&gt;//建立分支</span><br><span class="line">git checkout &lt;branch_name&gt;//切换到 branch_name 的分支</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">git checkout -b &lt;branch_name&gt;//新建 并切换到 branch_name 的分支</span><br></pre></td></tr></table></figure><h3 id="Git-已有分支查看"><a href="#Git-已有分支查看" class="headerlink" title="Git 已有分支查看"></a>Git 已有分支查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch//查看分支</span><br><span class="line">git branch -v//查看每一个分支的最后一次提交</span><br><span class="line">git branch -a//查看所有分支 ，包含 远端分支</span><br><span class="line">git branch -av //查看所有分支 以及 最后一次提交</span><br></pre></td></tr></table></figure><h3 id="Git分支删除"><a href="#Git分支删除" class="headerlink" title="Git分支删除"></a>Git分支删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch_name&gt;//删除 指定分支</span><br><span class="line">git branch -D &lt;branch_name&gt;//强制删除 指定分支，删除分支并丢掉所做的修改</span><br></pre></td></tr></table></figure><h3 id="Git-分支合并"><a href="#Git-分支合并" class="headerlink" title="Git 分支合并"></a>Git 分支合并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master//切换到分支 master</span><br><span class="line">git merge &lt;branch_name&gt;//将指定分支 的修改 合并到 master 上</span><br></pre></td></tr></table></figure><h1 id="情景1：-Git的常见分支处理方案"><a href="#情景1：-Git的常见分支处理方案" class="headerlink" title="情景1： Git的常见分支处理方案"></a>情景1： Git的常见分支处理方案</h1><h2 id="前置状态"><a href="#前置状态" class="headerlink" title="前置状态"></a>前置状态</h2><p>现在有一个 Git仓库， 里面有 README.txt 文件 和 description.txt 文件</p><p>README.txt 文件内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is the first line in the README.txt</span><br></pre></td></tr></table></figure><p>description.txt 文件为空</p><p>有如下分支</p><ul><li>master</li><li>feature</li><li>develop</li></ul><h2 id="11-1、操作方案1—不同分支处理了同一个文件，合并时产生冲突的处理"><a href="#11-1、操作方案1—不同分支处理了同一个文件，合并时产生冲突的处理" class="headerlink" title="11.1、操作方案1—不同分支处理了同一个文件，合并时产生冲突的处理"></a>11.1、操作方案1—不同分支处理了同一个文件，合并时产生冲突的处理</h2><p>开始时    master &lt;==&gt; feature &lt;==&gt; develop  (3个分支处于同一处)</p><p>切换到 feature 分支</p><pre><code>修改 read.txt 文件为</code></pre><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first in the read.txt</span><br><span class="line">in the feature branch</span><br></pre></td></tr></table></figure><p>commit 2</p><pre><code>                    commit1        commit2</code></pre><p>修改后            init —————&gt; master(develop)—————&gt;  feature</p><p>​         </p><p>切换到 develop 分支，并保证工作区 与 初始状态一样</p><pre><code>修改 read.txt 文件为</code></pre><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first in the read.txt</span><br><span class="line">In the develop branch</span><br></pre></td></tr></table></figure><p>commit3</p><pre><code>                    commit1        </code></pre><p>修改后        init ————&gt; master————&gt; feature[处于commit2]</p><pre><code>                    |                    |                    ----------------&gt; develop[处于commit3]</code></pre><p>最后 切换到 master分支，并保证 工作区与 版本库一致（也就是最初始状态）</p><p>此处先 合并 develop 后合并feature （也可以 先合并feature后合并 develop 效果一样）</p><p>git merge feature</p><p>git merge develop</p><p>出现冲突，处理冲突文件 read.txt</p><p>同一个文件合并时的冲突都合并到了文件中，git不辅助做修改，需要自行修改，修改文件后重新commit</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This is the first in the read.txt</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">In the develop branch</span><br><span class="line">=======</span><br><span class="line">in the feature branch</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>修改后，假设此处2句都要可以改成</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is the first in the read.txt</span><br><span class="line">In the develop branch</span><br><span class="line">in the feature branch</span><br></pre></td></tr></table></figure><p>git commit</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>修改后，假设此处可以改成 master</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first in the read.txt</span><br><span class="line">In the dmaster branch</span><br></pre></td></tr></table></figure><p>git commit</p><h2 id="11-2、操作方案2—不同分支处理了不同文件，各分支间的修改相互独立没有修改到同一个文件"><a href="#11-2、操作方案2—不同分支处理了不同文件，各分支间的修改相互独立没有修改到同一个文件" class="headerlink" title="11.2、操作方案2—不同分支处理了不同文件，各分支间的修改相互独立没有修改到同一个文件"></a>11.2、操作方案2—不同分支处理了不同文件，各分支间的修改相互独立没有修改到同一个文件</h2><p>正常合并 (merge) 不会报出 冲突异常(conflict)。</p><h2 id="11-3、操作方案3—不同分支修改了同一-文件的文件名"><a href="#11-3、操作方案3—不同分支修改了同一-文件的文件名" class="headerlink" title="11.3、操作方案3—不同分支修改了同一 文件的文件名"></a>11.3、操作方案3—不同分支修改了同一 文件的文件名</h2><p>合并时报出 冲突异常</p><p>比如 read.txt 在分支 develop 改成 read1.txt</p><p>而另外一个人 操作 分支feature 时 将read.txt 改成了 read2.txt</p><p>这时 master 合并2个分支时 会出现异常，结果导致出现 read1.txt 与read2.txt 需要合理甄别，或者讨论后决定是 留住哪一个文件，还是都留下来，在 add 以及commit</p><p><img src="https://bu.dusays.com/2023/08/27/64eb6a801cc06.jpg" alt=""></p><h1 id="Git-远程分支管理"><a href="#Git-远程分支管理" class="headerlink" title="Git 远程分支管理"></a>Git 远程分支管理</h1><h2 id="12-1、单词"><a href="#12-1、单词" class="headerlink" title="12.1、单词"></a>12.1、单词</h2><ul><li>remote</li><li>clone</li></ul><h2 id="12-2、语法"><a href="#12-2、语法" class="headerlink" title="12.2、语法"></a>12.2、语法</h2><h3 id="git-remote-操作"><a href="#git-remote-操作" class="headerlink" title="git remote 操作"></a>git remote 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v//查看远程信息</span><br><span class="line">git remote add &lt;name&gt; &lt;url&gt;//添加 远程 同时可以指定 branch 以及其他</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;//修改 远程 名称</span><br><span class="line">git remote remove &lt;name&gt;//删除 远程 引用</span><br><span class="line">……………………</span><br></pre></td></tr></table></figure><h3 id="git-clone-操作"><a href="#git-clone-操作" class="headerlink" title="git clone 操作"></a>git clone 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone [url/path]</span><br><span class="line">//从指定的 URL或路径 克隆仓库到本地</span><br><span class="line">git clone --bare file:///path/……/project_name name.git</span><br><span class="line">//将指定工程的版本库 克隆或者备份到 当前位置，不加--bare原样克隆</span><br></pre></td></tr></table></figure><h2 id="12-3、语义"><a href="#12-3、语义" class="headerlink" title="12.3、语义"></a>12.3、语义</h2><h3 id="不同克隆方法"><a href="#不同克隆方法" class="headerlink" title="不同克隆方法"></a>不同克隆方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone /path/…………/project.git//哑协议 克隆</span><br><span class="line">git clone file:///path/…………/project//智能协议 克隆</span><br><span class="line">git clone http://github.com/name/progit.git//http协议 克隆</span><br><span class="line">git clone git@github.com:leobod/GitGuide.git//SSH协议 克隆</span><br></pre></td></tr></table></figure><h3 id="克隆一个-github项目"><a href="#克隆一个-github项目" class="headerlink" title="克隆一个 github项目"></a>克隆一个 github项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/leobod/GitGuide.git//克隆当前项目到本地</span><br><span class="line">git remote -v</span><br><span class="line">shell显示</span><br><span class="line">origin  git@github.com:leobod/GitGuide.git (fetch)</span><br><span class="line">origin  git@github.com:leobod/GitGuide.git (push)</span><br><span class="line">克隆的项目 远程名一般为 origin远端分支一般叫 origin/master 或者其他</span><br></pre></td></tr></table></figure><h3 id="使用远程自己-连接github项目"><a href="#使用远程自己-连接github项目" class="headerlink" title="使用远程自己 连接github项目"></a>使用远程自己 连接github项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add github https://github.com/leobod/GitGuide.git</span><br><span class="line">git remote -v</span><br><span class="line">shell显示</span><br><span class="line">github  git@github.com:leobod/GitGuide.git (fetch)</span><br><span class="line">github  git@github.com:leobod/GitGuide.git (push)</span><br><span class="line">请类比上文</span><br></pre></td></tr></table></figure><h3 id="使用远端一般-需要提前配置好-SSH-密钥-并将公钥-放置于GitHub-中使得GitHub放行"><a href="#使用远端一般-需要提前配置好-SSH-密钥-并将公钥-放置于GitHub-中使得GitHub放行" class="headerlink" title="使用远端一般 需要提前配置好 SSH 密钥 并将公钥 放置于GitHub 中使得GitHub放行"></a>使用远端一般 需要提前配置好 SSH 密钥 并将公钥 放置于GitHub 中使得GitHub放行</h3><blockquote><p>更对内容请参考 GIt 官网 <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">3.5 Git 分支 - 远程分支</a></p></blockquote><h1 id="git-本地远程同步操作"><a href="#git-本地远程同步操作" class="headerlink" title="git 本地远程同步操作"></a>git 本地远程同步操作</h1><h2 id="13-1、单词"><a href="#13-1、单词" class="headerlink" title="13.1、单词"></a>13.1、单词</h2><ul><li>fetch</li><li>pull</li><li>push</li></ul><h2 id="13-2、语法"><a href="#13-2、语法" class="headerlink" title="13.2、语法"></a>13.2、语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch//从指定 远程 拉取文件到版本库</span><br><span class="line">git pull//从指定 远程 拉取并合并到 版本库</span><br><span class="line">git push//将版本库 推送到 远程仓库去</span><br></pre></td></tr></table></figure><h2 id="13-3、语义"><a href="#13-3、语义" class="headerlink" title="13.3、语义"></a>13.3、语义</h2><h3 id="在c0分支上做修改，并提交到远端，之后切换到master-合并c0分支的修改，再次提交"><a href="#在c0分支上做修改，并提交到远端，之后切换到master-合并c0分支的修改，再次提交" class="headerlink" title="在c0分支上做修改，并提交到远端，之后切换到master 合并c0分支的修改，再次提交"></a>在c0分支上做修改，并提交到远端，之后切换到master 合并c0分支的修改，再次提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/leobod/GitGuide.git</span><br><span class="line">cd GitGuide/</span><br><span class="line">git checkout c1</span><br><span class="line">vi README.md</span><br><span class="line">做一些修改</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &#x27;message&#x27;</span><br><span class="line">git push  --set-upstream origin c1</span><br><span class="line"></span><br><span class="line">git checkout master</span><br><span class="line">git merge c1</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><h3 id="当其他人修改了-文件，或者当远端-fast-forword（快过本地时，也就是commit-在上一回基础上有变更而本地-还没获取远端更新时）"><a href="#当其他人修改了-文件，或者当远端-fast-forword（快过本地时，也就是commit-在上一回基础上有变更而本地-还没获取远端更新时）" class="headerlink" title="当其他人修改了 文件，或者当远端 fast-forword（快过本地时，也就是commit 在上一回基础上有变更而本地 还没获取远端更新时）"></a>当其他人修改了 文件，或者当远端 fast-forword（快过本地时，也就是commit 在上一回基础上有变更而本地 还没获取远端更新时）</h3><p>方案1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><p>方案2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin</span><br></pre></td></tr></table></figure><h1 id="远程分支与本地分支映射关联"><a href="#远程分支与本地分支映射关联" class="headerlink" title="远程分支与本地分支映射关联"></a>远程分支与本地分支映射关联</h1><h2 id="14-1、单词"><a href="#14-1、单词" class="headerlink" title="14.1、单词"></a>14.1、单词</h2><ul><li>—set-upstream-to</li><li>-u</li><li>—unset-upstream</li><li>-vv                                                                          //此处是2个v</li></ul><h2 id="14-2、语法"><a href="#14-2、语法" class="headerlink" title="14.2、语法"></a>14.2、语法</h2><h3 id="添加本地与远程映射"><a href="#添加本地与远程映射" class="headerlink" title="添加本地与远程映射"></a>添加本地与远程映射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/remote_branch local_branch  </span><br><span class="line">//此处不是必须一一对应</span><br><span class="line">也可以使用</span><br><span class="line">git branch -u origin/remote_branch local_branch</span><br><span class="line"></span><br><span class="line">但是一般 我们建立分支是在本地，提交也是在本地</span><br><span class="line">所以做 push时候 一般已经指定了如：</span><br><span class="line">git checkout c1   //切换到c1  分支</span><br><span class="line">git push --set-upstream origin c1  //当处于 c1 分支时，这样提交 就是 本地c1与远端c1关联</span><br></pre></td></tr></table></figure><h2 id="14-3、撤销分支关联"><a href="#14-3、撤销分支关联" class="headerlink" title="14.3、撤销分支关联"></a>14.3、撤销分支关联</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --unset-upstream local_branch</span><br></pre></td></tr></table></figure><h3 id="查看所有分支的映射关系"><a href="#查看所有分支的映射关系" class="headerlink" title="查看所有分支的映射关系"></a>查看所有分支的映射关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv//此处是2个v</span><br></pre></td></tr></table></figure><h3 id="查看所有分支（本地加远端）"><a href="#查看所有分支（本地加远端）" class="headerlink" title="查看所有分支（本地加远端）"></a>查看所有分支（本地加远端）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote_branch_name&gt;</span><br></pre></td></tr></table></figure><h2 id="14-4、Git对版本库的文件取消track"><a href="#14-4、Git对版本库的文件取消track" class="headerlink" title="14.4、Git对版本库的文件取消track"></a>14.4、Git对版本库的文件取消track</h2><h3 id="取消track方法"><a href="#取消track方法" class="headerlink" title="取消track方法"></a>取消track方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached file/dir</span><br></pre></td></tr></table></figure><h2 id="14-5、GIt远程其他操作"><a href="#14-5、GIt远程其他操作" class="headerlink" title="14.5、GIt远程其他操作"></a>14.5、GIt远程其他操作</h2><p>[toc]</p><h3 id="14-5-1、Git远程仓库"><a href="#14-5-1、Git远程仓库" class="headerlink" title="14.5.1、Git远程仓库"></a>14.5.1、Git远程仓库</h3><p>此处关注的是remote,而不太侧重clone</p><h4 id="添加远程"><a href="#添加远程" class="headerlink" title="添加远程"></a>添加远程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;//添加 远程 同时可以指定 branch 以及其他</span><br></pre></td></tr></table></figure><h4 id="查看远程"><a href="#查看远程" class="headerlink" title="查看远程"></a>查看远程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">git remote show &lt;name&gt;</span><br><span class="line">比如</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h4 id="远程仓库的重命名"><a href="#远程仓库的重命名" class="headerlink" title="远程仓库的重命名"></a>远程仓库的重命名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;name&gt; &lt;new_name&gt;</span><br><span class="line">比如</span><br><span class="line">git remote rename origin github</span><br><span class="line">git remote rename origin gitee</span><br></pre></td></tr></table></figure><h4 id="远程仓库的移除"><a href="#远程仓库的移除" class="headerlink" title="远程仓库的移除"></a>远程仓库的移除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><h4 id="pull与push"><a href="#pull与push" class="headerlink" title="pull与push"></a>pull与push</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch//从指定 远程 拉取文件到版本库</span><br><span class="line">git pull//从指定 远程 拉取并合并到 版本库</span><br><span class="line">git push//将版本库 推送到 远程仓库去</span><br></pre></td></tr></table></figure><h3 id="14-5-2、分支手动关联"><a href="#14-5-2、分支手动关联" class="headerlink" title="14.5.2、分支手动关联"></a>14.5.2、分支手动关联</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/remote_branch local_branch  </span><br><span class="line"></span><br><span class="line">git push --set-upstream origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git的介绍&quot;&gt;&lt;a href=&quot;#Git的介绍&quot; class=&quot;headerlink&quot; title=&quot;Git的介绍&quot;&gt;&lt;/a&gt;Git的介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://bu.dusays.com/2023/08/25/64e7fcf33ba</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Git" scheme="https://blog.haodene.love/tags/Git/"/>
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java基础篇</title>
    <link href="https://blog.haodene.love/2023/06/25/javaEE/"/>
    <id>https://blog.haodene.love/2023/06/25/javaEE/</id>
    <published>2023-06-25T07:30:00.000Z</published>
    <updated>2023-09-12T15:04:33.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaEE基础语法学习笔记"><a href="#JavaEE基础语法学习笔记" class="headerlink" title="JavaEE基础语法学习笔记"></a>JavaEE基础语法学习笔记</h1><hr><h2 id="1-Java的变量与常量使用"><a href="#1-Java的变量与常量使用" class="headerlink" title="1.Java的变量与常量使用"></a>1.Java的变量与常量使用</h2><p>类似于C#，Java的所有变量和函数都要定义在class中</p><h3 id="1-Java内置数据类型"><a href="#1-Java内置数据类型" class="headerlink" title="(1)Java内置数据类型:"></a>(1)Java内置数据类型:</h3><p>类型    字节数    举例<br>byte    1    123<br>short    2    12345<br>int        4    123456789<br>long    8    1234567891011L<br>float    4    1.2F<br>double    8    1.2, 1.2D<br>boolean    1    true, false<br>char    2    ‘A’</p><h3 id="2-Java常量使用"><a href="#2-Java常量使用" class="headerlink" title="(2)Java常量使用:"></a>(2)Java常量使用:</h3><p>使用final修饰</p><p>举例:</p><p>final int N = 110;</p><h2 id="2-Java类型转化"><a href="#2-Java类型转化" class="headerlink" title="2.Java类型转化"></a>2.Java类型转化</h2><h3 id="1-显示转化："><a href="#1-显示转化：" class="headerlink" title="(1)显示转化："></a>(1)显示转化：</h3><p>举例:</p><p>int x = (int)’A’;</p><h3 id="3-隐式转化："><a href="#3-隐式转化：" class="headerlink" title="(3)隐式转化："></a>(3)隐式转化：</h3><p>举例:</p><p>double x = 12, y = 4 * 3.3;</p><h2 id="3-表达式"><a href="#3-表达式" class="headerlink" title="3.表达式"></a>3.表达式</h2><p>与C++、Python3类似,包括+,-,*,/,%等算数运算符, &amp;,|等位运算符, &amp;&amp;,||等逻辑运算符</p><p>举例:<br>int a = 1, b = 2, c = 3;<br>int x = (a + b) * c;<br>x ++;</p><h2 id="4-Java的输入输出"><a href="#4-Java的输入输出" class="headerlink" title="4.Java的输入输出"></a>4.Java的输入输出</h2><h3 id="输入方式1，使用Scanner类，效率较低，输入规模较小时使用。"><a href="#输入方式1，使用Scanner类，效率较低，输入规模较小时使用。" class="headerlink" title="输入方式1，使用Scanner类，效率较低，输入规模较小时使用。"></a>输入方式1，使用Scanner类，效率较低，输入规模较小时使用。</h3><p>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();  <span class="comment">// 读入下一个字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">// 读入下一个整数</span></span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> sc.nextFloat();  <span class="comment">// 读入下一个单精度浮点数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> sc.nextDouble();  <span class="comment">// 读入下一个双精度浮点数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();  <span class="comment">// 读入下一行</span></span><br></pre></td></tr></table></figure><h3 id="输入方式2，使用BufferReader类与InputStreamReader类-效率较高，输入规模较大时使用。注意需要抛异常。"><a href="#输入方式2，使用BufferReader类与InputStreamReader类-效率较高，输入规模较大时使用。注意需要抛异常。" class="headerlink" title="输入方式2，使用BufferReader类与InputStreamReader类,效率较高，输入规模较大时使用。注意需要抛异常。"></a>输入方式2，使用BufferReader类与InputStreamReader类,效率较高，输入规模较大时使用。注意需要抛异常。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出方式1-使用System-out-输出效率较低，输出规模较小时使用。"><a href="#输出方式1-使用System-out-输出效率较低，输出规模较小时使用。" class="headerlink" title="输出方式1 使用System.out 输出效率较低，输出规模较小时使用。"></a>输出方式1 使用System.out 输出效率较低，输出规模较小时使用。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">123</span>);  <span class="comment">// 输出整数 + 换行</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">// 输出字符串 + 换行</span></span><br><span class="line">System.out.print(<span class="number">123</span>);  <span class="comment">// 输出整数</span></span><br><span class="line">System.out.print(<span class="string">&quot;yxc\n&quot;</span>);  <span class="comment">// 输出字符串</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%04d %.2f\n&quot;</span>, <span class="number">4</span>, <span class="number">123.456D</span>);  <span class="comment">// 格式化输出，float与double都用%f输出</span></span><br></pre></td></tr></table></figure><h3 id="输出方式2-效率较高，输出规模较大时使用。注意需要抛异常。"><a href="#输出方式2-效率较高，输出规模较大时使用。注意需要抛异常。" class="headerlink" title="输出方式2 效率较高，输出规模较大时使用。注意需要抛异常。"></a>输出方式2 效率较高，输出规模较大时使用。注意需要抛异常。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">        bw.flush();  <span class="comment">// 需要手动刷新缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Java判断语句"><a href="#5-Java判断语句" class="headerlink" title="5.Java判断语句"></a>5.Java判断语句</h2><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a is bigger than b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;b is bigger than a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a is equal to b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        name = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        name = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        name = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        name = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        name = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        name = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        name = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        name = <span class="string">&quot;not valid&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-Java循环语句"><a href="#6-Java循环语句" class="headerlink" title="6.Java循环语句"></a>6.Java循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i ++ ;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>do while语句与while语句非常相似。唯一的区别是，do while语句限制性循环体后检查条件。不管条件的值如何，我们都要至少执行一次循环。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;  <span class="comment">// 普通循环</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x: a) &#123;  <span class="comment">// forEach循环</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Java数组"><a href="#7-Java数组" class="headerlink" title="7.Java数组"></a>7.Java数组</h2><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>初始化定长数组，长度可以是变量，可以在初始化时赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];  <span class="comment">// 初始化长度为5的int数组，初始值为0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span>[] b = <span class="keyword">new</span> <span class="title class_">float</span>[n];  <span class="comment">// 初始化长度为n的float数组，初始值为0.0F</span></span><br><span class="line"><span class="type">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;  <span class="comment">// 初始化长度为3的char数组，初始值为：&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line"><span class="type">char</span>[] d = c;  <span class="comment">// d与c地址相同，更改c中的元素，d中的元素也会改变</span></span><br></pre></td></tr></table></figure><h3 id="数组元素的读取与写入"><a href="#数组元素的读取与写入" class="headerlink" title="数组元素的读取与写入"></a>数组元素的读取与写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;</span><br><span class="line">    System.out.println(a[i] * a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>[][] b = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">System.out.println(b[<span class="number">0</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><ul><li>属性length：返回数组长度，注意不加小括号</li><li>Arrays.sort()：数组排序</li><li>Arrays.fill(int[] a, int val)：填充数组</li><li>Arrays.toString()：将数组转化为字符串</li><li>Arrays.deepToString()：将多维数组转化为字符串</li></ul><p>注意:数组不可变长</p><h2 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8.字符串"></a>8.字符串</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h4><p><strong>String a = “Hello World”;</strong></p><h3 id="String类-常用API："><a href="#String类-常用API：" class="headerlink" title="String类 常用API："></a>String类 常用API：</h3><ol><li>length()：返回长度</li><li>split(String regex)：分割字符串</li><li>indexOf(char c)、indexOf(String str)：查找，找不到返回-1</li><li>equals()：判断两个字符串是否相等，注意不能直接用==</li><li>compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于</li><li>startsWith()：判断是否以某个前缀开头</li><li>endsWith()：判断是否以某个后缀结尾</li><li>trim()：去掉首位的空白字符</li><li>toLowerCase()：全部用小写字符</li><li>toUpperCase()：全部用大写字符</li><li>replace(char oldChar, char newChar)：替换字符</li><li>replace(String oldRegex, String newRegex)：替换字符串</li><li>substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串</li></ol><h3 id="StringBuilder、StringBuffer"><a href="#StringBuilder、StringBuffer" class="headerlink" title="StringBuilder、StringBuffer"></a>StringBuilder、StringBuffer</h3><ul><li>String不能被修改，如果打算修改字符串，可以使用StringBuilder和StringBuffer。</li><li>StringBuffer线程安全，速度较慢；StringBuilder线程不安全，速度较快。</li></ul><p>举例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello &quot;</span>);  <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 拼接字符串</span></span><br><span class="line"></span><br><span class="line">System.out.println(sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i ++ ) &#123;</span><br><span class="line">    sb.setCharAt(i, (<span class="type">char</span>)(sb.charAt(i) + <span class="number">1</span>));  <span class="comment">// 读取和写入字符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure><h2 id="9-Java的类"><a href="#9-Java的类" class="headerlink" title="9.Java的类"></a>9.Java的类</h2><h3 id="Java源文件声明规则"><a href="#Java源文件声明规则" class="headerlink" title="Java源文件声明规则"></a>Java源文件声明规则</h3><ul><li>一个源文件中只能有一个public类。</li><li>一个源文件可以有多个非public类。</li><li>源文件的名称应该和public类的类名保持一致。</li><li>每个源文件中，先写package语句，再写import语句，最后定义类。</li></ul><h3 id="Java中类的定义"><a href="#Java中类的定义" class="headerlink" title="Java中类的定义"></a>Java中类的定义</h3><p>举例:</p><ul><li>public: 所有对象均可以访问</li><li>private: 只有自己可以访问</li></ul><p>class Point {<br>    private int x;<br>    private int y;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;(%d, %d)&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><h3 id="Java中类的继承"><a href="#Java中类的继承" class="headerlink" title="Java中类的继承"></a>Java中类的继承</h3><p>注意:每个类只能继承一个类。</p><p>举例；</p><p>class ColorPoint extends Point {<br>    private String color;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ColorPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, String color)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;(%d, %d, %s)&quot;</span>, <span class="built_in">super</span>.getX(), <span class="built_in">super</span>.getY(), <span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java中类的多态"><a href="#Java中类的多态" class="headerlink" title="Java中类的多态"></a>Java中类的多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">Point</span> <span class="variable">colorPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;red&quot;</span>);    </span><br><span class="line">    <span class="comment">// 多态，同一个类的实例，调用相同的函数，运行就结果不同</span></span><br><span class="line">    System.out.println(point.toString());</span><br><span class="line">    System.out.println(colorPoint.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-Java的接口"><a href="#10-Java的接口" class="headerlink" title="10.Java的接口"></a>10.Java的接口</h2><p>interface与class类似。主要用来定义类中所需包含的函数。</p><p>接口也可以继承其他接口，一个类可以实现多个接口。</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>每个接口可以继承多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hero</span> <span class="keyword">extends</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>每个类可以实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zeus</span> <span class="keyword">implements</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Zeus&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;: attack!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;: Hi!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot;: Move!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>类似于C++的template，Java的类和接口也可以定义泛型，即同一套函数可以作用于不同的对象类型。<br>泛型只能使用对象类型，不能使用基本变量类型。</p><h2 id="10-Java常用容器"><a href="#10-Java常用容器" class="headerlink" title="10.Java常用容器"></a>10.Java常用容器</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ol><li><p>接口：java.util.List&lt;&gt;。</p></li><li><p>实现：</p></li></ol><p>java.util.ArrayList&lt;&gt;：变长数组<br>java.util.LinkedList&lt;&gt;：双链表</p><ol><li>函数：</li></ol><p>add()：在末尾添加一个元素<br>clear()：清空<br>size()：返回长度<br>isEmpty()：是否为空<br>get(i)：获取第i个元素<br>set(i, val)：将第i个元素设置为val</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li><p>类：java.util.Stack&lt;&gt;</p></li><li><p>函数：<br>push()：压入元素<br>pop()：弹出栈顶元素，并返回栈顶元素<br>peek()：返回栈顶元素<br>size()：返回长度<br>empty()：栈是否为空<br>clear()：清空</p></li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol><li><p>接口：java.util.Queue&lt;&gt;</p></li><li><p>实现：</p></li></ol><p>java.util.LinkedList&lt;&gt;：双链表<br>java.util.PriorityQueue&lt;&gt;：优先队列<br>默认是小根堆，大根堆写法：new PriorityQueue&lt;&gt;(Collections.reverseOrder())</p><ol><li>函数：<br>add()：在队尾添加元素<br>remove()：删除并返回队头<br>isEmpty()：是否为空<br>size()：返回长度<br>peek()：返回队头<br>clear()：清空</li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li><p>接口：java.util.Set<K></p></li><li><p>实现：<br>java.util.HashSet<K>：哈希表<br>java.util.TreeSet<K>：平衡树</p></li><li><p>函数：<br>add()：添加元素<br>contains()：是否包含某个元素<br>remove()：删除元素<br>size()：返回元素数<br>isEmpty()：是否为空<br>clear()：清空<br>java.util.TreeSet多的函数：</p></li></ol><p>​    ceiling(key)：返回大于等于key的最小元素，不存在则返回null<br>​    floor(key)：返回小于等于key的最大元素，不存在则返回null</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ol><li><p>接口：java.util.Map<K, V></p></li><li><p>实现：<br>java.util.HashMap<K, V>：哈希表<br>java.util.TreeMap<K, V>：平衡树</p></li><li><p>函数：<br>put(key, value)：添加关键字和其对应的值<br>get(key)：返回关键字对应的值<br>containsKey(key)：是否包含关键字<br>remove(key)：删除关键字<br>size()：返回元素数<br>isEmpty()：是否为空<br>clear()：清空<br>entrySet()：获取Map中的所有对象的集合<br>Map.Entry<K, V>：Map中的对象类型<br>getKey()：获取关键字<br>getValue()：获取值<br>java.util.TreeMap<K, V>多的函数：<br>ceilingEntry(key)：返回大于等于key的最小元素，不存在则返回null<br>floorEntry(key)：返回小于等于key的最大元素，不存在则返回null</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaEE基础语法学习笔记&quot;&gt;&lt;a href=&quot;#JavaEE基础语法学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaEE基础语法学习笔记&quot;&gt;&lt;/a&gt;JavaEE基础语法学习笔记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-Java的变量与常量</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis基础入门篇</title>
    <link href="https://blog.haodene.love/2023/06/20/MyBatis%E5%9F%BA%E7%A1%80%E4%BA%BA%E7%AF%87/"/>
    <id>https://blog.haodene.love/2023/06/20/MyBatis%E5%9F%BA%E7%A1%80%E4%BA%BA%E7%AF%87/</id>
    <published>2023-06-20T04:30:00.000Z</published>
    <updated>2023-07-25T10:52:31.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MayBatis基础快速入门"><a href="#MayBatis基础快速入门" class="headerlink" title="MayBatis基础快速入门"></a>MayBatis基础快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="如下教程学习自尚硅谷杨博超老师的MyBatis-Plus教程"><a href="#如下教程学习自尚硅谷杨博超老师的MyBatis-Plus教程" class="headerlink" title="如下教程学习自尚硅谷杨博超老师的MyBatis-Plus教程"></a><strong>如下教程学习自尚硅谷杨博超老师的<a href="https://www.bilibili.com/video/BV12R4y157Be/?p=1">MyBatis-Plus教程</a></strong></h3><div class="note no-icon flat"><p>我们的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></div><p><img src="/image/relationship-with-mybatis.png" alt=""></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="支持数据库支持数据库"><a href="#支持数据库支持数据库" class="headerlink" title="支持数据库支持数据库"></a>支持数据库支持数据库</h2><div class="note no-icon flat"><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></div><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p><img src="/image/mybatis-plus-framework.jpg" alt=""></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>我们将通过一个简单的 Demo 来阐述 MyBatis-Plus 的强大功能，在此之前，我们假设您已经：</p><ul><li>拥有 Java 开发环境以及相应 IDE</li><li>熟悉 Spring Boot</li><li>熟悉 Maven</li></ul><p>现有一张 <code>User</code> 表，其表结构如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">name</th><th style="text-align:center">age</th><th style="text-align:center">email</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Jone</td><td style="text-align:center">18</td><td style="text-align:center">test1@baomidou.com</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Jack</td><td style="text-align:center">20</td><td style="text-align:center">test2@baomidou.com</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Tom</td><td style="text-align:center">28</td><td style="text-align:center">test3@baomidou.com</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Sandy</td><td style="text-align:center">21</td><td style="text-align:center">test4@baomidou.com</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Billie</td><td style="text-align:center">24</td><td style="text-align:center">test5@baomidou.com</td></tr></tbody></table></div><p>其对应的数据库 Schema 脚本如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其对应的数据库 Data 脚本如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><div class="note red no-icon flat"><p>Question</p><p>如果从零开始用 MyBatis-Plus 来实现该表的增删改查我们需要做什么呢？</p></div><h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h2><p>​    创建一个空的 Spring Boot 工程（工程将以 H2 作为默认数据库进行演示）</p><div class="note green no-icon flat"><p>提示</p><p>可以使用 <a href="https://start.spring.io/">Spring Initializer (opens new window)</a>快速初始化一个 Spring Boot 工程</p></div><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>引入 Spring Boot Starter 父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5+ 版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 <code>spring-boot-starter</code>、<code>spring-boot-starter-test</code>、<code>mybatis-plus-boot-starter</code>、<code>h2</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 <code>application.yml</code> 配置文件中添加 H2 数据库的相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Config</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">sql:</span></span><br><span class="line">    <span class="attr">init:</span></span><br><span class="line">      <span class="attr">schema-locations:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line">      <span class="attr">data-locations:</span> <span class="string">classpath:db/data-h2.sql</span></span><br></pre></td></tr></table></figure><p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编写实体类 <code>User.java</code>（此处使用了 <a href="https://www.projectlombok.org/">Lombok</a> 简化代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 Mapper 包下的 <code>UserMapper</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>添加测试类，进行功能测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;----- selectAll method test ------&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">5</span>, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note blue no-icon flat"><p>UserMapper 中的 <code>selectList()</code> 方法的参数为 MP 内置的条件封装器 <code>Wrapper</code>，所以不填写就是无任何条件</p></div><p>控制台输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User(id=1, name=Jone, age=18, email=test1@baomidou.com)</span><br><span class="line">User(id=2, name=Jack, age=20, email=test2@baomidou.com)</span><br><span class="line">User(id=3, name=Tom, age=28, email=test3@baomidou.com)</span><br><span class="line">User(id=4, name=Sandy, age=21, email=test4@baomidou.com)</span><br><span class="line">User(id=5, name=Billie, age=24, email=test5@baomidou.com)</span><br></pre></td></tr></table></figure><div class="note blue no-icon flat"><p class='p gren'>提示</p><p>完整的代码示例请移步：<a href="https://github.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-quickstart">Spring Boot 快速启动示例 (opens new window)</a>| <a href="https://github.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-quickstart-springmvc">Spring MVC 快速启动示例</a></p></div><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>全新的 <code>MyBatis-Plus</code> 3.0 版本基于 JDK8，提供了 <code>lambda</code> 形式的调用，所以安装集成 MP3.0 要求如下：</p><ul><li>JDK 8+</li><li>Maven or Gradle</li></ul><div class="note blue no-icon flat"><p class='p green'>提示</p><p>JDK7 及以下的请参考 MP2.0 版本，地址：<a href="https://baomidou.gitee.io/mybatis-plus-doc/#/">2.0 文档</a></p></div><h2 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h2><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Gradle Version:&lt;4.1</span></span><br><span class="line">compile <span class="attr">group:</span> <span class="string">&#x27;com.baomidou&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;mybatis-plus-boot-starter&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;最新版本&#x27;</span></span><br><span class="line"><span class="comment">//Gradle Version:&gt;=4.1 (The function compile has been deprecated since Gradle 4.10, and removed since Gradle 7.0. Please use implementation instead.)</span></span><br><span class="line">implementation <span class="string">&#x27;com.baomidou:mybatis-plus-boot-starter:最新版本&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Gradle Version:&lt;4.1</span></span><br><span class="line">compile <span class="attr">group:</span> <span class="string">&#x27;com.baomidou&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;mybatis-plus&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;最新版本&#x27;</span></span><br><span class="line"><span class="comment">//Gradle Version:&gt;=4.1 (The function compile has been deprecated since Gradle 4.10, and removed since Gradle 7.0. Please use implementation instead.)</span></span><br><span class="line">implementation <span class="string">&#x27;com.baomidou:mybatis-plus:最新版本&#x27;</span></span><br></pre></td></tr></table></figure><div class="note blue no-icon flat"><p class='p yellow'>注意</p><p>引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</p></div><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>快照 SNAPSHOT 版本需要添加仓库，且版本号为快照版本 <a href="https://oss.sonatype.org/content/repositories/snapshots/com/baomidou/mybatis-plus-boot-starter/">点击查看最新快照版本号</a></p><p>Maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://oss.sonatype.org/content/repositories/snapshots/&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h1><p>MyBatis-Plus 的配置异常的简单，我们仅需要一些简单的配置即可使用 MyBatis-Plus 的强大功能！</p><div class="note blue no-icon flat"><p class='p green'>提示</p><p>在讲解配置之前，请确保您已经安装了 MyBatis-Plus，如果您尚未安装，请查看 <a href="https://baomidou.com/pages/bab2db/">安装</a> 一章。</p></div><h2 id="Spring-Boot-工程"><a href="#Spring-Boot-工程" class="headerlink" title="Spring Boot 工程"></a>Spring Boot 工程</h2><ul><li>配置 MapperScan 注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-工程"><a href="#Spring-工程" class="headerlink" title="Spring 工程"></a>Spring 工程</h2><ul><li>配置 MapperScan</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>调整 SqlSessionFactory 为 MyBatis-Plus 的 SqlSessionFactory</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>本文将介绍 <code>MybatisPlus</code> 注解包相关类详解（更多详细描述可点击查看源码注释）</p><div class="note no-icon flat"><p>注解类包源码：👉 <a href="https://gitee.com/baomidou/mybatis-plus/tree/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation">mybatis-plus-annotation</a></p></div><h2 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableName.java">TableName</a></h2><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>属性</th><th style="text-align:left">类型</th><th style="text-align:left">必须指定</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>value</td><td style="text-align:left">String</td><td style="text-align:left">否</td><td style="text-align:left">“”</td><td style="text-align:left">表名</td></tr><tr><td>schema</td><td style="text-align:left">String</td><td style="text-align:left">否</td><td style="text-align:left">“”</td><td style="text-align:left">schema</td></tr><tr><td>keepGlobalPrefix</td><td style="text-align:left">boolean</td><td style="text-align:left">否</td><td style="text-align:left">false</td><td style="text-align:left">是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td style="text-align:left">String</td><td style="text-align:left">否</td><td style="text-align:left">“”</td><td style="text-align:left">xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>aytoResultMap</td><td style="text-align:left">boolean</td><td style="text-align:left">否</td><td style="text-align:left">false</td><td style="text-align:left">是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td style="text-align:left">String[]</td><td style="text-align:left">否</td><td style="text-align:left">{}</td><td style="text-align:left">需要排除的属性名 @since 3.3.1</td></tr></tbody></table></div><p><strong>关于 <code>autoResultMap</code> 的说明：</strong></p><p>MP 会自动构建一个 <code>resultMap</code> 并注入到 MyBatis 里（一般用不上），请注意以下内容：</p><p>因为 MP 底层是 MyBatis，所以 MP 只是帮您注入了常用 CRUD 到 MyBatis 里，注入之前是动态的（根据您的 Entity 字段以及注解变化而变化），但是注入之后是静态的（等于 XML 配置中的内容）。</p><p>而对于 <code>typeHandler</code> 属性，MyBatis 只支持写在 2 个地方:</p><ol><li>定义在 resultMap 里，作用于查询结果的封装</li><li>定义在 <code>insert</code> 和 <code>update</code> 语句的 <code>#&#123;property&#125;</code> 中的 <code>property</code> 后面（例：<code>#&#123;property,typehandler=xxx.xxx.xxx&#125;</code>），并且只作用于当前 <code>设置值</code></li></ol><p>除了以上两种直接指定 <code>typeHandler</code> 的形式，MyBatis 有一个全局扫描自定义 <code>typeHandler</code> 包的配置，原理是根据您的 <code>property</code> 类型去找其对应的 <code>typeHandler</code> 并使用。</p><h2 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableId.java">TableId</a></h2><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>属性</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>idType.NOME</td><td>指定主键类型</td></tr></tbody></table></div><h3 id="IdType"><a href="#IdType" class="headerlink" title="IdType"></a><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType</a></h3><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增</td></tr><tr><td>NONE</td><td>无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td>INPUT</td><td>insert 前自行 set 主键值</td></tr><tr><td>ASSIGN_ID</td><td>分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr><tr><td>ASSIGN_UUID</td><td>分配 UUID,主键类型为 String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认 default 方法)</td></tr><tr><td><del>ID_WORKER</del></td><td>分布式全局唯一 ID 长整型类型(please use <code>ASSIGN_ID</code>)</td></tr><tr><td><del>UUID</del></td><td>32 位 UUID 字符串(please use <code>ASSIGN_UUID</code>)</td></tr><tr><td><del>ID_WORKER_STR</del></td><td>分布式全局唯一 ID 字符串类型(please use <code>ASSIGN_ID</code>)</td></tr></tbody></table></div><h2 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableField.java">@TableField</a></h2><ul><li>描述：字段注解（非主键）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>数据库字段名</td></tr><tr><td>exist</td><td>boolean</td><td>否</td><td>true</td><td>是否为数据库表字段</td></tr><tr><td>condition</td><td>String</td><td>否</td><td>“”</td><td>字段 <code>where</code> 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的 `%s=#</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MayBatis基础快速入门&quot;&gt;&lt;a href=&quot;#MayBatis基础快速入门&quot; class=&quot;headerlink&quot; title=&quot;MayBatis基础快速入门&quot;&gt;&lt;/a&gt;MayBatis基础快速入门&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="https://blog.haodene.love/tags/Java/"/>
    
    <category term="MyBatis" scheme="https://blog.haodene.love/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.haodene.love/2023/06/15/hello-world/"/>
    <id>https://blog.haodene.love/2023/06/15/hello-world/</id>
    <published>2023-06-15T08:30:00.000Z</published>
    <updated>2023-07-07T01:33:12.981Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微机原理与接口技术</title>
    <link href="https://blog.haodene.love/2023/06/15/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"/>
    <id>https://blog.haodene.love/2023/06/15/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/</id>
    <published>2023-06-15T08:30:00.000Z</published>
    <updated>2023-07-25T10:52:28.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微机原理与接口技术"><a href="#微机原理与接口技术" class="headerlink" title="微机原理与接口技术"></a>微机原理与接口技术</h1><h2 id="第一章-微型计算机系统概述"><a href="#第一章-微型计算机系统概述" class="headerlink" title="第一章 微型计算机系统概述"></a>第一章 微型计算机系统概述</h2><h3 id="1-微型计算机系统组成"><a href="#1-微型计算机系统组成" class="headerlink" title="1. 微型计算机系统组成"></a>1. 微型计算机系统组成</h3><ol><li>微处理器:运算器、控制器、寄存器</li><li>微型计算机：输入输出接口、总线、内存</li><li>微型计算机系统：由硬件和软件共同组成的完整的计算机系统</li></ol><h3 id="2-系统总线"><a href="#2-系统总线" class="headerlink" title="2. 系统总线"></a>2. 系统总线</h3><ul><li>地址总线AB</li><li>输出将要访问的内存单元或I/O端口的地址</li><li>地址线的多少决定了系统直接寻址存储器的范围</li><li>数据总线DB</li><li>CPU读操作时，外部数据通过数据总线送往CPU</li><li>CPU写操作时，CPU数据通过数据总线送往外部</li><li>数据线的多少决定了一次能够传送数据的位数</li><li>控制总线CB</li><li>协调系统中各部件的操作，有输出控制、输入状态等信号</li><li>控制总线决定了系统总线的特点，例如功能、适应性等</li></ul><h3 id="3-基于8088CPU的PC微机系统结构"><a href="#3-基于8088CPU的PC微机系统结构" class="headerlink" title="3. 基于8088CPU的PC微机系统结构"></a>3. 基于8088CPU的PC微机系统结构</h3><ol><li>运算器：包括算术逻辑单元（ALU），对数据进行算术或者逻辑运算</li><li>控制器：包括指令寄存器、指令译码器、定时控制电路。执行一条指令的流程为：取指令，翻译指令，执行指令 </li><li>寄存器阵列：包括通用寄存器和专用寄存器，通用寄存器用来存放临时数据，专用寄存器有PC和SP等</li></ol><h3 id="4-微处理器（CPU）内部结构"><a href="#4-微处理器（CPU）内部结构" class="headerlink" title="4. 微处理器（CPU）内部结构"></a>4. 微处理器（CPU）内部结构</h3><ul><li><p>指令处理单元（控制器）：对机器指令<strong>译码</strong>，产生指令执行所需的<strong>控制信</strong>号，并按照指令规定的时序将控制信号<strong>传送</strong>到CPU内部各器件或传送到总线。</p></li><li><p>算术逻辑单元（运算器）：接收到控制器发出的各种运算控制信号后，执行相应运算，并影响相应标志位。</p></li><li><p>寄存器组：CPU内用于暂时存放数据、地址的存储单元，CPU从内存读取指令、在内存中读写数据，均需要这些寄存器完成寻址、暂存的功能。其中标志寄存器能够间接影响程序执行流程</p></li><li><p>8088的内部结构从功能分成两个单元</p><p>a. 总线接口单元BIU——管理8088与系统总线的接口，负责CPU对存储器和外设进行访问</p><p>b. 执行单元EU——负责指令的译码、执行和数据的运算</p><p>c. 两个单元相互独立，分别完成各自操作</p><p> 两个单元可以并行执行，实现指令取指和执行的流水线操作</p></li></ul><h2 id="8088-CPU-外部特性与IBM-PC总线结构"><a href="#8088-CPU-外部特性与IBM-PC总线结构" class="headerlink" title="8088 CPU 外部特性与IBM PC总线结构"></a>8088 CPU 外部特性与IBM PC总线结构</h2><p><img src="/image/01.png" alt="01"></p><h3 id="1-8088的两种组态模式"><a href="#1-8088的两种组态模式" class="headerlink" title="1. 8088的两种组态模式"></a>1. 8088的两种组态模式</h3><ul><li>MN/MX*接高电平为最小组态模式</li><li>MN/MX*接低电平为最大组态模式</li></ul><h3 id="2-8088最小组态的引脚信号"><a href="#2-8088最小组态的引脚信号" class="headerlink" title="2. 8088最小组态的引脚信号"></a>2. 8088最小组态的引脚信号</h3><h5 id="1-数据和地址引脚"><a href="#1-数据和地址引脚" class="headerlink" title="1. 数据和地址引脚"></a>1. 数据和地址引脚</h5><ol><li>AD7～AD0</li></ol><ul><li>地址/数据分时复用引脚，双向、三态</li><li>在访问存储器或外设的总线操作周期中，这些引脚在第一个时钟周期输出存储器或I/O端口的低8位地址A7～A0</li><li>其他时间用于传送8位数据D7～D0</li></ul><ol><li>A15～A8（Address）<br>中间8位地址引脚，输出、三态<br>这些引脚在访问存储器或外设时，提供全部20位地址中的中间8位地址A15～A8</li><li>A19/S6～A16/S3（Address/Status）</li></ol><ul><li>地址/状态分时复用引脚，输出、三态</li><li>这些引脚在访问存储器的第一个时钟周期输出高4位地址A19～A16</li><li>在访问外设的第一个时钟周期全部输出低电平无效</li><li>其他时间输出状态信号S6～S3</li><li>S6始终为低；</li><li>S5为标志寄存器的中断允许标志的状态位，它在每一个时钟周期开始时被修改；</li><li>S4和S3用以指示是哪一个段寄存器正在被使用，00为ES，01为SS，10为CS，11为DS。</li><li>在DMA方式时这4条线处于高阻状态</li></ul><h5 id="2-读写控制引脚"><a href="#2-读写控制引脚" class="headerlink" title="2. 读写控制引脚"></a>2. 读写控制引脚</h5><ol><li>ALE（Address Latch Enable）</li></ol><ul><li>地址锁存允许，输出、三态、高电平有效</li><li>ALE引脚高有效时，表示复用引脚：AD7～AD0和A19/S6～A16/S3正在传送地址信息</li><li>由于地址信息在这些复用引脚上出现的时间很短暂，所以系统可以利用ALE引脚将地址锁存起来</li></ul><ol><li>IO/M*（Input and Output/Memory）</li></ol><ul><li>I/O或存储器访问，输出、三态</li><li>该引脚输出高电平时，表示CPU将访问I/O端口，这时地址总线A15～A0提供16位I/O口地址</li><li>该引脚输出低电平时，表示CPU将访问存储器，这时地址总线A19～A0提供20位存储器地址</li></ul><ol><li>WR*（Write）</li></ol><ul><li>写控制，输出、三态、低电平有效</li><li>有效时，表示CPU正在写出数据给存储器或I/O端口</li></ul><ol><li>RD*（Read）</li></ol><ul><li>读控制，输出、三态、低电平有效</li><li>有效时，表示CPU正在从存储器或I/O端口读入数据</li></ul><ol><li>READY</li></ol><ul><li>存储器或I/O口就绪，输入、高电平有效</li><li>在总线操作周期中，8088CPU会在第3个时钟周期的前沿（下降沿）测试该引脚<br>如果测到高有效，CPU直接进入第4个时钟周期<br>如果测到无效，CPU将插入等待周期Tw</li><li>CPU在等待周期中仍然要监测READY信号，有效则进入第4个时钟周期，否则继续插入等待周期Tw</li></ul><ol><li>DEN*（Data Enable）</li></ol><ul><li>数据允许，输出、三态、低电平有效</li><li>有效时，表示当前数据总线上正在传送数据，可利用他来控制对数据总线的驱动</li></ul><ol><li>DT/R*（Data Transmit/Receive）</li></ol><ul><li>数据发送/接收，输出、三态</li><li>该信号表明当前总线上数据的流向<br>高电平时数据自CPU输出（发送）<br>低电平时数据输入CPU（接收）</li></ul><ol><li>SS0*（System Status 0）<br>最小组态模式下的状态输出信号</li></ol><ul><li>它与IO/M<em>和DT/R</em>一道，通过编码指示CPU在最小组态下的8种工作状态：</li></ul><h5 id="3-中断请求和响应引脚"><a href="#3-中断请求和响应引脚" class="headerlink" title="3. 中断请求和响应引脚"></a>3. 中断请求和响应引脚</h5><ol><li>INTR（Interrupt Request）</li></ol><ul><li>可屏蔽中断请求，输入、高电平有效</li><li>有效时，表示请求设备向CPU申请可屏蔽中断</li><li>该请求的优先级别较低，并可通过关中断指令CLI清除标志寄存器中的IF标志、从而对中断请求进行屏蔽</li></ul><ol><li>INTA*（Interrupt Acknowledge）</li></ol><ul><li>可屏蔽中断响应，输出、低电平有效</li><li>有效时，表示来自INTR引脚的中断请求已被CPU响应，CPU进入中断响应周期</li><li>中断响应周期是连续的两个，每个都发出有效响应信号，以便通知外设他们的中断请求已被响应、并令有关设备将中断向量号送到数据总线</li></ul><ol><li>NMI（Non-Maskable Interrupt）</li></ol><ul><li>不可屏蔽中断请求，输入、上升沿有效</li><li>有效时，表示外界向CPU申请不可屏蔽中断</li><li>该请求的优先级别高于INTR，并且不能在CPU内被屏蔽</li><li>当系统发生紧急情况时，可通过他向CPU申请不可屏蔽中断服务</li></ul><h5 id="4-总线请求和响应引脚"><a href="#4-总线请求和响应引脚" class="headerlink" title="4. 总线请求和响应引脚"></a>4. 总线请求和响应引脚</h5><ol><li>HOLD</li></ol><ul><li>总线保持（即总线请求），输入、高电平有效</li><li>有效时，表示总线请求设备向CPU申请占有总线</li></ul><ol><li>HLDA（HOLD Acknowledge）</li></ol><ul><li>总线保持响应（即总线响应），输出、高电平有效</li><li>有效时，表示CPU已响应总线请求并已将总线释放</li><li>此时CPU的地址总线、数据总线及具有三态输出能力的控制总线将全面呈现高阻，使总线请求设备可以顺利接管总线</li><li>待到总线请求信号HOLD无效，总线响应信号HLDA也转为无效，CPU重新获得总线控制权</li></ul><ol><li>RESET</li></ol><ul><li>复位请求，输入、高电平有效</li><li>该信号有效，将使CPU回到其初始状态；当它再度返回无效时，CPU将重新开始工作<br>8088/86复位后<br>CS＝FFFFH、IP＝0000H，<br>所以程序入口在物理地址FFFF0H</li></ul><ol><li>CLK（Clock）<br>时钟输入</li></ol><h5 id="5-其它引脚"><a href="#5-其它引脚" class="headerlink" title="5. 其它引脚"></a>5. 其它引脚</h5><ol><li>MN/MX*（Minimum/Maximum）<br>组态选择，输入</li><li>TEST*<br>测试，输入、低电平有效</li></ol><h5 id="6-8088的基本总线时序"><a href="#6-8088的基本总线时序" class="headerlink" title="6. 8088的基本总线时序"></a>6. 8088的基本总线时序</h5><ol><li>总线时序描述CPU引脚如何实现总线操作</li></ol><ul><li>描述总线操作的微处理器时序有三级：<br>指令周期 → 总线周期 → 时钟周期</li><li>指令周期是指一条指令经取指、译码、读写操作数到执行完成的过程。若干总线周期组成一个指令周期</li><li>总线周期是指CPU通过总线操作与外部（存储器或I/O端口）进行一次数据交换的过程</li><li>8088的基本总线周期需要4个时钟周期</li><li>总线操作中如何实现CPU与内存、接口芯片间的时序同步是关键</li><li>同步时序：<br>各部件都以系统时钟信号为基准<br>当相互不能配合时，快速部件（CPU）插入等待状态等待慢速部件（I/O和存储器）</li><li>异步时序：<br>CPU与外设接口通过应答联络信号实现同步操作</li></ul><h5 id="7-8088最小组态的总线时序"><a href="#7-8088最小组态的总线时序" class="headerlink" title="7. 8088最小组态的总线时序"></a>7. 8088最小组态的总线时序</h5><ul><li>存储器读总线周期</li><li>存储器写总线周期</li><li>I/O读总线周期</li><li>I/O写总线周期</li></ul><h5 id="8-8088最大组态中的引脚定义"><a href="#8-8088最大组态中的引脚定义" class="headerlink" title="8. 8088最大组态中的引脚定义"></a>8. 8088最大组态中的引脚定义</h5><ul><li>有些控制信号不相同，主要是用于输出操作编码信号，由总线控制器8288译码产生系统控制信号：</li><li>LOCK*——总线封锁信号</li><li>S2<em>、S1</em>、S0*——3个状态信号</li><li>QS1、QS0——指令队列状态信号</li><li>RQ<em>/GT0</em>、RQ<em>/GT1</em>——2个总线请求/同意信号</li></ul><h5 id="9-8088最大组态的总线形成"><a href="#9-8088最大组态的总线形成" class="headerlink" title="9. 8088最大组态的总线形成"></a>9. 8088最大组态的总线形成</h5><p>系统地址总线</p><ol><li>采用三态透明锁存器74LS373和三态单向缓冲器74LS244</li><li>系统数据总线<br>通过三态双向缓冲器74LS245形成和驱动</li><li>系统控制总线<br>主要由总线控制器8288形成<br>MEMR<em>、MEMW</em>、IOR<em>、IOW</em>、INTA*</li></ol><hr><h2 id="第二章-半导体存储器及接口"><a href="#第二章-半导体存储器及接口" class="headerlink" title="第二章 半导体存储器及接口"></a>第二章 半导体存储器及接口</h2><h5 id="1-半导体存储器的分类"><a href="#1-半导体存储器的分类" class="headerlink" title="1. 半导体存储器的分类"></a>1. 半导体存储器的分类</h5><ol><li>读写存储器RAM：SRAM.DRAM,NVRAM</li><li>只读存储器ROM</li></ol><ul><li>掩膜ROM：信息制作在芯片中，不可更改</li><li>PROM：允许一次编程，此后不可更改</li><li>EPROM：用紫外光擦除，擦除后可编程；并允许用户多次擦除和编程</li><li>EEPROM（E2PROM）：采用加电方法在线进行擦除和编程，也可多次擦写</li><li>Flash Memory（闪存）：能够快速擦写的EEPROM，但只能按块（Block）擦除</li></ul><h5 id="2-半导体存储器芯片的内部结构"><a href="#2-半导体存储器芯片的内部结构" class="headerlink" title="2. 半导体存储器芯片的内部结构"></a>2. 半导体存储器芯片的内部结构</h5><ol><li>每个存储单元具有一个唯一的地址，可存储1位（位片结构）或多位（字片结构）二进制数据</li></ol><ul><li>存储容量（bits）与地址、数据线个数有关：<br>芯片的存储容量＝2^M×N<br>＝存储单元数×存储单元的位数</li></ul><ol><li>地址译码电路结构<br>单译码，双译码</li><li>片选和读写控制逻辑<br>片选端CS<em>或CE</em><br>有效时，可以对该芯片进行读写操作<br>输出OE<em><br>控制读操作。有效时，芯片内数据输出<br>该控制端对应系统的读控制线<br>写WE</em><br>控制写操作。有效时，数据进入芯片中<br>该控制端对应系统的写控制线</li></ol><h5 id="4-随机存取存储器"><a href="#4-随机存取存储器" class="headerlink" title="4. 随机存取存储器"></a>4. 随机存取存储器</h5><ol><li>静态RAM（SRAM）</li></ol><p><img src="/image/02.png" alt="02"></p><ul><li>SRAM的基本存储单元是触发器电路</li><li>SRAM一般采用“字结构”存储矩阵</li><li>SRAM芯片2114外部特性：<br>10根地址线A9～A0<br>4根数据线I/O4～I/O1<br>片选CS<em><br>读写WE</em></li><li>SRAM芯片6264外部特性<br>28个引脚：<br>13根地址线A12～A0<br>8根数据线D7～D0<br>片选CS1<em>、CS2<br>读写WE</em>、OE*</li></ul><ol><li>动态RAM</li></ol><ul><li>每个存储单元存放一位，芯片内每个位单元具有独立地址</li><li>需要8个存储芯片构成一个字节单元，每个</li><li>DRAM芯片4116外部特性</li><li><ul><li>7根地址线A6～A0,</li></ul></li><li><ul><li>1根数据输入线DIN,</li></ul></li><li><ul><li>1根数据输出线DOUT,</li></ul></li><li><ul><li>行地址选通RAS*,</li></ul></li><li><ul><li>列地址选通CAS*,</li></ul></li><li><ul><li>读写控制WE*.</li></ul></li><li>DRAM 4116的刷新:采用“仅行地址有效”方法刷新</li><li>DRAM芯片2164外部特性</li><li><ul><li>8根地址线A7～A0<br>1根数据输入线DIN<br>1根数据输出线DOUT<br>行地址选通RAS<em><br>列地址选通CAS</em><br>读写控制WE*</li></ul></li></ul><h5 id="5-只读存储器"><a href="#5-只读存储器" class="headerlink" title="5. 只读存储器"></a>5. 只读存储器</h5><ol><li>EPROM 2716</li></ol><ul><li>11根地址线A10～A0<br>8根数据线DO7～DO0<br>片选/编程CE<em>/PGM<br>读写OE</em><br>编程电压VPP</li></ul><ol><li>EPROM 2764</li></ol><ul><li>13根地址线A12～A0<br>8根数据线D7～D0<br>片选CE<em><br>编程PGM</em><br>读写OE*<br>编程电压VPP</li></ul><ol><li>EEPROM<br>用加电方法，进行在线（无需拔下，直接在电路中）擦写（擦除和编程一次完成）</li><li>EEPROM 2717A</li></ol><ul><li>11根地址线A10～A0<br>8根数据线I/O7～I/O0<br>片选CE<em><br>读写OE</em>、WE<em><br>状态输出RDY/BUSY</em></li></ul><ol><li>EEPROM 2864A</li></ol><ul><li>13根地址线A12～A0<br>8根数据线I/O7～I/O0<br>片选CE<em><br>读写OE</em>、WE*</li></ul><h5 id="6-半导体存储器与CPU的连接"><a href="#6-半导体存储器与CPU的连接" class="headerlink" title="6. 半导体存储器与CPU的连接"></a>6. 半导体存储器与CPU的连接</h5><ol><li>存储芯片的数据线</li></ol><ul><li>若芯片的数据线正好8根：<br>一次可从芯片中访问到8位数据，全部数据线与系统的8位数据总线相连</li><li>若芯片的数据线不足8根：一次不能从一个芯片中访问到8位数据，“位扩充”</li></ul><p><img src="/image/03.png" alt="03"></p><ol><li>存储芯片的地址线</li></ol><ul><li>芯片的地址线通常应全部与系统的低位地址总线相连</li><li>寻址时，这部分地址的译码是在存储芯片内完成的，我们称为“<strong>片内译码</strong>”</li></ul><ol><li>存储芯片的片选端</li></ol><ul><li>存储系统常需利用多个存储芯片扩充容量，也就是扩充了存储器地址范围</li><li>进行“地址扩充”，需要利用存储芯片的片选端对多个存储芯片（组）进行寻址</li><li>这个寻址方法，主要通过将存储芯片的片选端与系统的高位地址线相关联来实现</li><li>这种扩充简称为“地址扩充”或“字扩充”</li></ul><p><strong>译码和译码器</strong></p><p><strong>全译码</strong></p><ol><li>所有的系统地址线均参与对存储单元的译码寻址</li><li>包括低位地址线对芯片内各存储单元的译码寻址（片内译码），高位地址线对存储芯片的译码寻址（片选译码）</li><li>采用全译码，每个存储单元的地址都是唯一的，不存在地址重复</li><li>译码电路可能比较复杂、连线也较多</li></ol><p><strong>部分译码</strong></p><ol><li>只有部分（高位）地址线参与对存储芯片的译码</li><li>每个存储单元将对应多个地址（地址重复），需要选取一个可用地址</li><li>可简化译码电路的设计</li><li>但系统的部分地址空间将被浪费</li></ol><p><strong>线选译码</strong></p><ul><li>只用少数几根高位地址线进行芯片的译码，且每根负责选中一个芯片（组）</li><li>虽构成简单，但地址空间严重浪费，必然会出现地址重复</li><li>一个存储地址会对应多个存储单元</li><li>多个存储单元共用的存储地址不应使用</li></ul><ol><li>存储芯片的读写控制线</li></ol><ul><li>芯片OE*与系统的读命令线相连<br>当芯片被选中、且读命令有效时，存储芯片将开放并驱动数据到总线</li><li>芯片WE*与系统的写命令线相连<br>当芯片被选中、且写命令有效时，允许总线数据写入存储芯片</li></ul><h5 id="7-存储芯片与CPU的配合"><a href="#7-存储芯片与CPU的配合" class="headerlink" title="7. 存储芯片与CPU的配合"></a>7. 存储芯片与CPU的配合</h5><ol><li>总线驱动</li></ol><ul><li>CPU的总线驱动能力有限</li><li>单向传送的地址和控制总线，可采用三态锁存器和三态单向驱动器等来加以锁存和驱动</li><li>双向传送的数据总线，可以采用三态双向驱动器来加以驱动</li></ul><ol><li>时序配合</li></ol><ul><li>分析存储器的存取速度是否满足CPU总线时序的要求<br>如果不能满足：考虑更换芯片，总线周期中插入等待状态TW</li></ul><h5 id="8-8086存储器组织"><a href="#8-8086存储器组织" class="headerlink" title="8. 8086存储器组织"></a>8. 8086存储器组织</h5><ol><li>寻址空间(20位地址线)<br>220＝1M bytes的存储器寻址空间<br>分段的概念</li><li>分段组织<br>段寄存器的16位值左移4位，得到的20位值加上16位的偏移量。</li><li>字与字节访问<br>AD0 信号和BHE信号组合，选择奇偶字节或字。</li></ol><hr><h2 id="第三章-基本输入输出接口"><a href="#第三章-基本输入输出接口" class="headerlink" title="第三章 基本输入输出接口"></a>第三章 基本输入输出接口</h2><h3 id="I-O接口概述"><a href="#I-O接口概述" class="headerlink" title="I/O接口概述"></a>I/O接口概述</h3><ul><li>I/O接口是位于系统与外设间、用来协助完成数据传送和控制任务的逻辑电路</li><li>PC机系统板的可编程接口芯片、I/O总线槽的电路板（适配器）都是接口电路</li></ul><ol><li>信号转换<br>对信号的形式和数据的格式进行变换<br>微机直接处理：数字量、开关量、脉冲量</li><li>数据缓冲<br>对输入输出数据进行缓冲和锁存<br>输出锁存缓冲环节，输入锁存缓冲环节</li><li>对I/O端口进行寻址</li><li>与CPU和I/O设备进行联络</li></ol><h3 id="I-O接口的典型结构"><a href="#I-O接口的典型结构" class="headerlink" title="I/O接口的典型结构"></a>I/O接口的典型结构</h3><h5 id="1-接口电路的内部结构"><a href="#1-接口电路的内部结构" class="headerlink" title="1. 接口电路的内部结构"></a>1. 接口电路的内部结构</h5><ul><li>数据寄存器<br>保存外设给CPU和CPU发往外设的数据</li><li>状态寄存器<br>保存外设或接口电路的状态</li><li>控制寄存器<br>保存CPU给外设或接口电路的命令</li></ul><h5 id="2-接口电路的外部特性"><a href="#2-接口电路的外部特性" class="headerlink" title="2. 接口电路的外部特性"></a>2. 接口电路的外部特性</h5><ul><li>面向CPU一侧的信号：用于与CPU连接、主要是数据、地址和控制信号</li><li>面向外设一侧的信号：用于与外设连接、提供的信号种类繁多、功能定义、时序及有效电平等差异较大</li></ul><h5 id="3-接口电路芯片的分类"><a href="#3-接口电路芯片的分类" class="headerlink" title="3. 接口电路芯片的分类"></a>3. 接口电路芯片的分类</h5><ul><li>通用接口芯片<br>支持通用的数据输入输出和控制的接口芯片</li><li>面向外设的专用接口芯片<br>针对某种外设设计、与该种外设接口</li><li>面向微机系统的专用接口芯片<br>与CPU和系统配套使用，以增强其总体功能</li></ul><h5 id="4-接口电路的可编程性"><a href="#4-接口电路的可编程性" class="headerlink" title="4. 接口电路的可编程性"></a>4. 接口电路的可编程性</h5><h3 id="3-I-O端口的编址"><a href="#3-I-O端口的编址" class="headerlink" title="3. I/O端口的编址"></a>3. I/O端口的编址</h3><ol><li>数据寄存器、状态寄存器和控制寄存器占有的I/O地址常依次被称为数据端口、状态端口和控制端口，用于保存数据、状态和控制信息</li><li>两类编排形式</li></ol><ul><li>I/O端口独立编址</li></ul><p><strong>优点</strong>：</p><ul><li>I/O端口的地址空间独立</li><li>控制和地址译码电路相对简单</li><li>专门的I/O指令使程序清晰易读</li></ul><p><strong>缺点</strong>：</p><ul><li>I/O指令没有存储器指令丰富</li><li>I/O端口与存储器统一编址</li></ul><p><strong>优点：</strong></p><ul><li>不需要专门的I/O指令</li><li>I/O数据存取与存储器数据存取一样灵活</li></ul><p><strong>缺点：</strong></p><ul><li>I/O端口要占去部分存储器地址空间</li><li>程序不易阅读（不易分清访存和访问外设）</li></ul><h3 id="4-8088-8086的输入输出指令"><a href="#4-8088-8086的输入输出指令" class="headerlink" title="4. 8088/8086的输入输出指令"></a>4. 8088/8086的输入输出指令</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入指令</span><br><span class="line"><span class="keyword">IN</span> <span class="built_in">AL</span>,i8<span class="comment">;字节输入，直接寻址</span></span><br><span class="line"><span class="keyword">IN</span> <span class="built_in">AL</span>,<span class="built_in">DX</span><span class="comment">;字节输入，间接寻址</span></span><br><span class="line"><span class="keyword">IN</span> <span class="built_in">AX</span>,i8<span class="comment">;字输入，直接寻址</span></span><br><span class="line"><span class="keyword">IN</span> <span class="built_in">AX</span>,<span class="built_in">DX</span><span class="comment">;字输入，间接寻址</span></span><br><span class="line">输出指令</span><br><span class="line"><span class="keyword">OUT</span> i8,<span class="built_in">AL</span><span class="comment">;字节输出，直接寻址</span></span><br><span class="line"><span class="keyword">OUT</span> <span class="built_in">DX</span>,<span class="built_in">AL</span><span class="comment">;字节输出，间接寻址</span></span><br><span class="line"><span class="keyword">OUT</span> i8,<span class="built_in">AX</span><span class="comment">;字输出，直接寻址</span></span><br><span class="line"><span class="keyword">OUT</span> <span class="built_in">DX</span>,<span class="built_in">AX</span><span class="comment">;字输出，间接寻址</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-8088-8086的I-O端口"><a href="#1-8088-8086的I-O端口" class="headerlink" title="1. 8088/8086的I/O端口"></a>1. 8088/8086的I/O端口</h5><ul><li>8086用于寻址外设端口的地址线为16条，端口最多为216＝65536（64K）个，端口号（端口地址）为0000H ~ FFFFH</li><li>每个端口地址对应一个字节空间</li></ul><ol><li>寻址方式</li></ol><ul><li>直接寻址：只用于寻址00H ~ FFH前256个端口，操作数i8表示端口号</li><li>间接寻址：可用于寻址全部64K个端口，DX寄存器的值就是端口号，对端口号大于FFH的端口只能采用间接寻址方式</li></ul><ol><li>数据交换</li></ol><ul><li>如果输入输出一个字节，使用AL寄存器</li><li>如果输入输出一个字，使用AX寄存器</li></ul><h3 id="5-I-O地址的译码"><a href="#5-I-O地址的译码" class="headerlink" title="5. I/O地址的译码"></a>5. I/O地址的译码</h3><h3 id="6-数据传送方式"><a href="#6-数据传送方式" class="headerlink" title="6. 数据传送方式"></a>6. 数据传送方式</h3><ul><li>程序控制下的数据传送：通过CPU执行程序中的I/O指令来完成传送，又分为：<strong>无条件传送、查询传送、中断传送</strong></li><li>直接存储器存取（DMA）——传送请求由外设向DMA控制器（DMAC）提出，后者向CPU申请总线，最后DMAC利用系统总线来完成外设和存储器间的数据传送</li><li>I/O处理机——CPU委托专门的I/O处理机来管理外设，完成传送和相应的数据处理</li></ul><h4 id="1-无条件传送方式及其接口"><a href="#1-无条件传送方式及其接口" class="headerlink" title="1. 无条件传送方式及其接口"></a>1. 无条件传送方式及其接口</h4><ul><li>在CPU与慢速变化的设备（或简单设备）交换数据时，可以认为它们总是<strong>处于“就绪”状态</strong>，随时可以进行数据传送</li><li>适合于简单设备，如LED数码管、开关等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">next:mov dx,8000h;DX指向数据端口</span><br><span class="line">in al,dx;从输入端口读开关状态</span><br><span class="line">not al;反相</span><br><span class="line">out dx,al;送输出端口显示</span><br><span class="line">call delay;调子程序延时</span><br><span class="line">jmp next;重复</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-查询传送方式及其接口"><a href="#2-查询传送方式及其接口" class="headerlink" title="2. 查询传送方式及其接口"></a>2. 查询传送方式及其接口</h5><ul><li>CPU需要先了解（<strong>查询</strong>）外设的工作状态，然后在外设可以交换信息的情况下（就绪）实现数据输入或输出</li><li>对多个外设的情况，则CPU按一定顺序依次查询（<strong>轮询</strong>）</li><li>查询传送的特点是：工作可靠，适用面宽，但传送效率低</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查询输入接口程序示例</span><br><span class="line">mov dx,8000h;DX指向状态端口</span><br><span class="line">    status:in al,dx;读状态端口</span><br><span class="line">test al,01h;测试标志位D0</span><br><span class="line">jz status;D0＝0，未就绪，继续查询</span><br><span class="line">inc dx;D0＝1，就绪，DX指向数据端口</span><br><span class="line">in al,dx;从数据端口输入数据</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//查询输出接口程序示例</span><br><span class="line">  mov dx,8000h;DX指向状态端口</span><br><span class="line">  status:in al,dx;读取状态端口的状态数据</span><br><span class="line">test al,80h;测试标志位D7</span><br><span class="line">jnz status;D7＝1，未就绪，继续查询</span><br><span class="line">inc dx;D7＝0，就绪，DX指向数据端口</span><br><span class="line">mov al,buf;变量buf送AL</span><br><span class="line">out dx,al;将数据输出给数据端口</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//查询方式的EEPROM编程</span><br><span class="line">next:mov al,55h;写入内容＝55H</span><br><span class="line">mov [bx],al;写入存储单元</span><br><span class="line">nop;空操作指令，起延时作用</span><br><span class="line">nop</span><br><span class="line">next1:in al,dx;查询状态口</span><br><span class="line">test al,01h;测试D0</span><br><span class="line">jz next1;D0＝0，芯片还在写入</span><br><span class="line">inc bx;D0＝1，写毕，指针移动</span><br><span class="line">loop next;循环至全部字节写完</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-中断传送方式"><a href="#3-中断传送方式" class="headerlink" title="3. 中断传送方式"></a>3. 中断传送方式</h5><ul><li>中断请求 =&gt;中断响应=&gt;关中断=&gt;断点保护=&gt;中断识别=&gt;现场保护=&gt;中断服务=&gt;恢复现场=&gt;开中断=&gt;中断返回</li><li>中断传送是一种效率更高的程序传送方式</li><li>进行传送的中断服务程序是预先设计好的</li><li>中断请求是外设随机向CPU提出的</li></ul><h5 id="4-DMA传送方式"><a href="#4-DMA传送方式" class="headerlink" title="4. DMA传送方式"></a>4. DMA传送方式</h5><ul><li>CPU对DMA控制器进行初始化设置</li><li>外设、DMAC和CPU三者通过应答信号建立联系：CPU将总线交给DMAC控制</li></ul><ol><li>DMA传送<br>DMA读存储器：存储器 → 外设<br>DMA写存储器：存储器 ← 外设</li><li>自动增减地址和计数，判断传送完成否</li></ol><p><strong>传送方式的比较</strong></p><ul><li>无条件传送：慢速外设需与CPU保持同步</li><li>查询传送： 简单实用，效率较低</li><li>中断传送：外设主动，可与CPU并行工作，但每次传送需要大量额外时间开销</li><li>DMA传送：DMAC控制，外设直接和存储器进行数据传送，适合大量、快速数据传送</li></ul><hr><h2 id="第四章-中断控制接口"><a href="#第四章-中断控制接口" class="headerlink" title="第四章 中断控制接口"></a>第四章 中断控制接口</h2><h3 id="1-8088中断系统"><a href="#1-8088中断系统" class="headerlink" title="1. 8088中断系统"></a>1. 8088中断系统</h3><ul><li>8088的中断系统采用向量中断机制</li><li>能够处理256个中断</li><li>用中断向量号0～255区别</li><li>可屏蔽中断还需要借助专用中断控制器Intel 8259A实现优先权管理</li></ul><h5 id="1-8088的中断类型"><a href="#1-8088的中断类型" class="headerlink" title="1. 8088的中断类型"></a>1. 8088的中断类型</h5><ul><li>内部中断:除法错中断、指令中断、溢出中断、单步中断</li><li>外部中断：非屏蔽中断、可屏蔽中断</li></ul><h5 id="2-8088的中断响应过程"><a href="#2-8088的中断响应过程" class="headerlink" title="2. 8088的中断响应过程"></a>2. 8088的中断响应过程</h5><p><img src="/image/04.png" alt="04"></p><ul><li>8088各种中断源的优先权，实际上是指被识别出来的先后</li><li>多种中断同时请求时，最先响应的则可能是单步中断或NMI中断</li></ul><p><img src="/image/05.png" alt="05"></p><h5 id="3-8088的中断向量表"><a href="#3-8088的中断向量表" class="headerlink" title="3. 8088的中断向量表"></a>3. 8088的中断向量表</h5><ul><li>中断向量：中断服务程序的入口地址（首地址）</li><li>逻辑地址含有段地址CS和偏移地址IP（32位）</li><li>每个中断向量的低字是偏移地址、高字是段地址，需占用4个字节</li><li>8088微处理器从物理地址00000H开始，依次安排各个中断向量，向量号也从0开始</li><li>256个中断占用1KB区域，就形成中断向量表</li><li>向量号为N的中断向量的物理地址＝N×4</li></ul><h3 id="2-内部中断服务程序"><a href="#2-内部中断服务程序" class="headerlink" title="2. 内部中断服务程序"></a>2. 内部中断服务程序</h3><h5 id="1-内部中断服务程序"><a href="#1-内部中断服务程序" class="headerlink" title="1. 内部中断服务程序"></a>1. 内部中断服务程序</h5><p>编写80H号中断服务程序<br>功能：显示以“0”结尾字符串的功能,利用显示器功能调用INT 10H，字符串缓冲区首地址为入口参数，DS:DX（段地址：偏移地址）传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    intoffdw ?//偏移</span><br><span class="line">intsegdw ?//段基址</span><br><span class="line">intmsgdb ‘A Instruction Interrupt !’//字符串</span><br><span class="line">db 0dh,0ah,0</span><br><span class="line">//保存中断向量</span><br><span class="line">    mov ax,3580h//AH＝35H，AL=中断向量号</span><br><span class="line">int 21h //DOS功能调用INT 21H</span><br><span class="line">mov intoff,bx;保存偏移地址</span><br><span class="line">mov intseg,es;保存段基地址</span><br><span class="line">    //设置中断向量</span><br><span class="line">    //设置中断向量（DOS功能调用INT 21H）</span><br><span class="line">    push ds</span><br><span class="line">    mov dx,offset new80h</span><br><span class="line">    mov ax,seg new80h</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,2580h//AH=25，AL＝中断向量号</span><br><span class="line">    int 21h</span><br><span class="line">    pop ds</span><br><span class="line">    //调用中断服务程序，设置入口参数：//DS＝段地址（已设置）</span><br><span class="line">//；DX＝偏移地址</span><br><span class="line">    mov dx,offset intmsg</span><br><span class="line">int 80h ；调用80H中断服务程序</span><br><span class="line">//主程序结束</span><br><span class="line">    mov dx,intoff</span><br><span class="line">mov ax,intseg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2580h</span><br><span class="line">int 21h</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">//进入中断服务程序</span><br><span class="line">new80hproc</span><br><span class="line">sti;开中断</span><br><span class="line">push ax;保护寄存器</span><br><span class="line">push bx</span><br><span class="line">push si</span><br><span class="line">mov si,dx</span><br><span class="line">//显示字符串</span><br><span class="line">new1:mov al,[si]</span><br><span class="line">cmp al,0</span><br><span class="line">jz new2</span><br><span class="line">mov bx,0</span><br><span class="line">mov ah,0eh</span><br><span class="line">int 10h</span><br><span class="line">inc si</span><br><span class="line">jmp new1</span><br><span class="line">//退出中断服务程序</span><br><span class="line">new2:pop si;恢复寄存器</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret;中断返回</span><br><span class="line">new80hendp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-8259A中断控制器"><a href="#3-8259A中断控制器" class="headerlink" title="3. 8259A中断控制器"></a>3. 8259A中断控制器</h3><h5 id="1-8259A的内部结构和引脚"><a href="#1-8259A的内部结构和引脚" class="headerlink" title="1. 8259A的内部结构和引脚"></a>1. 8259A的内部结构和引脚</h5><ol><li>中断控制</li></ol><ul><li>中断请求寄存器IRR<br>保存8条外界中断请求信号IR0～IR7的请求状态<br>Di位为1表示IRi引脚有中断请求；为0表示无请求</li><li>中断服务寄存器ISR<br>保存正在被8259A服务着的中断状态<br>Di位为1表示IRi中断正在服务中；为0表示没有被服务</li><li>中断屏蔽寄存器IMR<br>保存对中断请求信号IR的屏蔽状态<br>Di位为1表示IRi中断被屏蔽（禁止）；为0表示允许</li></ul><ol><li>与处理器接口</li></ol><p><img src="/image/06.png" alt="06"></p><ol><li>中断级连</li></ol><ul><li>一个系统中，8259A可以级连，有一个主8259A，若干个（最多8个）从8259A</li><li>级连时，主8259A的三条级连线CAS0～CAS2作为输出线，连至每个从8259A的CAS0～CAS2</li><li>SP<em>/EN</em>在非缓冲方式下，规定该8259A是主片（SP<em>＝1）还是从片（SP</em>＝0）</li></ul><h5 id="3-8259A的工作方式"><a href="#3-8259A的工作方式" class="headerlink" title="3. 8259A的工作方式"></a>3. 8259A的工作方式</h5><ol><li>设置优先权方式</li></ol><ul><li>普通全嵌套方式</li><li>特殊全嵌套方式</li><li>优先权自动循环方式</li></ul><ol><li>结束中断处理方式</li></ol><ul><li>8259A利用中断服务寄存器ISR判断：<br>某位为1，表示正在进行中断服务；<br>该位为0，就是该中断结束服务。</li><li>自动中断结束方式</li><li>普通中断结束方式，配合全嵌套优先权方式使用</li><li>特殊中断结束方式，配合循环优先权方式使用</li></ul><ol><li>屏蔽中断源方式</li></ol><ul><li>普通屏蔽方式<br>将IMR的Di位置1，则对应的中断IRi被屏蔽</li><li>特殊屏蔽方式<br>将IMR的Di位置1，对应的中断IRi被屏蔽的同时，使ISR的Di位置0</li></ul><ol><li>中断触发方式</li></ol><ul><li>边沿触发方式</li><li>电平触发方式</li></ul><ol><li>数据线连接方式</li></ol><ul><li>缓冲方式<br>8259A的数据线需加缓冲器予以驱动<br>8259A把SP<em>/EN</em>引脚作为输出端，输出允许信号，用以锁存或开启缓冲器</li><li>非缓冲方式<br>SP<em>/EN</em>引脚为输入端<br>若8259A级连，由其确定是主片或从片</li></ul><h5 id="4-8259A的编程"><a href="#4-8259A的编程" class="headerlink" title="4. 8259A的编程"></a>4. 8259A的编程</h5><ol><li>初始化命令字ICW</li></ol><ul><li>初始化命令字ICW最多有4个</li><li>8259A在开始工作前必须写入</li><li>必须按照ICW1～ICW4顺序写入</li><li>ICW1和ICW2是必须送的</li><li>ICW3和ICW4由工作方式决定</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">中断控制器的初始化程序段</span><br><span class="line">//初始化主片8259A</span><br><span class="line">mov al,11h;写入ICW1</span><br><span class="line">out 20h,al</span><br><span class="line">jmp intr1</span><br><span class="line">intr1:mov al,08h;写入ICW2</span><br><span class="line">out 21h,al</span><br><span class="line">jmp intr2</span><br><span class="line">intr2:mov al,04h;写入ICW3</span><br><span class="line">out 21h,al</span><br><span class="line">jmp intr3</span><br><span class="line">intr3:mov al,1h;写入ICW4</span><br><span class="line">out 21h,al</span><br><span class="line">//初始化从片8259A</span><br><span class="line">mov al,11h;写入ICW1</span><br><span class="line">out 0a0h,al</span><br><span class="line">jmp intr5</span><br><span class="line">intr5:mov al,70h;写入ICW2</span><br><span class="line">out 0a1h,al</span><br><span class="line">jmp intr6</span><br><span class="line">intr6:mov al,02h;写入ICW3</span><br><span class="line">out 0a1h,al</span><br><span class="line">jmp intr7</span><br><span class="line">intr7:mov al, 01h;写入ICW4</span><br><span class="line">out 0a1h,al</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>操作命令字OCW</li></ol><ul><li>OCW共有3个：OCW1～OCW3</li><li>写入时没有顺序要求，需要哪个OCW就写入那个OCW</li></ul><p><strong>应用注意事项</strong></p><ul><li>利用上升沿做为中断请求IRQ的有效信号</li><li>IRQ0～IRQ7的中断向量号依次为08H～0FH，IRQ8～IRQ15依次为70H～77H</li><li>采用普通全嵌套优先权方式，中断优先权从高到低顺序为IRQ0～IRQ2、IRQ8～IRQ15、IRQ3～IRQ7，且不能改变</li></ul><h5 id="5-外部中断服务程序"><a href="#5-外部中断服务程序" class="headerlink" title="5. 外部中断服务程序"></a>5. 外部中断服务程序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/*8259A的IRQ0（向量号为08H）中断请求来自定时器8253，每隔55ms产生一次</span><br><span class="line"></span><br><span class="line">本程序的08H号中断服务程序，每次中断显示一串信息，显示10次</span><br><span class="line">*/</span><br><span class="line">intmsgdb ‘A 8259A Interrupt !’</span><br><span class="line">         db 0dh,0ah,0</span><br><span class="line">counterdb 0</span><br><span class="line">mov ax,3508h</span><br><span class="line">int 21h</span><br><span class="line">push bx;保存偏移地址</span><br><span class="line">push es;保存段基地址</span><br><span class="line">//设置中断向量</span><br><span class="line">cli</span><br><span class="line">push ds</span><br><span class="line">mov dx,offset new08h</span><br><span class="line">mov ax,seg new08h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2508h</span><br><span class="line">int 21h</span><br><span class="line">pop ds</span><br><span class="line">//设置中断寄存器</span><br><span class="line">in al,21h</span><br><span class="line">push ax</span><br><span class="line">and al,0feh         ;允许IRQ0</span><br><span class="line">out 21h,al</span><br><span class="line">mov counter,0;设置中断次数初值</span><br><span class="line">sti         ;开中断</span><br><span class="line">//循环等待中断</span><br><span class="line">start1:cmp counter,10</span><br><span class="line"> jb start1          ;中断10次退出</span><br><span class="line"> //子程序结束</span><br><span class="line"> cli</span><br><span class="line">pop ax</span><br><span class="line">out 21h,al</span><br><span class="line">pop dx</span><br><span class="line">pop ds</span><br><span class="line">mov ax,2508h</span><br><span class="line">int 21h</span><br><span class="line">sti</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">        //进入中断服务程序</span><br><span class="line">new08hproc</span><br><span class="line">  sti         ;开中断</span><br><span class="line">  push ax;保护寄存器</span><br><span class="line">  push bx</span><br><span class="line">  push ds</span><br><span class="line">  mov ax,data</span><br><span class="line">  mov ds,ax;设置数据段DS</span><br><span class="line">//中断处理</span><br><span class="line">inc counter</span><br><span class="line">mov si,offset intmsg;显示信息</span><br><span class="line">call dpstri</span><br><span class="line">//</span><br><span class="line">     mov al,20h</span><br><span class="line">     out 20h,al</span><br><span class="line">     pop ds       ;恢复寄存器</span><br><span class="line">     pop bx</span><br><span class="line">     pop ax</span><br><span class="line">     iret       ;中断返回</span><br><span class="line">new08h endp</span><br><span class="line">//显示字符串</span><br><span class="line">dpstri proc        ;显示字符串子程序</span><br><span class="line"> push ax</span><br><span class="line"> push bx</span><br><span class="line">dps1: lodsb</span><br><span class="line"> cmp al,0</span><br><span class="line"> jz dps2</span><br><span class="line">//显示字符串</span><br><span class="line"> mov bx,0</span><br><span class="line"> mov ah,0eh</span><br><span class="line"> int 10h</span><br><span class="line"> jmp dps1</span><br><span class="line">dps2: pop bx</span><br><span class="line"> pop ax</span><br><span class="line"> ret</span><br><span class="line">dpstri endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第五章-定时计数控制接口"><a href="#第五章-定时计数控制接口" class="headerlink" title="第五章 定时计数控制接口"></a>第五章 定时计数控制接口</h2><h3 id="8253-8254定时计数器"><a href="#8253-8254定时计数器" class="headerlink" title="8253/8254定时计数器"></a>8253/8254定时计数器</h3><ul><li>3个独立的16位计数器通道</li><li>每个计数器有6种工作方式</li><li>按二进制或十进制（BCD码）计数</li></ul><ol><li>计数器结构分析</li></ol><ul><li>计数初值存于预置寄存器；</li><li>在计数过程中，减法计数器的值不断递减，而预置寄存器中的预置不变。</li><li>输出锁存器用于写入锁存命令时，锁定当前计数值</li></ul><ol><li>计数器的3个引脚</li></ol><ul><li>CLK时钟输入信号——在计数过程中，此引脚上每输入一个时钟信号（下降沿），计数器的计数值减1</li><li>GATE门控输入信号——控制计数器工作，可分成电平控制和上升沿控制两种类型</li><li>OUT计数器输出信号——当一次计数过程结束（计数值减为0），OUT引脚上将产生一个输出信号</li></ul><h3 id="8253-8254的工作方式"><a href="#8253-8254的工作方式" class="headerlink" title="8253/8254的工作方式"></a>8253/8254的工作方式</h3><ul><li>方式0 计数结束中断</li><li>方式1 可编程单稳脉冲</li><li>方式2 频率发生器（分频器）</li><li>方式3 方波发生器</li><li>方式4 软件触发选通信号</li><li>方式5 硬件触发选通信号</li></ul><ol><li>注意</li></ol><ul><li>处理器写入8253的计数初值只是写入了预置寄存器，之后到来的第一个CLK输入脉冲（需先由低电平变高，再由高变低）才将预置寄存器的初值送到减1计数器。</li><li>从第二个CLK信号的下降沿，计数器才真正开始减1计数。</li></ul><h3 id="8253-8254的编程"><a href="#8253-8254的编程" class="headerlink" title="8253/8254的编程"></a>8253/8254的编程</h3><hr><h2 id="第六章-DMA控制接口"><a href="#第六章-DMA控制接口" class="headerlink" title="第六章 DMA控制接口"></a>第六章 DMA控制接口</h2><h3 id="DMA控制器8237A"><a href="#DMA控制器8237A" class="headerlink" title="DMA控制器8237A"></a>DMA控制器8237A</h3><ul><li>每个8237A芯片有4个DMA通道，就是有4个DMA控制器</li><li>每个DMA通道具有不同的优先权</li><li>每个DMA通道可以分别允许和禁止</li><li>每个DMA通道有4种工作方式</li><li>一次传送的最大长度可达64KB</li><li>多个8237A芯片可以级连，扩展通道数</li></ul><h5 id="1-8237A的内部结构和引脚"><a href="#1-8237A的内部结构和引脚" class="headerlink" title="1. 8237A的内部结构和引脚"></a>1. 8237A的内部结构和引脚</h5><ol><li>请求与响应信号</li></ol><ul><li>DREQ0～DREQ3：DMA通道请求</li><li>HRQ：总线请求</li><li>HLDA：总线响应</li><li>DACK0～DACK3：DMA通道响应</li></ul><ol><li>DMA传送控制信号</li></ol><ul><li>A0～A7：地址线。输出低8位存储器地址。<br>DB0～DB7：数据线。输出高8位存储器地址</li><li>ADSTB：地址选通</li><li>AEN：地址允许。</li><li>MEMR*：存储器读</li><li>MEMW*：存储器写</li><li>IOR*：I/O读</li><li>IOW*：I/O写</li><li>READY：准备好</li><li>EOP*：过程结束。DMA传送过程结束，输出一个低有效脉冲。</li></ul><ol><li>处理器接口信号</li></ol><ul><li>DB0～DB7：数据线。</li><li>A0～A3：地址线。</li><li>CS*：片选</li><li>IOR*：I/O读。读取8237A内部寄存器。</li><li>IOW*：I/O写。写入8237A内部寄存器。</li><li>CLK：时钟。控制芯片内部操作和数据传输。</li><li>RESET：复位。使8237A处于初始状态。</li></ul><p><strong>8237A的两种工作状态</strong></p><ul><li>空闲周期：<br>作为接口电路，受CPU控制的工作状态</li><li>有效周期：<br>作为DMAC控制DMA传送的工作状态</li></ul><p><img src="/image/07.png" alt="07"></p><h5 id="2-8237A的工作时序·空闲周期"><a href="#2-8237A的工作时序·空闲周期" class="headerlink" title="2. 8237A的工作时序·空闲周期"></a>2. 8237A的工作时序·空闲周期</h5><p><strong>DMA传送时序</strong></p><ul><li>S1状态——输出16位存储器地址<br>AEN输出高电平，表示DMA传送</li><li>S2状态——输出DMA响应信号和控制信号<br>DMA读：MEMR<em>和IOW</em>有效<br>DMA写：IOR<em>和MEMW</em>有效</li><li>S3和Sw状态——检测数据传送是否能够完成，决定是否插入等待状态Sw</li><li>S4状态——完成数据传送</li></ul><h5 id="3-8237A的工作方式"><a href="#3-8237A的工作方式" class="headerlink" title="3. 8237A的工作方式"></a>3. 8237A的工作方式</h5><ol><li>DMA传送方式</li></ol><ul><li>单字节传送方式：一次传送一个字节，效率略低，<br>DMA传送之间CPU有机会重新获取总线控制权</li><li>数据块传送方式：一次请求传送一个数据块，效率高，<br>整个DMA传送期间CPU长时间无法控制总线</li><li>请求传送方式<br>DREQ信号有效就连续传送数据<br>DREQ信号无效，DMA传送被暂时中止，8237A释放总线，CPU可继续操作</li><li>级连方式</li></ul><ol><li>DMA传送类型<br>· DMA读 · DMA写 · DMA检验</li><li>DMA通道的优先权方式</li></ol><ul><li>固定优先权方式——优先权固定：0，1，2.。。</li><li>循环优先权方式——优先权循环变化</li></ul><ol><li>自动初始化方式</li></ol><h5 id="4-8237A的寄存器"><a href="#4-8237A的寄存器" class="headerlink" title="4. 8237A的寄存器"></a>4. 8237A的寄存器</h5><ol><li>通道寄存器（4个通道分别具有）：基地址寄存器、基字节数寄存器、现行地址寄存器、现行字节数寄存器。</li><li>状态、命令寄存器：命令寄存器、状态寄存器、请求寄存器、方式寄存器、屏蔽寄存器、临时寄存器</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微机原理与接口技术&quot;&gt;&lt;a href=&quot;#微机原理与接口技术&quot; class=&quot;headerlink&quot; title=&quot;微机原理与接口技术&quot;&gt;&lt;/a&gt;微机原理与接口技术&lt;/h1&gt;&lt;h2 id=&quot;第一章-微型计算机系统概述&quot;&gt;&lt;a href=&quot;#第一章-微型计算机系统概</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="微机原理" scheme="https://blog.haodene.love/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    <category term="基础学习" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C语言基础篇</title>
    <link href="https://blog.haodene.love/2023/06/15/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://blog.haodene.love/2023/06/15/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-06-15T08:30:00.000Z</published>
    <updated>2023-07-25T10:52:18.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言笔记"><a href="#C语言笔记" class="headerlink" title="C语言笔记"></a>C语言笔记</h1><h2 id="1-C语言概述"><a href="#1-C语言概述" class="headerlink" title="1. C语言概述"></a>1. C语言概述</h2><h3 id="1-1-C语言"><a href="#1-1-C语言" class="headerlink" title="1.1 C语言"></a>1.1 C语言</h3><p>​    一提到语言这个词语，自然会想到的是像英语、汉语等这样的自然语言，因为它是人和人交换信息不可缺少的工具。</p><p>而今天计算机遍布了我们生活的每一个角落，除了人和人的相互交流之外，我们必须和计算机角落。</p><p>用什么的什么样的方式和计算机做最直接的交流呢？人们自然想到的是最古老也最方便的方式——语言，而C语言就是人和计算机交流的一种语言。</p><p>语言是用来交流沟通的。有一方说，有另一方听，必须有两方参与，这是语言最重要的功能：</p><blockquote><p> 说的一方传递信息，听的一方接收信息；</p><p>说的一方下达指令，听的一方遵循命令做事情。</p></blockquote><p>语言是人和人交流，C语言是人和机器交流。只是，人可以不听另外一个人，但是，计算机是无条件服从。</p><p>语言有独特的语法规则和定义，双方必须遵循这些规则和定义才能实现真正的交流。</p><h4 id="1-1-1-计算机结构组成"><a href="#1-1-1-计算机结构组成" class="headerlink" title="1.1.1  计算机结构组成"></a>1.1.1  计算机结构组成</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291928379.jpg" alt="image"></p><h3 id="1-2-为什么学C语言"><a href="#1-2-为什么学C语言" class="headerlink" title="1.2 为什么学C语言"></a>1.2 为什么学C语言</h3><h4 id="1-2-1-C语言特点"><a href="#1-2-1-C语言特点" class="headerlink" title="1.2.1 C语言特点"></a>1.2.1 C语言特点</h4><ul><li>优点<ul><li>代码量小</li><li>执行速度快</li><li>功能强大</li><li>编程自由</li></ul></li><li>缺点<ul><li>写代码实现周期长</li><li>可移植性较差</li><li>过于自由，经验不足易出错</li><li>对平台库依赖较多 </li></ul></li></ul><h4 id="1-2-2-学习C语言理由"><a href="#1-2-2-学习C语言理由" class="headerlink" title="1.2.2 学习C语言理由"></a>1.2.2 学习C语言理由</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291928243.jpg" alt="image"></p><h4 id="1-2-3-C语言应用领域"><a href="#1-2-3-C语言应用领域" class="headerlink" title="1.2.3 C语言应用领域"></a>1.2.3 C语言应用领域</h4><p>C语言的应用极其广泛，从网站后台，到底层操作系统，从多媒体应用到大型网络游戏，均可使用C语言来开发：</p><ul><li><p>C语言可以写网站后台程序</p></li><li><p>C语言可以专门针对某个主题写出功能强大的程序库</p></li><li><p>C语言可以写出大型游戏的引擎</p></li><li><p>C语言可以写出另一个语言来</p></li><li><p>C语言可以写操作系统和驱动程序，并且只能用C语言编写</p></li><li><p>任何设备只要配置了微处理器，就都支持C语言。从微波炉到手机，都是由C语言技术来推动的</p></li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291928437.png" alt="image"></p><h4 id="1-2-4-C语言关键字"><a href="#1-2-4-C语言关键字" class="headerlink" title="1.2.4 C语言关键字"></a>1.2.4 C语言关键字</h4><blockquote><p>C语言仅有32个关键字，9种控制语句，34种运算符，却能完成无数的功能：</p></blockquote><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291929232.jpg" alt="image"></p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291929026.jpg" alt="image"></p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011654487.jpeg" alt="image"></p><h3 id="1-3-第一个C语言程序：HelloWorld"><a href="#1-3-第一个C语言程序：HelloWorld" class="headerlink" title="1.3 第一个C语言程序：HelloWorld"></a>1.3 第一个C语言程序：HelloWorld</h3><h4 id="1-3-1-编写C语言代码：hello-c"><a href="#1-3-1-编写C语言代码：hello-c" class="headerlink" title="1.3.1 编写C语言代码：hello.c"></a>1.3.1 编写C语言代码：hello.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// 第一个C语言程序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言的源代码文件是一个普通的文本文件，<font color="red">但扩展名必须是.c</font></p></blockquote><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291930758.png" alt="image-20200919090134713"></p><h4 id="1-3-2-通过gcc编译C代码"><a href="#1-3-2-通过gcc编译C代码" class="headerlink" title="1.3.2 通过gcc编译C代码"></a>1.3.2 通过gcc编译C代码</h4><h5 id="1-gcc编译器介绍"><a href="#1-gcc编译器介绍" class="headerlink" title="1. gcc编译器介绍"></a>1. gcc编译器介绍</h5><p>编辑器(如vi、记事本)是指我用它来写程序的（编辑代码），而我们写的代码语句，电脑是不懂的，我们需要把它转成电脑能懂的语句，编译器就是这样的转化工具。就是说，<font color="red">我们用编辑器编写程序，由编译器编译后才可以运行！</font></p><p>编译器是将易于编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低级机器语言的程序</p><p>gcc（GNU Compiler Collection，GNU 编译器套件），是由 GNU 开发的编程语言编译器。gcc原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，gcc同样适用于微软的Windows</p><p>gcc最初用于编译C语言，随着项目的发展gcc已经成为了能够编译C、C++、Java、Ada、fortran、Object C、Object C++、Go语言的编译器大家族</p><p>编译命令格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc [-option1] ... &lt;filename&gt;</span><br><span class="line">g++ [-option1] ... &lt;filename&gt;</span><br></pre></td></tr></table></figure><ul><li><p>命令、选项和源文件之间使用空格分隔</p></li><li><p>一行命令中可以有零个、一个或多个选项</p></li><li><p>文件名可以包含文件的绝对路径，也可以使用相对路径</p></li><li><p>如果命令中不包含输出可执行文件的文件名，可执行文件的文件名会自动生成一个默认名，Linux平台为<code>a.out</code>，Windows平台为<code>a.exe</code></p></li></ul><p>gcc、g++编译常用选项说明：</p><div class="table-container"><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-o file</td><td>指定生成的输出文件名为file</td></tr><tr><td>-E</td><td>只进行预处理</td></tr><tr><td>-S(大写)</td><td>只进行预处理和编译</td></tr><tr><td>-c(小写)</td><td>只进行预处理、编译和汇编</td></tr></tbody></table></div><h5 id="2-Windows平台下gcc环境配置"><a href="#2-Windows平台下gcc环境配置" class="headerlink" title="2. Windows平台下gcc环境配置"></a>2. Windows平台下gcc环境配置</h5><blockquote><p>windows命令行界面下，默认是没有gcc编译器，我们需要配置一下环境</p><p><code>MinGW</code>, 安装使用教程参看：<a href="https://blog.csdn.net/wxh0000mm/article/details/100666329">MinGW安装教程</a></p></blockquote><h5 id="3-linux平台下gcc环境配置"><a href="#3-linux平台下gcc环境配置" class="headerlink" title="3. linux平台下gcc环境配置"></a>3. linux平台下gcc环境配置</h5><blockquote><p>参考教程：<a href="https://blog.csdn.net/lydong_/article/details/79812402">详解Linux安装GCC方法</a></p></blockquote><h4 id="1-3-3-代码分析"><a href="#1-3-3-代码分析" class="headerlink" title="1.3.3 代码分析"></a>1.3.3 代码分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include的意思是头文件包含,</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;代表包含stdio.h这个头文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用C语言库函数需要提前包含库函数对应的头文件，如这里使用了printf()函数，需要包含stdio.h头文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// 第一个C语言程序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); <span class="comment">// 可以通过man 3 printf查看printf所需的头文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-include头文件包含"><a href="#1-include头文件包含" class="headerlink" title="1. include头文件包含"></a>1. include头文件包含</h5><ul><li><p><code>#include&lt; &gt;</code> 与 <code>#include &quot;&quot;</code>的区别：</p></li><li><p><code>&lt; &gt;</code> 表示系统<font color="red">直接</font>按系统指定的目录检索</p></li><li><p><code>&quot; &quot;</code> 表示系统<font color="red">先</font>在<code>&quot; &quot;</code>指定的路径(没写路径代表当前路径)查找头文件，如果找不到，<font color="red">再</font>按系统指定的目录检索</p></li></ul><p><code>stdio.h</code> 在操作系统<code>/usr/include/</code>目录下</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291930778.png" alt="image-20200919092034856"></p><h5 id="2-main函数"><a href="#2-main函数" class="headerlink" title="2. main函数"></a>2. main函数</h5><ul><li>一个完整的C语言程序，是由一个、<font color="red">且只能有一个</font><code>main()</code>函数(又称主函数，必须有)和若干个其他函数结合而成（可选）</li><li><code>main</code>函数是C语言程序的入口，程序是从main函数开始执行</li></ul><h5 id="3-括号，程序体和代码块"><a href="#3-括号，程序体和代码块" class="headerlink" title="3. {} 括号，程序体和代码块"></a>3. {} 括号，程序体和代码块</h5><ul><li><code>&#123;&#125;</code>叫代码块，一个代码块内部可以有一条或者多条语句</li><li>C语言每句可执行代码都是”<code>;</code>“分号结尾</li><li>所有的<code>#</code>开头的行，都代表预编译指令，预编译指令行结尾是没有分号的</li><li>所有的可执行语句必须是在代码块里面</li></ul><h5 id="4-注释"><a href="#4-注释" class="headerlink" title="4.  注释"></a>4.  注释</h5><ul><li><code>//</code>叫行注释，注释的内容编译器是忽略的，注释主要的作用是在代码中加一些说明和解释，这样有利于代码的阅读</li><li><code>/**/</code>叫块注释</li><li>块注释是C语言标准的注释方法</li><li>行注释是从C++语言借鉴过来的</li></ul><h5 id="5-printf函数"><a href="#5-printf函数" class="headerlink" title="5. printf函数"></a>5. printf函数</h5><ul><li><p><code>printf</code>是C语言库函数，功能是向标准输出设备输出一个字符串</p></li><li><p><code>printf(“hello world\n”);</code> //<code>\n</code>的意思是回车换行</p></li></ul><h5 id="6-return语句"><a href="#6-return语句" class="headerlink" title="6.  return语句"></a>6.  return语句</h5><ul><li><p><code>return</code> 代表函数执行完毕，返回return代表函数的终止</p></li><li><p>如果main定义的时候前面是<code>int</code>，那么return后面就需要写一个整数；如果main定义的时候前面是<code>void</code>，那么return后面什么也不需要写</p></li><li><p>在main函数中<code>return 0</code>代表程序执行成功，<code>return -1</code>代表程序执行失败</p></li><li><p><code>int main()</code>和<code>void main()</code>在C语言中是一样的，但C++只接受<code>int main</code>这种定义方式</p></li></ul><h3 id="1-4-system函数"><a href="#1-4-system函数" class="headerlink" title="1.4 system函数"></a>1.4 system函数</h3><h4 id="1-4-1-system函数的使用"><a href="#1-4-1-system函数的使用" class="headerlink" title="1.4.1 system函数的使用"></a>1.4.1 system函数的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：在已经运行的程序中执行另外一个外部程序<br>参数：外部可执行程序名字<br>返回值：<br>成功：0<br>失败：任意数字</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//system(&quot;calc&quot;); //windows平台</span></span><br><span class="line">system(<span class="string">&quot;ls&quot;</span>); <span class="comment">//Linux平台, 需要头文件#include &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291931743.png" alt="image-20200919094712699"></p><h3 id="1-5-C语言编译过程"><a href="#1-5-C语言编译过程" class="headerlink" title="1.5 C语言编译过程"></a>1.5 C语言编译过程</h3><h4 id="1-5-1-C程序编译步骤"><a href="#1-5-1-C程序编译步骤" class="headerlink" title="1.5.1 C程序编译步骤"></a>1.5.1 C程序编译步骤</h4><blockquote><p>C代码编译成可执行程序经过4步：</p></blockquote><ol><li>预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法</li><li>编译：检查语法，将预处理后文件编译生成汇编文件</li><li>汇编：将汇编文件生成目标文件(二进制文件)</li><li>链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</li></ol><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291931803.png" alt=""></p><blockquote><p>VS 执行结果一闪而过的解决方法：</p></blockquote><ol><li><p><code>system(&quot;pause&quot;);</code></p></li><li><p><code>项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;系统-&gt;子系统-&gt;控制台 增加“/SUBSYSTEM:CONSOLE”链接选项即可</code></p></li></ol><h4 id="1-5-2-gcc-编译过程"><a href="#1-5-2-gcc-编译过程" class="headerlink" title="1.5.2 gcc 编译过程"></a>1.5.2 gcc 编译过程</h4><h5 id="1-分步编译"><a href="#1-分步编译" class="headerlink" title="1. 分步编译"></a>1. 分步编译</h5><blockquote><p>预处理：<code>gcc -E introduce.c -o introduce.i</code></p><p>编 译：<code>gcc -S introduce.i -o introduce.s</code></p><p>汇 编：<code>gcc -c introduce.s -o introduce.o</code></p><p>链 接：<code>gcc  introduce.o -o introduce</code></p></blockquote><div class="table-container"><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-E</td><td>只进行预处理</td></tr><tr><td>-S(大写)</td><td>只进行预处理和编译</td></tr><tr><td>-c(小写)</td><td>只进行预处理、编译和汇编</td></tr><tr><td>-o file</td><td>指定生成的输出文件名为 file</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>文件后缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>.c</td><td>C 语言文件</td></tr><tr><td>.i</td><td>预处理后的 C 语言文件</td></tr><tr><td>.s</td><td>编译后的汇编文件</td></tr><tr><td>.o</td><td>编译后的目标文件</td></tr></tbody></table></div><p>编译的时候最后两倒数第二步的时候用了大写<code>C</code></p><p><code>gcc -C introduce.s -o introduce.o</code></p><p><code>gcc introduce.o -o introduce</code></p><p>导致了如下问题， 记录一下</p><p>/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/Scrt1.o: in function <code>_start&#39;:(.text+0x20): undefined reference to</code>main’<br>collect2: error: ld returned 1 exit status</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932904.png" alt="image-20200919101105887"></p><p>正确的编译过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -E introduce.c -o introduce.i</span><br><span class="line">gcc -S introduce.i -o introduce.s</span><br><span class="line">gcc -c introduce.s -o introduce.o</span><br><span class="line">gcc introduce.o -o introduce</span><br><span class="line">./introduce </span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932709.png" alt="image-20200919101944251"></p><h5 id="2-一步编译"><a href="#2-一步编译" class="headerlink" title="2. 一步编译"></a>2. 一步编译</h5><p><code>gcc introduce.c -o introduce1</code> // 自动完成：预处理、编译、汇编、链接的过程</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932690.png" alt="image-20200919102259922"></p><h4 id="1-5-3-查找程序所依赖的动态库"><a href="#1-5-3-查找程序所依赖的动态库" class="headerlink" title="1.5.3  查找程序所依赖的动态库"></a>1.5.3  查找程序所依赖的动态库</h4><p>Windows平台下，需要相应软件(<code>Depends.exe</code>)：</p><blockquote><p>工具下载地址：<a href="http://www.dependencywalker.com/">http://www.dependencywalker.com/</a></p></blockquote><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932876.png" alt="image-20200919102850515"></p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932693.png" alt="image-20200919102938934"></p><h3 id="1-6-CPU内部结构与寄存器-了解"><a href="#1-6-CPU内部结构与寄存器-了解" class="headerlink" title="1.6 CPU内部结构与寄存器(了解)"></a>1.6 CPU内部结构与寄存器(了解)</h3><h4 id="1-6-1-64位和32位系统区别"><a href="#1-6-1-64位和32位系统区别" class="headerlink" title="1.6.1 64位和32位系统区别"></a>1.6.1 64位和32位系统区别</h4><ul><li>寄存器是CPU内部最基本的存储单元</li><li><p>CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，<font color="red">总线的宽度是8位，同时CPU的寄存器也是8位</font>，那么这个CPU就叫8位CPU</p></li><li><p>如果总线是32位，寄存器也是32位的，那么这个CPU就是32位CPU</p></li><li>有一种CPU内部的寄存器是32位的，但总线是16位，准32为CPU</li><li>所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上是可以识别32位的指令</li><li>在64位的CPU构架上运行了64位的软件操作系统，那么这个系统是64位</li><li>在64位的CPU构架上，运行了32位的软件操作系统，那么这个系统就是32位</li><li>64位的软件不能运行在32位的CPU之上</li></ul><h4 id="1-6-2-寄存器名字-了解"><a href="#1-6-2-寄存器名字-了解" class="headerlink" title="1.6.2 寄存器名字(了解)"></a>1.6.2 寄存器名字(了解)</h4><div class="table-container"><table><thead><tr><th><strong>8</strong>位</th><th><strong>16</strong>位</th><th><strong>32</strong>位</th><th><strong>64</strong>位</th></tr></thead><tbody><tr><td>A</td><td>AX</td><td>EAX</td><td>RAX</td></tr><tr><td>B</td><td>BX</td><td>EBX</td><td>RBX</td></tr><tr><td>C</td><td>CX</td><td>ECX</td><td>RCX</td></tr><tr><td>D</td><td>DX</td><td>EDX</td><td>RDX</td></tr></tbody></table></div><h4 id="1-6-3-寄存器、缓存、内存三者关系"><a href="#1-6-3-寄存器、缓存、内存三者关系" class="headerlink" title="1.6.3 寄存器、缓存、内存三者关系"></a>1.6.3 寄存器、缓存、内存三者关系</h4><p>按与CPU远近来分，离得最近的是寄存器，然后缓存(CPU缓存)，最后内存。</p><p>CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是 CPU&lt;—-&gt;寄存器&lt;—-&gt;内存，这就是它们之间的信息交换。</p><p>那为什么有缓存呢？因为如果经常操作内存中的同一址地的数据，就会影响速度。于是就在寄存器与内存之间设置一个缓存。</p><p>因为从存提取的速度远高于内存。当然缓存的价格肯定远远高于内存，不然的话，机器里就没有内存的存在。</p><p>由此可以看出，从远近来看：<font color="red">CPU〈—-〉寄存器〈—-&gt; 缓存 &lt;—-&gt; 内存</font></p><h3 id="1-7-汇编语言"><a href="#1-7-汇编语言" class="headerlink" title="1.7 汇编语言"></a>1.7 汇编语言</h3><h4 id="1-7-1-VS中C语言嵌套汇编代码-了解"><a href="#1-7-1-VS中C语言嵌套汇编代码-了解" class="headerlink" title="1.7.1 VS中C语言嵌套汇编代码(了解)"></a>1.7.1 VS中C语言嵌套汇编代码(了解)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义整型变量a, b, c</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov a, <span class="number">3</span><span class="comment">//3的值放在a对应内存的位置</span></span><br><span class="line">mov b, <span class="number">4</span><span class="comment">//4的值放在b对应内存的位置</span></span><br><span class="line">mov eax, a<span class="comment">//把a内存的值放在eax寄存器</span></span><br><span class="line">add eax, b<span class="comment">//eax和b相加，结果放在eax</span></span><br><span class="line">mov c, eax<span class="comment">//eax的值放在c中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,  c);<span class="comment">//把c的值输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//成功完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-2-VS反编译"><a href="#1-7-2-VS反编译" class="headerlink" title="1.7.2 VS反编译"></a>1.7.2 VS反编译</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义整型变量a, b, c</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,  c);<span class="comment">//把c的值输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//成功完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-集成开发环境IDE"><a href="#1-8-集成开发环境IDE" class="headerlink" title="1.8 集成开发环境IDE"></a>1.8 集成开发环境IDE</h3><p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，<font color="red">一般包括代码编辑器、编译器、调试器和图形用户界面工具</font>。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p><h4 id="1-8-1-Qt-Creator"><a href="#1-8-1-Qt-Creator" class="headerlink" title="1.8.1 Qt Creator"></a>1.8.1 Qt Creator</h4><p>Qt Creator是跨平台的 Qt IDE， Qt Creator 是 Qt 被 Nokia 收购后推出的一款新的轻量级集成开发环境（IDE）。此 IDE 能够跨平台运行，支持的系统包括 Linux（32 位及 64 位）、Mac OS X 以及 Windows。根据官方描述，Qt Creator 的设计目标是使开发人员能够利用 Qt 这个应用程序框架更加快速及轻易的完成开发任务。</p><div class="table-container"><table><thead><tr><th><strong>快捷键</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>Ctrl + i</td><td>自动格式化代码</td></tr><tr><td>Ctrl + /</td><td>注释/取消注释</td></tr><tr><td>Alt + Enter</td><td>自动完成类函数定义</td></tr><tr><td>F4</td><td>.h 文件和对应.cpp 文件切换</td></tr><tr><td>F9</td><td>设置断点</td></tr><tr><td>F5</td><td>调试运行</td></tr><tr><td>Ctrl + r</td><td>编译，但不调试运行</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Ctrl + b</th><th>编译，不运行</th></tr></thead><tbody><tr><td>F10</td><td>next调试</td></tr><tr><td>F11</td><td>step调试</td></tr></tbody></table></div><h4 id="1-8-2-Microsoft-Visual-Studio"><a href="#1-8-2-Microsoft-Visual-Studio" class="headerlink" title="1.8.2 Microsoft Visual Studio"></a>1.8.2 Microsoft Visual Studio</h4><p>Microsoft Visual Studio（简称VS）是美国微软公司的开发工具包系列产品。VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等,所写的目标代码适用于微软支持的所有平台。Visual Studio是目前最流行的Windows平台应用程序的集成开发环境。</p><h5 id="1-VS常用快捷键"><a href="#1-VS常用快捷键" class="headerlink" title="1. VS常用快捷键"></a>1. VS常用快捷键</h5><div class="table-container"><table><thead><tr><th><strong>快捷键</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>Ctrl + k,Ctrl + f</td><td>自动格式化代码</td></tr><tr><td>Ctrl + k,Ctrl + c</td><td>注释代码</td></tr><tr><td>Ctrl + k,Ctrl + u</td><td>取消注释代码</td></tr><tr><td>F9</td><td>设置断点</td></tr><tr><td>F5</td><td>调试运行</td></tr><tr><td>Ctrl + F5</td><td>不调试运行</td></tr><tr><td>Ctrl + Shift + b</td><td>编译，不运行</td></tr><tr><td>F10</td><td>next调试</td></tr><tr><td>F11</td><td>step调试</td></tr></tbody></table></div><h5 id="2-VS2013的C4996错误"><a href="#2-VS2013的C4996错误" class="headerlink" title="2. VS2013的C4996错误"></a>2. VS2013的C4996错误</h5><p>由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误：</p><p>VS建议采用带_s的函数，如scanf_s、strcpy_s，但这些并不是标准C函数。</p><p>要想继续使用此函数，<font color="red">需要在源文件中添加以下指令就可以避免这个错误提示</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS     <span class="comment">//这个宏定义最好要放到.c文件的第一行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)<span class="comment">//或者使用这个</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><h3 id="2-1-常量与变量"><a href="#2-1-常量与变量" class="headerlink" title="2.1 常量与变量"></a>2.1 常量与变量</h3><h4 id="2-1-1-关键字"><a href="#2-1-1-关键字" class="headerlink" title="2.1.1 关键字"></a>2.1.1 关键字</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932973.jpg" alt="06-01_125457"></p><h4 id="2-1-2-数据类型"><a href="#2-1-2-数据类型" class="headerlink" title="2.1.2 数据类型"></a>2.1.2 数据类型</h4><blockquote><p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小</p></blockquote><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291932774.jpg" alt="06-01_125610"></p><h4 id="2-1-3-常量"><a href="#2-1-3-常量" class="headerlink" title="2.1.3 常量"></a>2.1.3 常量</h4><p>常量：</p><ul><li>在程序运行过程中，其值不能被改变的量</li><li>常量一般出现在表达式或赋值语句中</li></ul><div class="table-container"><table><thead><tr><th>整型常量</th><th>100，200，-100，0</th></tr></thead><tbody><tr><td>实型常量</td><td>3.14  ， 0.125，-3.123</td></tr><tr><td>字符型常量</td><td>‘a’,‘b’,‘1’,‘\n’</td></tr><tr><td>字符串常量</td><td>“a”,“ab”，“12356”</td></tr></tbody></table></div><h4 id="2-1-4-变量"><a href="#2-1-4-变量" class="headerlink" title="2.1.4 变量"></a>2.1.4 变量</h4><h5 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h5><ul><li>在程序运行过程中，其值可以改变</li><li><font color="red">变量在使用前必须先定义，定义变量前必须有相应的数据类型</font></li></ul><p>标识符命名规则：</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><p>变量特点：</p><ul><li>变量在编译时为其分配相应的内存空间</li><li>可以通过其<font color="red">名字</font>和<font color="red">地址</font>&gt;访问相应内存</li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291933515.jpg" alt="05-29_200452_副本"></p><h5 id="2-声明和定义区别"><a href="#2-声明和定义区别" class="headerlink" title="2. 声明和定义区别"></a>2. 声明和定义区别</h5><ul><li>声明变量不需要建立存储空间，如：<code>extern int a;</code></li><li>定义变量需要建立存储空间，如：<code>int b;</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//extern 关键字只做声明，不能做任何定义，后面还会学习，这里先了解</span></span><br><span class="line"><span class="comment">//声明一个变量a，a在这里没有建立存储空间</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line">a = <span class="number">10</span>;<span class="comment">//err, 没有空间，就不可以赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;<span class="comment">//定义一个变量b，b的类型为int，b赋值为10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从广义的角度来讲声明中包含着定义，即<font color="red">定义是声明的一个特例</font>，所以并非所有的声明都是定义：</p><ul><li><p><code>int b</code> 它既是声明，同时又是定义</p></li><li><p>对于 <code>extern b</code>来讲它只是声明不是定义</p></li></ul><blockquote><p>一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”</p></blockquote><h4 id="2-1-5-使用示例"><a href="#2-1-5-使用示例" class="headerlink" title="2.1.5 使用示例"></a>2.1.5 使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10 <span class="comment">//声明了一个常量，名字叫MAX，值是10，常量的值一旦初始化不可改</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;<span class="comment">//定义了一个变量，其类型为int，名字叫a</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>; <span class="comment">//定义一个const常量，名为叫b，值为10</span></span><br><span class="line"><span class="comment">//b = 11; //err,常量的值不能改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MAX = 100;//err,常量的值不能改变</span></span><br><span class="line"></span><br><span class="line">a = MAX;<span class="comment">//将abc的值设置为MAX的值</span></span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">//打印变量a的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-整数：int"><a href="#2-2-整数：int" class="headerlink" title="2.2 整数：int"></a>2.2 整数：int</h3><h4 id="2-2-1-整型变量的定义和输出"><a href="#2-2-1-整型变量的定义和输出" class="headerlink" title="2.2.1 整型变量的定义和输出"></a>2.2.1 整型变量的定义和输出</h4><div class="table-container"><table><thead><tr><th><strong>打印格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%d</td><td>输出一个<font color="red">有符号</font>的10进制int类型</td></tr><tr><td>%o(字母o)</td><td>输出8进制的int类型</td></tr><tr><td>%x</td><td>输出16进制的int类型，字母以小写输出</td></tr><tr><td>%X</td><td>输出16进制的int类型，字母以大写输出</td></tr><tr><td>%u</td><td>输出一个10进制的<font color="red">无符号</font>数</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>;<span class="comment">//定义变量a，以10进制方式赋值为123</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0567</span>;<span class="comment">//定义变量b，以8进制方式赋值为0567</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xabc</span>;<span class="comment">//定义变量c，以16进制方式赋值为0xabc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;8进制：b = %o\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;10进制：b = %d\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;16进制：c = %x\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;16进制：c = %X\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;10进制：c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> d = <span class="number">0xffffffff</span>; <span class="comment">//定义无符号int变量d，以16进制方式赋值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;有符号方式打印：d = %d\n&quot;</span>, d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;无符号方式打印：d = %u\n&quot;</span>, d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291933839.png" alt="image-20200919133924510"></p><h4 id="2-2-2-整型变量的输入"><a href="#2-2-2-整型变量的输入" class="headerlink" title="2.2.2 整型变量的输入"></a>2.2.2 整型变量的输入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入a的值：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要加&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a); <span class="comment">//打印a的值</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-3-short、int、long、long-long"><a href="#2-2-3-short、int、long、long-long" class="headerlink" title="2.2.3 short、int、long、long long"></a>2.2.3 short、int、long、long long</h4><div class="table-container"><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td></tr><tr><td>int(整型)</td><td>4字节</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td></tr></tbody></table></div><blockquote><p>注意：</p></blockquote><ul><li>整型数据在内存中占的字节数与所选择的操作系统有关。虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型</li><li><font color="red">当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位</font></li></ul><div class="table-container"><table><thead><tr><th><strong>整型常量</strong></th><th><strong>所需类型</strong></th></tr></thead><tbody><tr><td>10</td><td>代表int类型</td></tr><tr><td>10l, 10L</td><td>代表long类型</td></tr><tr><td>10ll, 10LL</td><td>代表long long类型</td></tr><tr><td>10u, 10U</td><td>代表unsigned int类型</td></tr><tr><td>10ul, 10UL</td><td>代表unsigned long类型</td></tr><tr><td>10ull, 10ULL</td><td>代表unsigned long long类型</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>打印格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%hd</td><td>输出short类型</td></tr><tr><td><font color="red">%d  </font></td><td><font color="red">  输出int类型 </font></td></tr><tr><td>%ld</td><td>输出long类型</td></tr><tr><td>%lld</td><td>输出long long类型</td></tr><tr><td>%hu</td><td>输出unsigned short类型</td></tr><tr><td><font color="red">%u</font></td><td><font color="red">输出unsigned int类型  </font></td></tr><tr><td><font color="red">%lu  </font></td><td><font color="red">输出unsigned long类&lt;/型</font></td></tr><tr><td>%llu</td><td>输出unsigned long long类型</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> c = <span class="number">10l</span>; <span class="comment">//或者10L</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d = <span class="number">10ll</span>; <span class="comment">//或者10LL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %u\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %u\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %u\n&quot;</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %u\n&quot;</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;short a = %hd\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int b = %d\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long c = %ld\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long long d = %lld\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a2 = <span class="number">20u</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b2 = <span class="number">20u</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> c2= <span class="number">20ul</span>; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> d2 = <span class="number">20ull</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsigned short a = %hu\n&quot;</span>, a2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsigned int b = %u\n&quot;</span>, b2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsigned long c = %lu\n&quot;</span>, c2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsigned long long d = %llu\n&quot;</span>, d2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.2.3 </span><br><span class="line">sizeof(a) = 2</span><br><span class="line">sizeof(b) = 4</span><br><span class="line">sizeof(c) = 8</span><br><span class="line">sizeof(c) = 8</span><br><span class="line">short a = 10</span><br><span class="line">int b = 10</span><br><span class="line">long c = 10</span><br><span class="line">long long d = 10</span><br><span class="line">unsigned short a = 20</span><br><span class="line">unsigned int b = 20</span><br><span class="line">unsigned long c = 20</span><br><span class="line">unsigned long long d = 20</span><br></pre></td></tr></table></figure><h4 id="2-2-4-有符号数和无符号数区别"><a href="#2-2-4-有符号数和无符号数区别" class="headerlink" title="2.2.4 有符号数和无符号数区别"></a>2.2.4 有符号数和无符号数区别</h4><h5 id="1-有符号数"><a href="#1-有符号数" class="headerlink" title="1. 有符号数"></a>1. 有符号数</h5><blockquote><p>有符号数是最高位为符号位，0代表正数，1代表负数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> a = <span class="number">-1089474374</span>; <span class="comment">//定义有符号整型变量a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, a); <span class="comment">//结果为 BF0FF0BA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//B    F    0    F    F    0    B A</span></span><br><span class="line"><span class="comment">//1011 1111 0000 1111 1111 0000 1011 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出： BF0FF0BA</p></blockquote><h5 id="2-无符号数"><a href="#2-无符号数" class="headerlink" title="2. 无符号数"></a>2. 无符号数</h5><p><strong>无符号数最高位不是符号位, 而就是数的一部分，无符号数不可能是负数</strong></p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307061549906.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">3236958022</span>; <span class="comment">//定义无符号整型变量a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%X\n&quot;</span>, a); <span class="comment">//结果为 C0F00F46</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当我们写程序要处理一个不可能出现负值的时候，一般用无符号数，这样可以增大数的表达最大值</strong> </p><h5 id="3-有符号和无符号整型取值范围"><a href="#3-有符号和无符号整型取值范围" class="headerlink" title="3. 有符号和无符号整型取值范围"></a>3. 有符号和无符号整型取值范围</h5><div class="table-container"><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>short</td><td>2字节</td><td>-32768 到 32767 ($-2^{15}$  ~ 2$^{15}$-1)</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648 到  2147483647 ($-2^{31}$ ~ $2^{31}$-1)</td></tr><tr><td>long</td><td>4字节</td><td>-2147483648 到  2147483647($-2^{31}$ ~ $2^{31}$-1)</td></tr><tr><td>unsigned short</td><td>2字节</td><td>0 到 65535 (0 ~ 2$^{16}$-1)</td></tr><tr><td>unsigned int</td><td>4字节</td><td>0 到 4294967295 (0  ~ 2$^{32}$-1)</td></tr><tr><td>unsigned long</td><td>4字节</td><td>0 到 4294967295 (0  ~ 2$^{32}$-1)</td></tr></tbody></table></div><h3 id="2-3-sizeof-关键字"><a href="#2-3-sizeof-关键字" class="headerlink" title="2.3 sizeof 关键字"></a>2.3 sizeof 关键字</h3><ul><li><code>sizeof</code>不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节</li><li><code>sizeof</code>的返回值为<code>size_t</code></li><li><code>size_t</code>类型在32位操作系统下是<code>unsigned int</code>，是一个无符号的整数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b = <span class="keyword">sizeof</span>(a);<span class="comment">//sizeof得到指定值占用内存的大小，单位：字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> c = <span class="keyword">sizeof</span>(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c = %u\n&quot;</span>, c);<span class="comment">//用无符号数的方式输出c的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.3 </span><br><span class="line">b = 4</span><br><span class="line">c = 4</span><br></pre></td></tr></table></figure><h3 id="2-4-字符型：char"><a href="#2-4-字符型：char" class="headerlink" title="2.4  字符型：char"></a>2.4  字符型：char</h3><h4 id="2-4-1-字符变量的定义和输出"><a href="#2-4-1-字符变量的定义和输出" class="headerlink" title="2.4.1 字符变量的定义和输出"></a>2.4.1 字符变量的定义和输出</h4><p>字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(<code>&#39; &#39;</code>)把字符括起来</p><p>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(ch) = %u\n&quot;</span>, <span class="keyword">sizeof</span>(ch));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch[%%c] = %c\n&quot;</span>, ch); <span class="comment">//打印字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch[%%d] = %d\n&quot;</span>, ch); <span class="comment">//打印‘a’ ASCII的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> A = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);<span class="comment">//97</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A = %d\n&quot;</span>, A);<span class="comment">//65</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A = %c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> - <span class="number">32</span>); <span class="comment">//小写a转大写A</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + <span class="number">32</span>); <span class="comment">//大写A转小写a</span></span><br><span class="line"></span><br><span class="line">ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空字符：%d\n&quot;</span>, ch); <span class="comment">//空字符ASCII的值为32</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A = %c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27; &#x27;</span>); <span class="comment">//小写a转大写A</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27; &#x27;</span>); <span class="comment">//大写A转小写a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ao@Taoc:~/Desktop/C/<span class="number">2</span>$ ./<span class="number">2.4</span><span class="number">.1</span> </span><br><span class="line"><span class="keyword">sizeof</span>(ch) = <span class="number">1</span></span><br><span class="line">ch[%c] = a</span><br><span class="line">ch[%d] = <span class="number">97</span></span><br><span class="line">a = <span class="number">97</span></span><br><span class="line">A = <span class="number">65</span></span><br><span class="line">A = A</span><br><span class="line">a = a</span><br><span class="line">空字符：<span class="number">32</span></span><br><span class="line">A = A</span><br><span class="line">a = a</span><br></pre></td></tr></table></figure><h4 id="2-4-2-字符变量的输入"><a href="#2-4-2-字符变量的输入" class="headerlink" title="2.4.2 字符变量的输入"></a>2.4.2 字符变量的输入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入ch的值：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要加“\n”</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch); <span class="comment">//打印ch的字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.4.2 </span><br><span class="line">请输入ch的值：a</span><br><span class="line">ch = a</span><br></pre></td></tr></table></figure><h4 id="2-4-3-ASCII-对照表"><a href="#2-4-3-ASCII-对照表" class="headerlink" title="2.4.3 ASCII 对照表"></a>2.4.3 ASCII 对照表</h4><div class="table-container"><table><thead><tr><th><font color="blue"><strong>ASCII值</strong></font></th><th><font color="blue"> <strong>控制字符</strong>  </font></th><th><font color="blue"><strong>ASCII值</strong></font></th><th><font color="blue"> <strong>字符</strong>  </font></th><th><font color="blue"><strong>ASCII值</strong></font></th><th><font color="blue"> <strong>字符</strong>  </font></th><th><font color="blue"><strong>ASCII值</strong></font></th><th><font color="blue"> <strong>字符</strong>  </font></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>\</td><td></td></tr><tr><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table></div><p>ASCII 码大致由以下两部分组成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备</li><li>ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。数字 127 代表 Del 命令</li></ul><h4 id="2-4-4-转义字符"><a href="#2-4-4-转义字符" class="headerlink" title="2.4.4 转义字符"></a>2.4.4 转义字符</h4><div class="table-container"><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII**</strong>码值（十进制）**</th></tr></thead><tbody><tr><td><font color="red">\a</font></td><td>警报</td><td>007</td></tr><tr><td><font color="red">\b  </font></td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td><font color="red">\f  </font></td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td><font color="red">\n  </font></td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td><font color="red"> \r  </font></td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td><font color="red">\t  </font></td><td>水平制表(HT)  （跳到下一个TAB位置）</td><td>009</td></tr><tr><td><font color="red"> \v  </font></td><td>垂直制表(VT)</td><td>011</td></tr><tr><td><code>\\</code></td><td>代表一个反斜线字符”\”</td><td>092</td></tr><tr><td><code>\&#39;</code></td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td><code>\&quot;</code></td><td>代表一个双引号字符</td><td>034</td></tr><tr><td><code>\?</code></td><td>代表一个问号</td><td>063</td></tr><tr><td><code>\0</code></td><td>数字0</td><td>000</td></tr><tr><td><code>\ddd</code></td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td><code>\xhh</code></td><td>16进制转义字符，h范围0~9，a~f，A~F</td><td>3位16进制</td></tr></tbody></table></div><blockquote><p>注意：红色字体标注的为不可打印字符</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\refg\n&quot;</span>); <span class="comment">//\r切换到句首， \n为换行键</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\befg\n&quot;</span>);<span class="comment">//\b为退格键， \n为换行键</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\123&#x27;</span>);<span class="comment">// &#x27;\123&#x27;为8进制转义字符，0123对应10进制数为83</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\x23&#x27;</span>);<span class="comment">// &#x27;\x23&#x27;为16进制转义字符，0x23对应10进制数为35</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.4.4 </span><br><span class="line">efg</span><br><span class="line">abefg</span><br><span class="line">83</span><br><span class="line">35</span><br></pre></td></tr></table></figure><h3 id="2-5-实型-浮点型-：float、double"><a href="#2-5-实型-浮点型-：float、double" class="headerlink" title="2.5 实型(浮点型)：float、double"></a>2.5 实型(浮点型)：float、double</h3><p>实型变量也可以称为浮点型变量，浮点型变量是用来存储小数数值的。在C语言中， 浮点型变量分为两种： 单精度浮点数(<code>float</code>)、 双精度浮点数(<code>double</code>)， 但是<code>double</code>型变量所表示的浮点数比 float 型变量更精确。</p><p>由于浮点型变量是由有限的存储单元组成的，因此只能提供有限的有效数字。在有效位以外的数字将被舍去，这样可能会产生一些误差。</p><p>不以f结尾的常量是<code>double</code>类型，以f结尾的常量(如3.14f)是<code>float</code>类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//传统方式赋值</span></span><br><span class="line"><span class="type">float</span> a = <span class="number">3.14f</span>; <span class="comment">//或3.14F</span></span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %f\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %lf\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学法赋值</span></span><br><span class="line">a = <span class="number">3.2e3</span>f; <span class="comment">//3.2*1000 = 3200，e可以写E</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a1 = %f\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">100e-3</span>f; <span class="comment">//100*0.001 = 0.1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a2 = %f\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">a = <span class="number">3.1415926f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a3 = %f\n&quot;</span>, a); <span class="comment">//结果为3.141593</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.5 </span><br><span class="line">a = 3.140000</span><br><span class="line">b = 3.140000</span><br><span class="line">a1 = 3200.000000</span><br><span class="line">a2 = 0.100000</span><br><span class="line">a3 = 3.141593</span><br></pre></td></tr></table></figure><h3 id="2-6-进制"><a href="#2-6-进制" class="headerlink" title="2.6 进制"></a>2.6 进制</h3><p>进制也就是进位制，是人们规定的一种进位方法。 对于任何一种进制—X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位</p><div class="table-container"><table><thead><tr><th><strong>十进制</strong></th><th><strong>二进制</strong></th><th><strong>八进制</strong></th><th><strong>十六进制</strong></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>10</td><td>2</td><td>2</td></tr><tr><td>3</td><td>11</td><td>3</td><td>3</td></tr><tr><td>4</td><td>100</td><td>4</td><td>4</td></tr><tr><td>5</td><td>101</td><td>5</td><td>5</td></tr><tr><td>6</td><td>110</td><td>6</td><td>6</td></tr><tr><td>7</td><td>111</td><td>7</td><td>7</td></tr><tr><td>8</td><td>1000</td><td>10</td><td>8</td></tr><tr><td>9</td><td>1001</td><td>11</td><td>9</td></tr><tr><td>10</td><td>1010</td><td>12</td><td>A</td></tr><tr><td>11</td><td>1011</td><td>13</td><td>B</td></tr><tr><td>12</td><td>1100</td><td>14</td><td>C</td></tr><tr><td>13</td><td>1101</td><td>15</td><td>D</td></tr><tr><td>14</td><td>1110</td><td>16</td><td>E</td></tr><tr><td>15</td><td>1111</td><td>17</td><td>F</td></tr><tr><td>16</td><td>10000</td><td>20</td><td>10</td></tr></tbody></table></div><h4 id="2-6-1-二进制"><a href="#2-6-1-二进制" class="headerlink" title="2.6.1 二进制"></a>2.6.1 二进制</h4><p>二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”</p><blockquote><p>当前的计算机系统使用的基本上是二进制系统，<font color="red">数据在计算机中主要是以补码的形式存储的</font></p></blockquote><div class="table-container"><table><thead><tr><th><strong>术语</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>bit(比特)</td><td>一个二进制代表一位，一个位只能表示0或1两种状态。数据传输是习惯以“位”（bit）为单位。</td></tr><tr><td>Byte(字节)</td><td>一个字节为8个二进制，称为8位，<font color="red">计算机中存储的最小单位是字节</font>。数据存储是习惯以“字节”（Byte）为单位。</td></tr><tr><td>WORD(双字节)</td><td>2个字节，16位</td></tr><tr><td>DWORD</td><td>两个WORD，4个字节，32位</td></tr><tr><td>1b</td><td>1bit，1位</td></tr><tr><td>1B</td><td>1Byte,1字节，8位</td></tr><tr><td>1k，1K</td><td>1024</td></tr><tr><td>1M(1兆)</td><td>1024k, 1024*1024</td></tr><tr><td>1G</td><td>1024M</td></tr><tr><td>1T</td><td>1024G</td></tr><tr><td>1Kb(千位)</td><td>1024bit,1024位</td></tr><tr><td>1KB(千字节)</td><td>1024Byte，1024字节</td></tr><tr><td>1Mb(兆位)</td><td>1024Kb = 1024 * 1024bit</td></tr><tr><td>1MB(兆字节)</td><td>1024KB = 1024 * 1024Byte</td></tr></tbody></table></div><p>十进制转化二进制的方法：用十进制数除以2，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291933901.png" alt="img"></p><p>十进制的小数转换成二进制：小数部分和2相乘，取整数，不足1取0，<font color="red">每次相乘都是小数部分</font>，顺序看取整后的数就是转化后的结果</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291934892.jpg" alt="无标题"></p><h4 id="2-6-2-八进制"><a href="#2-6-2-八进制" class="headerlink" title="2.6.2 八进制"></a>2.6.2 八进制</h4><p>八进制，<code>Octal</code>，缩写OCT或O，一种以8为基数的计数法，采用0，1，2，3，4，5，6，7八个数字，逢八进1。一些编程语言中常常以数字0开始表明该数字是八进制</p><p>八进制的数和二进制数可以按位对应（<font color="red">八进制一位对应二进制三位</font>），因此常应用在计算机语言中</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291934762.jpg" alt="06-01_172043"></p><p>十进制转化八进制的方法：</p><p>用十进制数除以8，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291934124.jpg" alt="10转_副本1"></p><h4 id="2-6-3-十六进制"><a href="#2-6-3-十六进制" class="headerlink" title="2.6.3 十六进制"></a>2.6.3 十六进制</h4><p>十六进制（英文名称：Hexadecimal），同我们日常生活中的表示法不一样，它由0-9，A-F组成，<font color="red">字母不区分大小写</font>。与10进制的对应关系是：0-9对应0-9，A-F对应10-15</p><p>十六进制的数和二进制数可以按位对应（<font color="red">十六进制一位对应二进制四位</font>），因此常应用在计算机语言中</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291934296.jpg" alt="2016-06-01_180102"></p><p>十进制转化十六进制的方法：</p><p>用十进制数除以16，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291934457.jpg" alt="10转"></p><h4 id="2-6-4-C语言如何表示相应进制数"><a href="#2-6-4-C语言如何表示相应进制数" class="headerlink" title="2.6.4 C语言如何表示相应进制数"></a>2.6.4 C语言如何表示相应进制数</h4><div class="table-container"><table><thead><tr><th>十进制</th><th>以正常数字1-9开头，如123</th></tr></thead><tbody><tr><td>八进制</td><td>以数字0开头，如0123</td></tr><tr><td>十六进制</td><td>以0x开头，如0x123</td></tr><tr><td>二进制</td><td>C语言不能直接书写二进制数</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">123</span>;<span class="comment">//十进制方式赋值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0123</span>;<span class="comment">//八进制方式赋值， 以数字0开头</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xABC</span>;<span class="comment">//十六进制方式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;十进制：%d\n&quot;</span>,a );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;八进制：%o\n&quot;</span>, b);<span class="comment">//%o,为字母o,不是数字</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;十六进制：%x\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.6.4 </span><br><span class="line">十进制：123</span><br><span class="line">八进制：123</span><br><span class="line">十六进制：abc</span><br></pre></td></tr></table></figure><h3 id="2-7-计算机内存数值存储方式"><a href="#2-7-计算机内存数值存储方式" class="headerlink" title="2.7 计算机内存数值存储方式"></a>2.7 计算机内存数值存储方式</h3><blockquote><p> <a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解</a></p></blockquote><h4 id="2-7-1-原码"><a href="#2-7-1-原码" class="headerlink" title="2.7.1 原码"></a>2.7.1 原码</h4><p>一个数的原码(原始的二进制码)有如下特点：</p><ul><li>最高位做为符号位，0表示正,为1表示负</li><li>其它数值部分就是数值本身绝对值的二进制数</li><li>负数的原码是在其绝对值的基础上，最高位变为1</li></ul><p>下面数值以1字节的大小描述：</p><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>原码</strong></th></tr></thead><tbody><tr><td>+15</td><td>0000 1111</td></tr><tr><td>-15</td><td>1000 1111</td></tr><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>1000 0000</td></tr></tbody></table></div><p>原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁减谁，才能确定结果是正还是负，所以原码不便于加减运算</p><h4 id="2-7-2-反码"><a href="#2-7-2-反码" class="headerlink" title="2.7.2 反码"></a>2.7.2 反码</h4><ul><li>对于正数，反码与原码相同</li><li><font color="red">对于负数，符号位不变，其它部分取反(1变0,0变1)</font></li></ul><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>反码</strong></th></tr></thead><tbody><tr><td>+15</td><td>0000 1111</td></tr><tr><td>-15</td><td>1111 0000</td></tr><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>1111 1111</td></tr></tbody></table></div><blockquote><p> 反码运算也不方便，通常用来作为求补码的中间过渡</p></blockquote><h4 id="2-7-3-补码"><a href="#2-7-3-补码" class="headerlink" title="2.7.3 补码"></a>2.7.3 补码</h4><font color="red">**在计算机系统中，数值一律用补码来存储**</font><p>补码特点：</p><ul><li>对于正数，原码、反码、补码相同</li><li><font color="red">对于负数，其补码为它的反码加1</font></li><li>补码符号位不动，其他位求反，最后整个数加1，得到原码</li></ul><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>补码</strong></th></tr></thead><tbody><tr><td>+15</td><td>0000 1111</td></tr><tr><td>-15</td><td>1111 0001</td></tr><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>0000 0000</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  a = <span class="number">-15</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, a);</span><br><span class="line"><span class="comment">//结果为 fffffff1</span></span><br><span class="line"><span class="comment">//fffffff1对应的二进制：1111 1111 1111 1111 1111 1111 1111 0001</span></span><br><span class="line"><span class="comment">//符号位不变，其它取反：1000 0000 0000 0000 0000 0000 0000 1110</span></span><br><span class="line"><span class="comment">//上面加1：1000 0000 0000 0000 0000 0000 0000 1111  最高位1代表负数，就是-15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-4-补码的意义"><a href="#2-7-4-补码的意义" class="headerlink" title="2.7.4 补码的意义"></a>2.7.4 补码的意义</h4><p>示例1：用8位二进制数分别表示+0和-0</p><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>原码</strong></th></tr></thead><tbody><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>1000 0000</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>反码</strong></th></tr></thead><tbody><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>1111 1111</td></tr></tbody></table></div><p>不管以原码方式存储，还是以反码方式存储，0也有两种表示形式。为什么同样一个0有两种不同的表示方法呢？</p><p>但是如果以补码方式存储，补码统一了零的编码：</p><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>补码</strong></th></tr></thead><tbody><tr><td>+0</td><td>0000 0000</td></tr><tr><td>-0</td><td>10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000</td></tr></tbody></table></div><p>示例2：计算9-6的结果</p><p>以原码方式相加：</p><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>原码</strong></th></tr></thead><tbody><tr><td>9</td><td>0000 1001</td></tr><tr><td>-6</td><td>1000 0110</td></tr></tbody></table></div><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291935392.jpg" alt="2016-06-01_225835"></p><p>结果为-15，不正确。</p><p>以补码方式相加：</p><div class="table-container"><table><thead><tr><th><strong>十进制数</strong></th><th><strong>补码</strong></th></tr></thead><tbody><tr><td>9</td><td>0000 1001</td></tr><tr><td>-6</td><td>1111 1010</td></tr></tbody></table></div><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291935116.jpg" alt="06-01_230938"></p><p>最高位的1溢出,剩余8位二进制表示的是3，正确</p><p><strong>在计算机系统中，数值一律用补码来存储</strong>主要原因是：</p><ul><li>统一了零的编码</li><li>将符号位和其它位统一处理</li><li>将减法运算转变为加法运算</li><li>两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃</li></ul><h4 id="2-7-5-数值溢出"><a href="#2-7-5-数值溢出" class="headerlink" title="2.7.5 数值溢出"></a>2.7.5 数值溢出</h4><p>当超过一个数据类型能够存放最大的范围时，数值会溢出</p><p>有符号位最高位溢出的区别：符号位溢出会导致数的正负发生改变，但最高位的溢出会导致最高位丢失</p><div class="table-container"><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>取值范围</strong></th></tr></thead><tbody><tr><td>char</td><td>1字节</td><td>-128到 127(-2$^{7}$  ~ 2$^{7}$-1)</td></tr><tr><td>unsigned char</td><td>1字节</td><td>0 到 255(0 ~ 2$^{8}$-1)</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号位溢出会导致数的正负发生改变</span></span><br><span class="line">ch = <span class="number">0x7f</span> + <span class="number">2</span>; <span class="comment">//127+2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ch);</span><br><span class="line"><span class="comment">//0111 1111</span></span><br><span class="line"><span class="comment">//+2后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最高位的溢出会导致最高位丢失</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ch2;</span><br><span class="line">ch2 = <span class="number">0xff</span>+<span class="number">1</span>; <span class="comment">//255+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, ch2);</span><br><span class="line"><span class="comment">//  1111 1111</span></span><br><span class="line"><span class="comment">//+1后 10000 0000， char只有8位最高位的溢出，结果为0000 0000，十进制为0</span></span><br><span class="line"></span><br><span class="line">ch2 = <span class="number">0xff</span> + <span class="number">2</span>; <span class="comment">//255+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, ch2);</span><br><span class="line"><span class="comment">//  1111 1111</span></span><br><span class="line"><span class="comment">//+1后 10000 0001， char只有8位最高位的溢出，结果为0000 0001，十进制为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">2</span>$ gcc <span class="number">2.7</span><span class="number">.5</span>.c -o <span class="number">2.7</span><span class="number">.5</span></span><br><span class="line"><span class="number">2.7</span><span class="number">.5</span>.c: In function ‘main’:</span><br><span class="line"><span class="number">2.7</span><span class="number">.5</span>.c:<span class="number">15</span>:<span class="number">8</span>: warning: <span class="type">unsigned</span> conversion from ‘<span class="type">int</span>’ to ‘<span class="type">unsigned</span> <span class="type">char</span>’ changes value from ‘<span class="number">256</span>’ to ‘<span class="number">0</span>’ [-Woverflow]</span><br><span class="line">  ch2 = <span class="number">0xff</span>+<span class="number">1</span>; <span class="comment">//255+1</span></span><br><span class="line">        ^~~~</span><br><span class="line"><span class="number">2.7</span><span class="number">.5</span>.c:<span class="number">20</span>:<span class="number">8</span>: warning: <span class="type">unsigned</span> conversion from ‘<span class="type">int</span>’ to ‘<span class="type">unsigned</span> <span class="type">char</span>’ changes value from ‘<span class="number">257</span>’ to ‘<span class="number">1</span>’ [-Woverflow]</span><br><span class="line">  ch2 = <span class="number">0xff</span> + <span class="number">2</span>; <span class="comment">//255+1</span></span><br><span class="line">        ^~~~</span><br><span class="line">tao@Taoc:~/Desktop/C/<span class="number">2</span>$ ./<span class="number">2.7</span><span class="number">.5</span> </span><br><span class="line"><span class="number">-127</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-8-类型限定符"><a href="#2-8-类型限定符" class="headerlink" title="2.8 类型限定符"></a>2.8 类型限定符</h3><div class="table-container"><table><thead><tr><th><strong>限定符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>extern</td><td>声明一个变量，extern声明的变量没有建立存储空间。  extern int a;//变量在定义的时候创建存储空间</td></tr><tr><td>const</td><td>定义一个常量，常量的值不能修改。  const int a = 10;</td></tr><tr><td>Volatile</td><td>防止编译器优化代码</td></tr><tr><td>register</td><td>定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。</td></tr></tbody></table></div><h3 id="2-9-字符串格式化输出和输入"><a href="#2-9-字符串格式化输出和输入" class="headerlink" title="2.9 字符串格式化输出和输入"></a>2.9 字符串格式化输出和输入</h3><h4 id="2-9-1-字符串常量"><a href="#2-9-1-字符串常量" class="headerlink" title="2.9.1 字符串常量"></a>2.9.1 字符串常量</h4><ul><li>字符串是内存中一段连续的char空间，以’<code>\0</code>‘(数字0)结尾</li><li>字符串常量是由双引号括起来的字符序列，如“china”、“C program”，“$12.5”等都是合法的字符串常量</li></ul><p>字符串常量与字符常量的不同：</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291935043.jpg" alt="06-02_122416"></p><p>每个字符串的结尾，编译器会自动的添加一个结束标志位’<code>\0</code>‘，即 “a” 包含两个字符’<code>a</code>‘和’<code>\0</code>’</p><h4 id="2-9-2-printf函数和putchar函数"><a href="#2-9-2-printf函数和putchar函数" class="headerlink" title="2.9.2  printf函数和putchar函数"></a>2.9.2  printf函数和putchar函数</h4><p><code>printf</code>是输出一个字符串，<code>putchar</code>输出一个char</p><p>printf格式字符：</p><div class="table-container"><table><thead><tr><th><strong>打印格式</strong></th><th><strong>对应数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%d</td><td>int</td><td>接受整数值并将它表示为有符号的十进制整数</td></tr><tr><td>%hd</td><td>short int</td><td>短整数</td></tr><tr><td>%hu</td><td>unsigned short</td><td>无符号短整数</td></tr><tr><td>%o</td><td>unsigned int</td><td>无符号8进制整数</td></tr><tr><td>%u</td><td>unsigned int</td><td>无符号10进制整数</td></tr><tr><td>%x,%X</td><td>unsigned int</td><td>无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF</td></tr><tr><td>%f</td><td>float</td><td>单精度浮点数</td></tr><tr><td>%lf</td><td>double</td><td>双精度浮点数</td></tr><tr><td>%e,%E</td><td>double</td><td>科学计数法表示的数，此处”e”的大小写代表在输出时用的”e”的大小写</td></tr><tr><td>%c</td><td>char</td><td>字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td></tr><tr><td>%s</td><td>char *</td><td>字符串。输出字符串中的字符直至字符串中的空字符（字符串以’\0‘结尾，这个’\0’即空字符）</td></tr><tr><td>%p</td><td>void *</td><td>以16进制形式输出指针</td></tr><tr><td>%%</td><td>%</td><td>输出一个百分号</td></tr></tbody></table></div><p>printf附加格式：</p><div class="table-container"><table><thead><tr><th><strong>字符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>l(字母l)</td><td>附加在d,u,x,o前面，表示长整数</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>m(代表一个整数)</td><td>数据最小宽度</td></tr><tr><td>0(数字0)</td><td>将输出的前面补上0直到占满指定列宽为止不可以搭配使用-</td></tr><tr><td>m.n(代表一个整数)</td><td>m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度，用于说明输出的实型数的小数位数。对数值型的来说，未指定n时，隐含的精度为n=6位。</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);<span class="comment">//格式化输出一个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;a);<span class="comment">//输出变量a在内存中的地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%%d\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(c);<span class="comment">//putchar只有一个参数，就是要输出的char</span></span><br><span class="line"><span class="type">long</span> a2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld, %lx, %lo\n&quot;</span>, a2, a2, a2);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a3 = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld, %llx, %llo\n&quot;</span>, a3, a3, a3);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> abc = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc = &#x27;%6d&#x27;\n&quot;</span>, abc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc = &#x27;%-6d&#x27;\n&quot;</span>, abc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc = &#x27;%06d&#x27;\n&quot;</span>, abc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc = &#x27;%-06d&#x27;\n&quot;</span>, abc);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d = <span class="number">12.3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d = \&#x27; %-10.3lf \&#x27;\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.9.2 </span><br><span class="line">a = 100</span><br><span class="line">0x7ffd3443b718</span><br><span class="line">%d</span><br><span class="line">a100, 64, 144</span><br><span class="line">1000, 3e8, 1750</span><br><span class="line">abc = <span class="string">&#x27;    10&#x27;</span></span><br><span class="line">abc = <span class="string">&#x27;10    &#x27;</span></span><br><span class="line">abc = <span class="string">&#x27;000010&#x27;</span></span><br><span class="line">abc = <span class="string">&#x27;10    &#x27;</span></span><br><span class="line">d = <span class="string">&#x27; 12.300     &#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-9-3-scanf函数与getchar函数"><a href="#2-9-3-scanf函数与getchar函数" class="headerlink" title="2.9.3 scanf函数与getchar函数"></a>2.9.3 scanf函数与getchar函数</h4><ul><li>getchar是从标准输入设备读取一个char</li><li>scanf通过%转义的方式可以得到用户通过标准输入设备输入的数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1;</span><br><span class="line"><span class="type">char</span> ch2;</span><br><span class="line"><span class="type">char</span> ch3;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入ch1的字符：&quot;</span>);</span><br><span class="line">ch1 = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c\n&quot;</span>, ch1);</span><br><span class="line"></span><br><span class="line">getchar(); <span class="comment">//测试此处getchar()的作用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入ch2的字符：&quot;</span>);</span><br><span class="line">ch2 = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;ch2 = %ctest\&#x27;\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">getchar(); <span class="comment">//测试此处getchar()的作用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入ch3的字符：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch3);<span class="comment">//这里第二个参数一定是变量的地址，而不是变量名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch3 = %c\n&quot;</span>, ch3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入a的值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入b的值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/2$ gcc 2.9.3.c -o 2.9.3</span><br><span class="line">tao@Taoc:~/Desktop/C/2$ ./2.9.3 </span><br><span class="line">请输入ch1的字符：a</span><br><span class="line">ch1 = a</span><br><span class="line">请输入ch2的字符：b</span><br><span class="line"><span class="string">&#x27;ch2 = btest&#x27;</span></span><br><span class="line">请输入ch3的字符：c</span><br><span class="line">ch3 = c</span><br><span class="line">请输入a的值：d</span><br><span class="line">a = 1513391056</span><br><span class="line">请输入b的值：b = 32765</span><br></pre></td></tr></table></figure><h2 id="3-运算符与表达式"><a href="#3-运算符与表达式" class="headerlink" title="3. 运算符与表达式"></a>3. 运算符与表达式</h2><h3 id="3-1-常用运算符分类"><a href="#3-1-常用运算符分类" class="headerlink" title="3.1 常用运算符分类"></a>3.1 常用运算符分类</h3><div class="table-container"><table><thead><tr><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr><tr><td>位运算符</td><td>用于处理数据的位运算</td></tr><tr><td>sizeof运算符</td><td>用于求字节数长度</td></tr></tbody></table></div><h3 id="3-2-算术运算符"><a href="#3-2-算术运算符" class="headerlink" title="3.2 算术运算符"></a>3.2 算术运算符</h3><div class="table-container"><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前自增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr><td>++</td><td>后自增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr><td>—</td><td>前自减</td><td>a=2; b=—a;</td><td>a=1; b=1;</td></tr><tr><td>—</td><td>后自减</td><td>a=2; b=a—;</td><td>a=1; b=2;</td></tr></tbody></table></div><h3 id="3-3-赋值运算符"><a href="#3-3-赋值运算符" class="headerlink" title="3.3 赋值运算符"></a>3.3 赋值运算符</h3><div class="table-container"><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table></div><h3 id="3-4-比较运算符"><a href="#3-4-比较运算符" class="headerlink" title="3.4 比较运算符"></a>3.4 比较运算符</h3><blockquote><p>C 语言的比较运算中， “<code>真</code>”用数字“<code>1</code>”来表示， “<code>假</code>”用数字“<code>0</code>”来表示</p></blockquote><div class="table-container"><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table></div><h3 id="3-5-逻辑运算符"><a href="#3-5-逻辑运算符" class="headerlink" title="3.5 逻辑运算符"></a>3.5 逻辑运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>运算符</strong></th><th style="text-align:center"><strong>术语</strong></th><th style="text-align:center"><strong>示例</strong></th><th style="text-align:center"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:center">!</td><td style="text-align:center">非</td><td style="text-align:center">!a</td><td style="text-align:center">如果a为假，则!a为真； 如果a为真，则!a为假。</td></tr><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">与</td><td style="text-align:center">a &amp;&amp; b</td><td style="text-align:center">如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">\</td><td style="text-align:center"></td><td style="text-align:center">或</td><td>a \</td><td>\</td><td>b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table></div><h3 id="3-6-运算符优先级"><a href="#3-6-运算符优先级" class="headerlink" title="3.6 运算符优先级"></a>3.6 运算符优先级</h3><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291936267.png" alt="image-20200920092724191"></p><h3 id="3-7-类型转换"><a href="#3-7-类型转换" class="headerlink" title="3.7 类型转换"></a>3.7 类型转换</h3><p>数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型的转换问题</p><p>转换的方法有两种：</p><ul><li>自动转换(隐式转换)：遵循一定的规则,由编译系统自动完成。</li><li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型。</li></ul><p>类型转换的原则：<font color="red">占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低</font></p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291936062.jpg" alt="06-02_202741"></p><h4 id="3-7-1-隐式转换"><a href="#3-7-1-隐式转换" class="headerlink" title="3.7.1 隐式转换"></a>3.7.1 隐式转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1=%d\n&quot;</span>, num / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2=%lf\n&quot;</span>, num / <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">3</span>$ ./<span class="number">3.7</span><span class="number">.1</span> </span><br><span class="line">S1 = <span class="number">2</span></span><br><span class="line">S2 = <span class="number">2.500000</span></span><br></pre></td></tr></table></figure><h4 id="3-7-2-强制转换"><a href="#3-7-2-强制转换" class="headerlink" title="3.7.2 强制转换"></a>3.7.2 强制转换</h4><p>强制类型转换指的是使用强制类型转换运算符，将一个变量或表达式转化成所需的类型，其基本语法格式如下所示：</p><p><code>(类型说明符) (表达式)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">float</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">x = <span class="number">3.6f</span>;</span><br><span class="line"></span><br><span class="line">i = x;</span><br><span class="line">i = (<span class="type">int</span>)x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%f, i=%d\n&quot;</span>, x, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/3$ ./3.7.2 </span><br><span class="line">x=3.600000, i=3</span><br></pre></td></tr></table></figure><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4. 程序流程结构"></a>4. 程序流程结构</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>C语言支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构。</p><ul><li><p>顺序结构：程序按顺序执行，不发生跳转。</p></li><li><p>选择结构：依据是否满足条件，有选择的执行相应功能。</p></li><li><p>循环结构：依据条件是否满足，循环多次执行某段代码。</p></li></ul><h3 id="4-2-选择结构"><a href="#4-2-选择结构" class="headerlink" title="4.2 选择结构"></a>4.2 选择结构</h3><h4 id="4-2-1-if语句"><a href="#4-2-1-if语句" class="headerlink" title="4.2.1 if语句"></a>4.2.1 if语句</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291936954.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="4-2-2-if…else语句"><a href="#4-2-2-if…else语句" class="headerlink" title="4.2.2 if…else语句"></a>4.2.2 if…else语句</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291936779.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-3-if…else-if…else语句"><a href="#4-2-3-if…else-if…else语句" class="headerlink" title="4.2.3 if…else if…else语句"></a>4.2.3 if…else if…else语句</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937241.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;个位\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;十位\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;百位\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;很大\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-三目运算符"><a href="#4-2-4-三目运算符" class="headerlink" title="4.2.4 三目运算符"></a>4.2.4 三目运算符</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937298.gif" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">c = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c1 = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = ( a &gt; b ? a : b );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c2 = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-5-switch语句"><a href="#4-2-5-switch语句" class="headerlink" title="4.2.5 switch语句"></a>4.2.5 switch语句</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">c = getchar();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (c) <span class="comment">//参数只能是整型变量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//switch遇到break就中断了</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;not OK\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//如果上面的条件都不满足，那么执行default</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;are u ok?\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/4$ ./4.2.5 </span><br><span class="line">t</span><br><span class="line">are u ok?</span><br></pre></td></tr></table></figure><h3 id="4-3-循环语句"><a href="#4-3-循环语句" class="headerlink" title="4.3 循环语句"></a>4.3 循环语句</h3><h4 id="4-3-1-while语句"><a href="#4-3-1-while语句" class="headerlink" title="4.3.1 while语句"></a>4.3.1 while语句</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937566.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span> (a &gt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-do…while语句"><a href="#4-3-2-do…while语句" class="headerlink" title="4.3.2 do…while语句"></a>4.3.2 do…while语句</h4><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937367.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125; <span class="keyword">while</span> (a &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-3-for-语句"><a href="#4-3-3-for-语句" class="headerlink" title="4.3.3 for 语句"></a>4.3.3 for 语句</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;sum = %d\n&quot;, sum);</span><br><span class="line"></span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-嵌套循环"><a href="#4-3-4-嵌套循环" class="headerlink" title="4.3.4 嵌套循环"></a>4.3.4 嵌套循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4-跳转语句break、continue、goto"><a href="#4-4-跳转语句break、continue、goto" class="headerlink" title="4.4 跳转语句break、continue、goto"></a>4.4 跳转语句break、continue、goto</h3><h4 id="4-3-1-break-语句"><a href="#4-3-1-break-语句" class="headerlink" title="4.3.1 break 语句"></a>4.3.1 break 语句</h4><p>在switch条件语句和循环语句中都可以使用<code>break</code>语句：</p><ul><li>当它出现在<code>switch</code>条件语句中时，作用是终止某个<code>case</code>并跳出<code>switch</code>结构。</li><li>当它出现在循环语句中，作用是跳出当前内循环语句，执行后面的代码。</li><li>当它出现在嵌套循环语句中，跳出最近的内循环语句，执行后面的代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"><span class="keyword">while</span> (1)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == 10)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>; //跳出<span class="keyword">while</span>循环</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int flag = 0;</span><br><span class="line">int m = 0;</span><br><span class="line">int n = 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (m = 0; m &lt; 10; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (n = 0; n &lt; 10; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == 5)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line"><span class="built_in">break</span>; //跳出<span class="keyword">for</span> (n = 0; n &lt; 10; n++)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == 1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">break</span>; //跳出<span class="keyword">for</span> (m = 0; m &lt; 10; m++)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/4$ ./4.3.1</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">i = 4</span><br><span class="line">i = 5</span><br><span class="line">i = 6</span><br><span class="line">i = 7</span><br><span class="line">i = 8</span><br><span class="line">i = 9</span><br><span class="line">i = 10</span><br></pre></td></tr></table></figure><h4 id="4-4-2-continue语句"><a href="#4-4-2-continue语句" class="headerlink" title="4.4.2 continue语句"></a>4.4.2 continue语句</h4><p>在循环语句中，如果希望立即终止本次循环，并执行下一次循环，此时就需要使用<code>continue</code>语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;           <span class="comment">//定义变量sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)   <span class="comment">//如果i是一个偶数，执行if语句中的代码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;      <span class="comment">//结束本次循环</span></span><br><span class="line">&#125;</span><br><span class="line">sum += i;          <span class="comment">//实现sum和i的累加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/4$ ./4.4.2</span><br><span class="line"><span class="built_in">sum</span> = 2500</span><br></pre></td></tr></table></figure><h4 id="4-4-3-goto语句-无条件跳转，尽量少用"><a href="#4-4-3-goto语句-无条件跳转，尽量少用" class="headerlink" title="4.4.3 goto语句(无条件跳转，尽量少用)"></a>4.4.3 goto语句(无条件跳转，尽量少用)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> End; <span class="comment">//无条件跳转到End的标识</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;aaaaaaaaa\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">End:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bbbbbbbb\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">4</span>$ ./<span class="number">4.4</span><span class="number">.3</span> </span><br><span class="line">bbbbbbbb</span><br></pre></td></tr></table></figure><h2 id="5-数组和字符串"><a href="#5-数组和字符串" class="headerlink" title="5. 数组和字符串"></a>5. 数组和字符串</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><blockquote><p>在程序设计中，为了方便处理数据把具有相同类型的若干变量按有序形式组织起来——称为数组</p></blockquote><p>数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937212.png" alt=""></p><p>数组属于构造数据类型：</p><ul><li><p>一个数组可以分解为多个数组元素：这些数组元素可以是基本数据类型或构造类型</p></li><li><p>```c<br>int a[10];<br>struct Stu boy[10]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 按数组元素类型的不同，数组可分为：数值数组、字符数组、指针数组、结构数组等类别</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int a[10];</span><br><span class="line">  char s[10];</span><br><span class="line">  char *p[10];</span><br></pre></td></tr></table></figure><p>通常情况下，数组元素下标的个数也称为维数，根据维数的不同，可将数组分为一维数组、二维数组、三维数组、四维数组等。通常情况下，<font color="red">我们将二维及以上的数组称为多维数组</font></p></li></ul><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组的定义和使用"><a href="#5-2-1-一维数组的定义和使用" class="headerlink" title="5.2.1  一维数组的定义和使用"></a>5.2.1  一维数组的定义和使用</h4><ul><li><p>数组名字符合标识符的书写规定(数字、英文字母、下划线)</p></li><li><font color="red">数组名不能与其它变量名相同，同一作用域内是唯一的</font></li><li><p>方括号[]中常量表达式表示数组元素的个数</p></li><li><p>```c<br>int a[3]表示数组a有3个元素<br>其下标从0开始计算，因此3个元素分别a[0],a[1],a[2]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &lt;font color=&quot;red&quot;&gt;定义数组时[]内最好是常量，使用数组时[]内即可是常量，也可以是变量&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[10];//定义了一个数组，名字叫a，有10个成员，每个成员都是int类型</span><br><span class="line">//a[0]…… a[9]，没有a[10]</span><br><span class="line">//没有a这个变量，a是数组的名字，但不是变量名，它是常量</span><br><span class="line">a[0] = 0;</span><br><span class="line">//……</span><br><span class="line">a[9] = 9;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = i; //给数组赋值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历数组，并输出每个成员的值</span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.2.1 </span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><h4 id="5-2-2-一维数组的初始化"><a href="#5-2-2-一维数组的初始化" class="headerlink" title="5.2.2 一维数组的初始化"></a>5.2.2 一维数组的初始化</h4><p>在定义数组的同时进行赋值，称为初始化。全局数组若不初始化，编译器将其初始化为零。<font color="red">局部数组若不初始化，内容为随机值。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;<span class="comment">//定义一个数组，同时初始化所有成员变量</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//初始化前三个成员，后面所有元素都设置为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//所有的成员都设置为0</span></span><br><span class="line"><span class="comment">//[]中不定义元素个数，定义时必须初始化</span></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;<span class="comment">//定义了一个数组，有5个成员</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-数组名"><a href="#5-2-3-数组名" class="headerlink" title="5.2.3 数组名"></a>5.2.3 数组名</h4><font color="red">数组名是一个地址的常量，代表数组中首元素的地址</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;<span class="comment">//定义一个数组，同时初始化所有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = %p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="keyword">sizeof</span>(a); <span class="comment">//数组占用内存的大小，10个int类型，10 * 4  = 40</span></span><br><span class="line"><span class="type">int</span> n0 = <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//数组第0个元素占用内存大小，第0个元素为int，4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.2.3 </span><br><span class="line">a = 0x7ffcfbfe16d0</span><br><span class="line">&amp;a[0]=0x7ffcfbfe16d0</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure><h4 id="5-2-4-强化训练"><a href="#5-2-4-强化训练" class="headerlink" title="5.2.4 强化训练"></a>5.2.4 强化训练</h4><h5 id="1-一维数组的最值"><a href="#1-一维数组的最值" class="headerlink" title="1. 一维数组的最值"></a>1. 一维数组的最值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;  <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>,- <span class="number">4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-8</span>, <span class="number">-9</span>, <span class="number">10</span> &#125;;<span class="comment">//定义一个数组，同时初始化所有成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组中最大值为：%d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.2.4-1 </span><br><span class="line">数组中最大值为:10</span><br></pre></td></tr></table></figure><h5 id="2-一维数组的逆置"><a href="#2-一维数组的逆置" class="headerlink" title="2. 一维数组的逆置"></a>2. 一维数组的逆置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123;  <span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>,- <span class="number">4</span>, <span class="number">5</span>, <span class="number">-6</span>, <span class="number">7</span>, <span class="number">-8</span>, <span class="number">-9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">tmp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = tmp;</span><br><span class="line">i++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.2.4-2 </span><br><span class="line">10, -9, -8, 7, -6, 5, -4, 3, -2, 1, </span><br></pre></td></tr></table></figure><blockquote><p>源文件的代码是有问题的，因为它<code>i++, j++</code> 放在了交换位置的前面，导致数组的第一个没有反转</p></blockquote><h5 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3. 冒泡排序"></a>3. 冒泡排序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">int a[] = &#123;  1, -2, 3,- 4, 5, -6, 7, -8, -9, 10 &#125;;</span><br><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">int n = sizeof(a)/sizeof(a[0]);</span><br><span class="line">int tmp;</span><br><span class="line"></span><br><span class="line">// 1. 流程</span><br><span class="line">// 2. 试数</span><br><span class="line"><span class="keyword">for</span>(i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = 0; j &lt; n - i - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; a[j+1])</span><br><span class="line">&#123;</span><br><span class="line">tmp = a[j];</span><br><span class="line">a[j] = a[j+1];</span><br><span class="line">a[j+1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.2.4-3 </span><br><span class="line">-9-8-6-4-2135710</span><br></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><h4 id="5-3-1-二维数组的定义和使用"><a href="#5-3-1-二维数组的定义和使用" class="headerlink" title="5.3.1 二维数组的定义和使用"></a>5.3.1 二维数组的定义和使用</h4><blockquote><p>二维数组定义的一般形式是：</p><p><code>类型说明符 数组名[常量表达式1][常量表达式2]</code></p></blockquote><p>其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。</p><p><code>int a[3][4];</code></p><ul><li>命名规则同一维数组</li><li>定义了一个三行四列的数组，数组名为a其元素类型为整型，该数组的元素个数为3×4个，即：</li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291937565.png" alt="img"></p><p>二维数组a是按行进行存放的，先存放a[0]行，再存放a[1]行、a[2]行，并且每行有四个元素，也是依次存放的</p><ul><li>二维数组在概念上是二维的：其下标在两个方向上变化，对其访问一般需要两个下标。</li><li>在内存中并不存在二维数组，二维数组实际的硬件存储器是连续编址的，<font color="red">也就是说内存中只有一维数组</font>，即放完一行之后顺次放入第二行，和一维数组存放方式是一样的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义一个二维数组，名字叫a</span></span><br><span class="line">    <span class="comment">// 由3个一维数组组成，这个一维数组是int[4]</span></span><br><span class="line">    <span class="comment">// 这3个一维数组的数组名分别为a[0],a[1],a[2]</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给数组每个元素赋值</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; j &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数组，并输出每个成员的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-2-二维数组的初始化"><a href="#5-3-2-二维数组的初始化" class="headerlink" title="5.3.2 二维数组的初始化"></a>5.3.2 二维数组的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分段赋值 int a[3][4] = &#123;&#123; 1, 2, 3, 4 &#125;,&#123; 5, 6, 7, 8, &#125;,&#123; 9, 10, 11, 12 &#125;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = </span><br><span class="line">&#123; </span><br><span class="line">&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">&#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, &#125;,</span><br><span class="line">&#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 连续赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>  &#125;;</span><br><span class="line"><span class="comment">// 可以只给部分元素赋初值，未初始化则为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的成员都设置为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[]中不定义元素个数，定义时必须初始化</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-数组名"><a href="#5-3-3-数组名" class="headerlink" title="5.3.3 数组名"></a>5.3.3 数组名</h4><font color="red">数组名是一个地址的常量，代表数组中首元素的地址</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义了一个二维数组，名字叫a</span></span><br><span class="line"><span class="comment">//二维数组是本质上还是一维数组，此一维数组有3个元素</span></span><br><span class="line"><span class="comment">//每个元素又是一个一维数组int[4]</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名为数组首元素地址，二维数组的第0个元素为一维数组</span></span><br><span class="line"><span class="comment">//第0个一维数组的数组名为a[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a[0] = %p\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测二维数组所占内存空间，有3个一维数组，每个一维数组的空间为4*4</span></span><br><span class="line"><span class="comment">//sizeof(a) = 3 * 4 * 4 = 48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//测第0个元素所占内存空间，a[0]为第0个一维数组int[4]的数组名，4*4=16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0]) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//测第0行0列元素所占内存空间，第0行0列元素为一个int类型，4字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a[0][0]) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//求二维数组行数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二维数组列数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//求二维数组行*列总数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">5</span>$ ./<span class="number">5.3</span><span class="number">.3</span> </span><br><span class="line">a = <span class="number">0x7ffe09fd1e60</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0x7ffe09fd1e60</span></span><br><span class="line"><span class="keyword">sizeof</span>(a) = <span class="number">48</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]) = <span class="number">16</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]) = <span class="number">4</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">n = <span class="number">12</span></span><br></pre></td></tr></table></figure><h4 id="5-3-4-强化训练"><a href="#5-3-4-强化训练" class="headerlink" title="5.3.4 强化训练"></a>5.3.4 强化训练</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//二维数组：  五行、三列</span></span><br><span class="line"><span class="comment">//行代表人：  老大到老五</span></span><br><span class="line"><span class="comment">//列代表科目：语、数、外</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> a[<span class="number">5</span>][<span class="number">3</span>] =  &#123; &#123; <span class="number">80</span>, <span class="number">75</span>, <span class="number">56</span> &#125;, &#123; <span class="number">59</span>, <span class="number">65</span>, <span class="number">71</span> &#125;, &#123; <span class="number">59</span>, <span class="number">63</span>, <span class="number">70</span> &#125;, &#123; <span class="number">85</span>, <span class="number">45</span>, <span class="number">90</span> &#125;, &#123; <span class="number">76</span>, <span class="number">77</span>, <span class="number">45</span> &#125; &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> i,j,person_low[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> s=<span class="number">0</span>,lesson_aver[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s + a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] &lt; <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                person_low[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lesson_aver[i] = s/<span class="number">5</span>;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">printf</span>(<span class="string">&quot;各科的平均成绩:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, lesson_aver[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;各科不及格的人数:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;%d\n&quot;</span>, person_low[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/5$ ./5.3.4 </span><br><span class="line">各科的平均成绩:</span><br><span class="line">67.00</span><br><span class="line">63.40</span><br><span class="line">64.40</span><br><span class="line">各科不及格的人数:</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="5-4-多维数组-了解"><a href="#5-4-多维数组-了解" class="headerlink" title="5.4 多维数组(了解)"></a>5.4 多维数组(了解)</h3><p>多维数组的定义与二维数组类似，其语法格式具体如下：</p><p><code>数组类型修饰符 数组名 [n1][n2]…[nn];</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>定义了一个三维数组，数组的名字是a，数组的长度为3，每个数组的元素又是一个二维数组，这个二维数组的长度是4，并且这个二维数组中的每个元素又是一个一维数组，这个一维数组的长度是5，元素类型是<code>int</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">// int a[3][4][5]; //定义了一个三维数组，有3个二维数组int[4][5]</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] = &#123; &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;, &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125; &#125;, &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125; &#125;, &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125;, &#123; <span class="number">0</span> &#125; &#125; &#125;;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加访问元素代码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">5</span>$ ./<span class="number">5.4</span> </span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line"><span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br></pre></td></tr></table></figure><h3 id="5-5-字符数组与字符串"><a href="#5-5-字符数组与字符串" class="headerlink" title="5.5 字符数组与字符串"></a>5.5 字符数组与字符串</h3><h4 id="5-5-1-字符数组与字符串区别"><a href="#5-5-1-字符数组与字符串区别" class="headerlink" title="5.5.1 字符数组与字符串区别"></a>5.5.1 字符数组与字符串区别</h4><ul><li>C语言中没有字符串这种数据类型，可以通过char的数组来替代；</li><li>字符串一定是一个char的数组，但char的数组未必是字符串；</li><li><font color="red">数字0(和字符‘`\0`’等价)结尾的char数组就是一个字符串</font>，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以<font color="red">字符串是一种特殊的char的数组</font></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c1[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span> &#125;; <span class="comment">//普通字符数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c1 = %s\n&quot;</span>, c1); <span class="comment">//乱码，因为没有’\0’结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以‘\0’(‘\0’就是数字0)结尾的字符数组是字符串</span></span><br><span class="line"><span class="type">char</span> c2[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c2 = %s\n&quot;</span>, c2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串处理以‘\0’(数字0)作为结束符，后面的&#x27;h&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;o&#x27;不会输出</span></span><br><span class="line"><span class="type">char</span> c3[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c3 = %s\n&quot;</span>, c3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291938034.png" alt="image-20200920211035690"></p><h4 id="5-5-2-字符串的初始化"><a href="#5-5-2-字符串的初始化" class="headerlink" title="5.5.2 字符串的初始化"></a>5.5.2 字符串的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言没有字符串类型，通过字符数组模拟</span></span><br><span class="line"><span class="comment">// C语言字符串，以字符&#x27;\0&#x27;, 数字0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不指定长度, 没有0结束符，有多少个元素就有多长</span></span><br><span class="line">    <span class="type">char</span> buf[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);<span class="comment">//乱码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定长度，后面没有赋值的元素，自动补0</span></span><br><span class="line"><span class="type">char</span> buf2[<span class="number">100</span>] = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1000</span>]=&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf2 = %s\n&quot;</span>, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有元素赋值为0</span></span><br><span class="line"><span class="type">char</span> buf3[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//char buf4[2] = &#123; &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27; &#125;;//数组越界</span></span><br><span class="line">    <span class="type">char</span> buf5[<span class="number">50</span>] = &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;7&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf5 = %s\n&quot;</span>, buf5);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf6[<span class="number">50</span>] = &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;7&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf6 = %s\n&quot;</span>, buf6);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf7[<span class="number">50</span>] = &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;7&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf7 = %s\n&quot;</span>, buf7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用字符串初始化，编译器自动在后面补0，常用</span></span><br><span class="line"><span class="type">char</span> buf8[] = <span class="string">&quot;agjdslgjlsdjg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#x27;\0&#x27;后面最好不要连着数字，有可能几个数字连起来刚好是一个转义字符</span></span><br><span class="line"><span class="comment">//&#x27;\ddd&#x27;八进制字义字符，&#x27;\xdd&#x27;十六进制转移字符</span></span><br><span class="line"><span class="comment">// \012相当于\n</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;\012abc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str == %s\n&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-3-字符串的输入输出"><a href="#5-5-3-字符串的输入输出" class="headerlink" title="5.5.3 字符串的输入输出"></a>5.5.3 字符串的输入输出</h4><blockquote><p>由于字符串采用了’\0’标志，字符串的输入输出将变得简单方便</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input string1 : \n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);<span class="comment">//scanf(“%s”,str)默认以空格分隔</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output:%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-gets"><a href="#1-gets" class="headerlink" title="1. gets()"></a>1. gets()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。<br>参数：<br>    <code>s</code>：字符串首地址<br>返回值：<br>    成功：读入的字符串<br>    失败：NULL</p><p><code>gets(str)</code>与<code>scanf(“%s”,str)</code>的区别：</p><ul><li><code>gets(str)</code>允许输入的字符串含有空格</li><li><code>scanf(“%s”,str)</code>不允许含有空格</li></ul><blockquote><p>注意：由于<code>scanf()</code>和<code>gets()</code>无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入str: &quot;</span>);</span><br><span class="line">gets(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure><h5 id="2-fgets"><a href="#2-fgets" class="headerlink" title="2. fgets()"></a>2. fgets()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p> 功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了<code>size - 1</code>个字符为止，最后会自动加上字符 ‘<code>\0</code>‘ 作为字符串结束。<br>参数：<br>    <code>s</code>：字符串<br>    <code>size</code>：指定最大读取字符串的长度（size - 1）<br>    <code>stream</code>：文件指针，如果读键盘输入的字符串，固定写为stdin<br>返回值：<br>    成功：成功读取的字符串<br>    读到文件尾或出错： NULL</p><p> <code>fgets()</code>在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。通过<code>scanf</code>和<code>gets</code>输入一个字符串的时候，不包含结尾的“<code>\n</code>”，但通过<code>fgets</code>结尾多了“<code>\n</code>”。<code>fgets()</code>函数是安全的，不存在缓冲区溢出的问题</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入str: &quot;</span>);</span><br><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str = \&quot;%s\&quot;\n&quot;</span>, str);</span><br></pre></td></tr></table></figure><h5 id="3-puts"><a href="#3-puts" class="headerlink" title="3. puts()"></a>3. puts()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：标准设备输出s字符串，<font color="red">在输出完成后自动输出一个’\n’。</font></p><p>参数：</p><p>​    s：字符串首地址</p><p>返回值：</p><p>​    成功：非负数</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-fputs"><a href="#4-fputs" class="headerlink" title="4. fputs()"></a>4. fputs()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 ‘\0’  不写入文件。 </p><p>参数：</p><p>​    str：字符串</p><p>​    stream：文件指针，<font color="red">如果把字符串输出到屏幕，固定写为stdout</font></p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote><p><code>fputs()</code>是<code>puts()</code>的文件操作版本，但<code>fputs()</code><font color="red">不会</font>自动输出一个’<code>\n</code>‘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello world&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure><h5 id="5-strlen"><a href="#5-strlen" class="headerlink" title="5. strlen()"></a>5. strlen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：计算指定指定字符串s的长度，<font color="red">不包含字符串结束符‘<code>\0</code>’</font></p><p>参数：</p><p>​    s：字符串首地址</p><p>返回值：字符串s的长度，size_t为unsigned int类型</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abc\0defg&quot;</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 n = 3</span></span><br></pre></td></tr></table></figure><h4 id="5-5-4-字符串追加"><a href="#5-5-4-字符串追加" class="headerlink" title="5.5.4 字符串追加"></a>5.5.4 字符串追加</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">char</span> dst[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str1[i] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">dst[i] = str1[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str2[j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">dst[i + j] = str2[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">dst[i + j] = <span class="number">0</span>; <span class="comment">//字符串结束符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>, dst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><h4 id="6-1-1-函数分类"><a href="#6-1-1-函数分类" class="headerlink" title="6.1.1 函数分类"></a>6.1.1 函数分类</h4><p>C 程序是由函数组成的，我们写的代码都是由主函数 main()开始执行的。函数是 C 程序的基本模块，是用于完成特定任务的程序代码单元</p><p>从函数定义的角度看，函数可分为系统函数和用户定义函数两种：</p><ul><li><p>系统函数，即库函数：这是由编译系统提供的，用户不必自己定义这些函数，可以直接使用它们，如我们常用的打印函数printf()。</p></li><li><p>用户定义函数：用以解决用户的专门需要</p></li></ul><h4 id="6-1-2-函数的作用"><a href="#6-1-2-函数的作用" class="headerlink" title="6.1.2 函数的作用"></a>6.1.2 函数的作用</h4><blockquote><p>函数的使用可以省去重复代码的编写，降低代码重复率</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 求两数的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>, b1 = <span class="number">20</span>, c1 = <span class="number">0</span>;</span><br><span class="line">    c1 = max(a1, b1); <span class="comment">// 调用max()</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">11</span>, b2 = <span class="number">21</span>, c2 = <span class="number">0</span>;</span><br><span class="line">    c2 = max(a2, b2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">6</span>$ ./<span class="number">6.1</span><span class="number">.2</span> </span><br><span class="line">c1= <span class="number">20</span>, c2 = <span class="number">21</span></span><br></pre></td></tr></table></figure><blockquote><p>函数可以让程序更加模块化，从而有利于程序的阅读，修改和完善</p></blockquote><p>假如我们编写一个实现以下功能的程序：读入一行数字；对数字进行排序；找到它们的平均值；打印出一个柱状图。如果我们把这些操作直接写在main()里，这样可能会给用户感觉代码会有点凌乱。但，假如我们使用函数，这样可以让程序更加清晰、模块化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> <span class="built_in">list</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里只是举例，函数还没有实现</span></span><br><span class="line">readlist(<span class="built_in">list</span>, <span class="number">50</span>);</span><br><span class="line">sort(<span class="built_in">list</span>, <span class="number">50</span>);</span><br><span class="line">average(<span class="built_in">list</span>, <span class="number">50</span>);</span><br><span class="line">bargraph(<span class="built_in">list</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们可以这么理解，<font color="red">程序就像公司，公司是由部门组成的，这个部门就类似于C程序的函数</font>。默认情况下，公司就是一个大部门( 只有一个部门的情况下 )，相当于C程序的<code>main()</code>函数。如果公司比较小( 程序比较小 )，因为任务少而简单，一个部门即可( <code>main()</code>函数 )胜任。但是，如果这个公司很大( 大型应用程序 )，任务多而杂，如果只是一个部门管理( 相当于没有部门，没有分工 )，我们可想而知，公司管理、运营起来会有多混乱，不是说这样不可以运营，只是这样不完美而已，如果根据公司要求分成一个个部门( 根据功能封装一个一个函数 )，招聘由行政部门负责，研发由技术部门负责等，这样就可以分工明确，结构清晰，方便管理，各部门之间还可以相互协调</p><h4 id="6-1-3-函数的调用：产生随机数"><a href="#6-1-3-函数的调用：产生随机数" class="headerlink" title="6.1.3 函数的调用：产生随机数"></a>6.1.3 函数的调用：产生随机数</h4><p>当调用函数时，需要关心5要素：</p><ul><li><p>头文件：包含指定的头文件</p></li><li><p>函数名字：函数名字必须和头文件声明的名字一样</p></li><li><p>功能：需要知道此函数能干嘛后才调用</p></li><li><p>参数：参数类型要匹配</p></li><li><p>返回值：根据需要接收返回值</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *t)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：获取当前系统时间</p><p>参数：常设置为NULL</p><p>返回值：当前系统时间, <em>time_t</em> 相当于long类型，单位为毫秒</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：用来设置<code>rand()</code>产生随机数时的随机种子</p><p>参数：如果每次seed相等，<code>rand()</code>产生随机数相等</p><p>返回值：无</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：返回一个随机数值</p><p>参数：无</p><p>返回值：随机数</p></blockquote><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><h4 id="6-2-1-函数定义格式"><a href="#6-2-1-函数定义格式" class="headerlink" title="6.2.1 函数定义格式"></a>6.2.1 函数定义格式</h4><p>函数定义的一般形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(形式参数列表)</span><br><span class="line">&#123;</span><br><span class="line">数据定义部分;</span><br><span class="line">执行语句部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202306291938386.jpg" alt="20150310105403075"></p><h4 id="6-2-2-函数名字、形参、函数体、返回值"><a href="#6-2-2-函数名字、形参、函数体、返回值" class="headerlink" title="6.2.2 函数名字、形参、函数体、返回值"></a>6.2.2 函数名字、形参、函数体、返回值</h4><h5 id="1-函数名"><a href="#1-函数名" class="headerlink" title="1. 函数名"></a>1. 函数名</h5><p>理论上是可以随意起名字，最好起的名字见名知意，应该让用户看到这个函数名字就知道这个函数的功能。注意，函数名的后面有个圆换号()，代表这个为函数，不是普通的变量名。</p><h5 id="2-形参列表"><a href="#2-形参列表" class="headerlink" title="2. 形参列表"></a>2. 形参列表</h5><p>在定义函数时指定的形参，<font color="red">在未出现函数调用时，它们并不占内存中的存储单元</font>，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>)</span> <span class="comment">// error, 形参不能赋值</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在定义函数时指定的形参，必须是，类型+变量的形式：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1: right, 类型+变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2: error, 只有类型，没有变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3: error, 只有变量，没有类型</span></span><br><span class="line"><span class="type">int</span> a, <span class="type">int</span> b;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(a, b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义函数时指定的形参，可有可无，根据函数的需要来设计，<font color="red">如果没有形参，圆括号内容为空，或写一个<code>void</code>关键字：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没形参， 圆括号内容为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没形参， 圆括号内容为void关键字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-函数体"><a href="#3-函数体" class="headerlink" title="3. 函数体"></a>3. 函数体</h5><p>花括号{ }里的内容即为函数体的内容，这里<font color="red">为函数功能实现的过程</font>，这和以前的写代码没太大区别，以前我们把代码写在main()函数里，现在只是把这些写到别的函数里。</p><h5 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h5><p>函数的返回值是通过函数中的return语句获得的，return后面的值也可以是一个表达式</p><ul><li><p>尽量保证return语句中表达式的值和函数返回类型是同一类型</p></li><li><p>```c<br>int max() // 函数的返回值为int类型<br>{</p><pre><code>int a = 10;return a;// 返回值a为int类型，函数返回类型也是int，匹配</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即&lt;font color=&quot;red&quot;&gt;函数返回类型决定返回值的类型&lt;/font&gt;。对数值型数据，可以自动进行类型转换</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  double max() // 函数的返回值为double类型</span><br><span class="line">  &#123;</span><br><span class="line">  int a = 10;</span><br><span class="line">  return a;// 返回值a为int类型，它会转为double类型再返回</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果函数返回的类型和return语句中表达式的值不一致，而它又无法自动进行类型转换，程序则会报错</p></blockquote></li><li><p>return语句的另一个作用为中断return所在的执行函数，类似于break中断循环、switch语句一样</p></li><li><p>```c<br>int max()<br>{</p><pre><code>return 1;// 执行到，函数已经被中断，所以下面的return 2无法被执行到return 2;// 没有执行</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果函数带返回值，return后面必须跟着一个值，如果函数没有返回值，函数名字的前面必须写一个`void`关键字，这时候，我们写代码时也可以通过return中断函数(也可以不用)，只是这时，`return`后面不带内容( 分号“`;`”除外)</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  void max()// 最好要有void关键字</span><br><span class="line">  &#123;</span><br><span class="line">  return; // 中断函数，这个可有可无</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><font color="red">定义函数后，我们需要调用此函数才能执行到这个函数里的代码段</font>。这和main()函数不一样，main()为编译器设定好自动调用的主函数，无需人为调用，我们都是在main()函数里调用别的函数，<font color="red">一个 C 程序里有且只有一个main()函数</font><h4 id="6-3-1-函数执行流程"><a href="#6-3-1-函数执行流程" class="headerlink" title="6.3.1 函数执行流程"></a>6.3.1 函数执行流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is for test\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">print_test();<span class="comment">// print_test函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.进入<code>mian()</code>函数</li><li>2.调用<code>print_test()</code>函数<ul><li>a. 它会在main()函数的前寻找有没有一个名字叫“print_test”的函数定义；</li><li>b. 如果找到，接着检查函数的参数，这里调用函数时没有传参，函数定义也没有形参，参数类型匹配；</li><li>c. 开始执行<code>print_test()</code>函数，这时候，<code>main()</code>函数里面的执行会阻塞( 停 )在<code>print_test()</code>这一行代码，等待<code>print_test()</code>函数的执行</li></ul></li><li><code>print_test()</code>函数执行完( 这里打印一句话 )，<code>main()</code>才会继续往下执行，执行到<code>return 0</code>, 程序执行完毕</li></ul><h4 id="6-3-2-函数的形参和实参"><a href="#6-3-2-函数的形参和实参" class="headerlink" title="6.3.2 函数的形参和实参"></a>6.3.2 函数的形参和实参</h4><ul><li>形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用</li><li>实参出现在主调函数中，进入被调函数后，实参也不能使用</li><li>实参变量对形参变量的数据传递是“值传递”，即单向传递，只<font color="red">由实参传给形参，而不能由形参传回来给实参</font></li><li>在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放</li><li>实参单元与形参单元是不同的单元。调用结束后，形参单元被释放，函数调用结束返回主调函数后则不能再使用该形参变量。实参单元仍保留并维持原值。<font color="red">因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调函数中实参的值</font></li></ul><h4 id="6-3-3-无参函数调用"><a href="#6-3-3-无参函数调用" class="headerlink" title="6.3.3 无参函数调用"></a>6.3.3 无参函数调用</h4><blockquote><p>如果是调用无参函数，则不能加上“实参”，但括号不能省略</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line">test();<span class="comment">// right, 圆括号()不能省略</span></span><br><span class="line">test(<span class="number">250</span>); <span class="comment">// error, 函数定义时没有参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-4-有参函数调用"><a href="#6-3-4-有参函数调用" class="headerlink" title="6.3.4 有参函数调用"></a>6.3.4 有参函数调用</h4><blockquote><p>如果实参表列包含多个实参，则各参数间用逗号隔开</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">10</span>, q = <span class="number">20</span>;</span><br><span class="line">test(p, q);<span class="comment">// 函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实参与形参的个数应相等，类型应匹配(相同或赋值兼容)。实参与形参按顺序对应，一对一地传递数据</li><li>实参可以是常量、变量或表达式，<font color="red">无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参</font>。所以，这里的变量是在圆括号( )外面定义好、赋好值的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line"><span class="type">int</span> p = <span class="number">10</span>, q = <span class="number">20</span>;</span><br><span class="line">test(p, q);<span class="comment">// right</span></span><br><span class="line">test(<span class="number">11</span>, <span class="number">30</span> - <span class="number">10</span>); <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line">test(<span class="type">int</span> a, <span class="type">int</span> b); <span class="comment">// error, 不应该在圆括号里定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-5-函数返回值"><a href="#6-3-5-函数返回值" class="headerlink" title="6.3.5 函数返回值"></a>6.3.5 函数返回值</h4><blockquote><p>如果函数定义没有返回值，函数调用时不能写<code>void</code>关键字，调用函数时也不能接收函数的返回值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line">test(); <span class="comment">// right</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>; <span class="comment">// error, void关键字只能出现在定义，不可能出现在调用的地方</span></span><br><span class="line"><span class="type">int</span> a = test();<span class="comment">// error, 函数定义根本就没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数定义有返回值，这个返回值我们根据用户需要可用可不用，但是，假如我们需要使用这个函数返回值，<font color="red">我们需要定义一个匹配类型的变量来接收</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数的定义, 返回值为int类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line"><span class="type">int</span> a = test(); <span class="comment">// right, a为int类型</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b = test();<span class="comment">// right, 和上面等级</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = test(); <span class="comment">// 虽然调用成功没有意义, p为char *, 函数返回值为int, 类型不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error, 必须定义一个匹配类型的变量来接收返回值</span></span><br><span class="line"><span class="comment">// int只是类型，没有定义变量</span></span><br><span class="line"><span class="type">int</span> = test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// error, 必须定义一个匹配类型的变量来接收返回值</span></span><br><span class="line"><span class="comment">// int只是类型，没有定义变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-4-函数的声明"><a href="#6-4-函数的声明" class="headerlink" title="6.4 函数的声明"></a>6.4 函数的声明</h3><p>如果使用用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者<font color="red">函数定义的位置在主调函数之后</font>，则必须在调用此函数之前对被调用的函数作声明</p><p>所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行</p><blockquote><p>注意：一个函数只能被定义一次，但可以声明多次</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">// 函数的声明，分号不能省略</span></span><br><span class="line"><span class="comment">// int max(int, int); // 另一种方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>, num_max = <span class="number">0</span>;</span><br><span class="line">num_max = max(a, b); <span class="comment">// 函数的调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num_max = %d\n&quot;</span>, num_max);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数定义和声明的区别：</strong></p><ul><li>定义是指对函数功能的确立，包括指定函数名、函数类型、形参及其类型、函数体等，它是一个完整的、独立的函数单位</li><li>声明的作用则是把函数的名字、函数类型以及形参的个数、类型和顺序(注意，不包括函数体)通知编译系统，以便在对包含函数调用的语句进行编译时，据此对其进行对照检查（例如函数名是否正确，实参与形参的类型和个数是否一致）</li></ul><h3 id="6-5-main函数与exit函数"><a href="#6-5-main函数与exit函数" class="headerlink" title="6.5 main函数与exit函数"></a>6.5 main函数与exit函数</h3><p>在<code>main</code>函数中调用<code>exit</code>和<code>return</code>结果是一样的，但在子函数中调用<code>return</code>只是代表子函数终止了，在子函数中调用<code>exit</code>，那么程序终止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fun\n&quot;</span>);</span><br><span class="line"><span class="comment">// return;</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-多文件-分文件-编程"><a href="#6-6-多文件-分文件-编程" class="headerlink" title="6.6 多文件(分文件)编程"></a>6.6 多文件(分文件)编程</h3><h4 id="6-6-1-分文件编程"><a href="#6-6-1-分文件编程" class="headerlink" title="6.6.1 分文件编程"></a>6.6.1 分文件编程</h4><ul><li>把函数声明放在头文件<code>xxx.h</code>中，在主函数中包含相应头文件</li><li>在头文件对应的<code>xxx.c</code>中实现<code>xxx.h</code>声明的函数</li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011648955.jpg" alt="2016-06-04_014552"></p><h4 id="6-6-2-防止头文件重复包含"><a href="#6-6-2-防止头文件重复包含" class="headerlink" title="6.6.2 防止头文件重复包含"></a>6.6.2 防止头文件重复包含</h4><blockquote><p>当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件 include 多次，或者头文件嵌套包含</p></blockquote><p>a.h 中包含 b.h ：<code>#include &quot;b.h&quot;</code></p><p>b.h 中包含 a.h：<code>#include &quot;a.h&quot;</code></p><p>main.c中使用其中头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错!!!</p><p>为了避免同一个文件被include多次，C/C++中有两种方式解决：</p><ul><li><p>法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// 声明语句</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><h4 id="7-1-1-内存"><a href="#7-1-1-内存" class="headerlink" title="7.1.1 内存"></a>7.1.1 内存</h4><p>内存含义：</p><ul><li><p>存储器：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。</p></li><li><p>内存：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR2、DDR3。</p></li><li><p>外存：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘</p></li></ul><p>内存是沟通CPU与硬盘的桥梁：</p><ul><li><p>暂存放CPU中的运算数据</p></li><li><p>暂存与硬盘等外部存储器交换的数据</p></li></ul><h4 id="7-1-2-物理存储器和存储地址空间"><a href="#7-1-2-物理存储器和存储地址空间" class="headerlink" title="7.1.2 物理存储器和存储地址空间"></a>7.1.2 物理存储器和存储地址空间</h4><blockquote><p>有关内存的两个概念：物理存储器和存储地址空间</p></blockquote><p>物理存储器：实际存在的具体存储器芯片。</p><ul><li><p>主板上装插的内存条</p></li><li><p>显示卡上的显示RAM芯片</p></li><li><p>各种适配卡上的RAM芯片和ROM芯片</p></li></ul><p>存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义</p><ul><li>编码：对每个物理存储单元（一个字节）分配一个号码</li><li>寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写</li></ul><h4 id="7-1-3-内存地址"><a href="#7-1-3-内存地址" class="headerlink" title="7.1.3 内存地址"></a>7.1.3 内存地址</h4><ul><li><p>将内存抽象成一个很大的一维字符数组</p></li><li><p>编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）</p></li><li><p>这个内存编号我们称之为内存地址。</p><p>内存中的每一个数据都会分配相应的地址：</p><ul><li><code>char</code>:占一个字节分配一个地址</li><li><code>int</code>: 占四个字节分配四个地址</li><li><code>float</code>、<code>struct</code>、函数、数组等</li></ul></li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011648914.png" alt="图片1"></p><h4 id="7-1-4-指针和指针变量"><a href="#7-1-4-指针和指针变量" class="headerlink" title="7.1.4 指针和指针变量"></a>7.1.4 指针和指针变量</h4><ul><li><font color="red">内存区的每一个字节都有一个编号，这就是“地址”</font></li><li>如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)</li><li>指针的实质就是内存“地址”。指针就是地址，地址就是指针</li><li><font color="red">指针是内存单元的编号，指针变量是存放地址的变量</font></li><li>通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样</li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011648370.png" alt="图片2"></p><h3 id="7-2-指针基础知识"><a href="#7-2-指针基础知识" class="headerlink" title="7.2 指针基础知识"></a>7.2 指针基础知识</h3><h4 id="7-2-1-指针变量的定义和使用"><a href="#7-2-1-指针变量的定义和使用" class="headerlink" title="7.2.1 指针变量的定义和使用"></a>7.2.1 指针变量的定义和使用</h4><ul><li><p>指针也是一种数据类型，指针变量也是一种变量</p></li><li><p>指针变量指向谁，就把谁的地址赋值给指针变量</p></li><li>“*”操作符操作的是指针变量指向的内存空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;a, &amp;b); <span class="comment">//打印a, b的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int *代表是一种数据类型，int*指针类型，p才是变量名</span></span><br><span class="line"><span class="comment">//定义了一个指针类型的变量，可以指向一个int类型变量的地址</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;<span class="comment">//将a的地址赋值给变量p，p也是一个变量，值是一个内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);<span class="comment">//p指向了a的地址，*p就是a的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p1 = &amp;b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p1);<span class="comment">//*p1指向了b的地址，*p1就是b的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>&amp;</code>可以取得一个变量在内存中的地址。但是，<font color="red">不能取寄存器变量</font>，因为寄存器变量不在内存里，而在CPU里面，所以是没有地址的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/7$ ./7.2.1 </span><br><span class="line">0x7ffda2091cf4, 0x7ffda2091cf3</span><br><span class="line">0</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="7-2-2-通过指针间接修改变量的值"><a href="#7-2-2-通过指针间接修改变量的值" class="headerlink" title="7.2.2 通过指针间接修改变量的值"></a>7.2.2 通过指针间接修改变量的值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d, *p=%d\n&quot;</span>, a, *p);</span><br><span class="line"></span><br><span class="line">p = &amp;b</span><br><span class="line">*p = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d, *p = %d\n&quot;</span>, b, *p);</span><br></pre></td></tr></table></figure><h4 id="7-2-3-指针大小"><a href="#7-2-3-指针大小" class="headerlink" title="7.2.3 指针大小"></a>7.2.3 指针大小</h4><ul><li><font color="red">使用sizeof()测量指针的大小，得到的总是：4或8</font></li><li><code>sizeof()</code>测的是指针变量指向存储地址的大小</li><li>在32位平台，所有的指针（地址）都是32位(4字节)</li><li>在64位平台，所有的指针（地址）都是64位(8字节)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p1;</span><br><span class="line">    <span class="type">int</span> **p2;</span><br><span class="line">    <span class="type">char</span> *p3;</span><br><span class="line">    <span class="type">char</span> **p4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p1) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p2) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p3) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(p4) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(double *) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span> *));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(p1) = <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(p2) = <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(p3) = <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(p4) = <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">double</span> *) = <span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="7-2-4-野指针和空指针"><a href="#7-2-4-野指针和空指针" class="headerlink" title="7.2.4 野指针和空指针"></a>7.2.4 野指针和空指针</h4><p>指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，<font color="red">任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针</font>，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，<font color="red">野指针不会直接引发错误，操作野指针指向的内存区域才会出问题</font>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a; <span class="comment">//把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">0x12345678</span>; <span class="comment">//给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">1000</span>;  <span class="comment">//操作野指针指向未知区域，内存出问题，err</span></span><br></pre></td></tr></table></figure><p>但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>NULL是一个值为0的宏常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL    ((void *)0)</span></span><br></pre></td></tr></table></figure><h4 id="7-2-5-万能指针void"><a href="#7-2-5-万能指针void" class="headerlink" title="7.2.5 万能指针void *"></a>7.2.5 万能指针void *</h4><blockquote><p><code>void *</code>指针可以指向任意变量的内存空间</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">p = (<span class="type">void</span> *)&amp;a; <span class="comment">//指向变量时，最好转换为void *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针变量指向的内存时，转换为int *</span></span><br><span class="line">*( (<span class="type">int</span> *)p ) = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><h4 id="7-2-6-const修饰的指针变量"><a href="#7-2-6-const修饰的指针变量" class="headerlink" title="7.2.6 const修饰的指针变量"></a>7.2.6 const修饰的指针变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="comment">//修饰*，指针指向内存区域不能修改，指针指向可以变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a;</span><br><span class="line"><span class="comment">// *p1 = 111 // err</span></span><br><span class="line">p1 = &amp;b; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//修饰p1，指针指向不能变，指针指向的内存可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">// p2 = &amp;b; //err</span></span><br><span class="line">*p2 = <span class="number">333</span>; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><font color="red">在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用const修饰指针数据类型</font><h3 id="7-3-指针和数组"><a href="#7-3-指针和数组" class="headerlink" title="7.3 指针和数组"></a>7.3 指针和数组</h3><h4 id="7-3-1-数组名"><a href="#7-3-1-数组名" class="headerlink" title="7.3.1 数组名"></a>7.3.1 数组名</h4><p>数组名字是数组的首元素地址，但它是一个地址常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = %p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 10; //err, 数组名只是常量，不能修改</span></span><br></pre></td></tr></table></figure><h4 id="7-3-2-指针操作数组元素"><a href="#7-3-2-指针操作数组元素" class="headerlink" title="7.3.2 指针操作数组元素"></a>7.3.2 指针操作数组元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d, &quot; a[i]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    p[i] = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">7</span>$ ./<span class="number">7.3</span><span class="number">.2</span> </span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br><span class="line"><span class="number">0246810121416</span></span><br></pre></td></tr></table></figure><h4 id="7-3-3-指针加减运算"><a href="#7-3-3-指针加减运算" class="headerlink" title="7.3.3 指针加减运算"></a>7.3.3 指针加减运算</h4><h5 id="1-加法运算"><a href="#1-加法运算" class="headerlink" title="1. 加法运算"></a>1. 加法运算</h5><ul><li><font color="red">指针计算不是简单的整数相加</font></li><li>如果是一个<code>int *</code>，+1的结果是增加一个int的大小</li><li>如果是一个<code>char *</code>，+1的结果是增加一个char大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line">    p += <span class="number">2</span>; <span class="comment">//移动了2个int</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *p1 = &amp;b;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p1);</span><br><span class="line">    p1 += <span class="number">2</span>;<span class="comment">// 移动了2个char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过改变指针指向操作数组元素：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, *p);</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-减法运算"><a href="#2-减法运算" class="headerlink" title="2. 减法运算"></a>2. 减法运算</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = a+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, *p);</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/7$ ./7.3.3-2 </span><br><span class="line">9, 8, 7, 6, 5, 4, 3, 2, 1, </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;a[<span class="number">2</span>]; <span class="comment">//第2个元素地址</span></span><br><span class="line"><span class="type">int</span> *p1 = &amp;a[<span class="number">1</span>]; <span class="comment">//第1个元素地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1 = %p, p2 = %p\n&quot;</span>, p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1 = p2 - p1; <span class="comment">//n1 = 1</span></span><br><span class="line"><span class="type">int</span> n2 = (<span class="type">int</span>)p2 - (<span class="type">int</span>)p1; <span class="comment">//n2 = 4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n1 = %d, n2 = %d\n&quot;</span>, n1, n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-4-指针数组"><a href="#7-3-4-指针数组" class="headerlink" title="7.3.4  指针数组"></a>7.3.4  指针数组</h4><p>指针数组，它是数组，数组的每个元素都是指针类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 指针数组</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>] = &amp;b;</span><br><span class="line">p[<span class="number">1</span>] = &amp;b;</span><br><span class="line">p[<span class="number">2</span>] = &amp;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(p)/<span class="keyword">sizeof</span>(p[<span class="number">0</span>]);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, *(p[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-多级指针"><a href="#7-4-多级指针" class="headerlink" title="7.4 多级指针"></a>7.4 多级指针</h3><ul><li>C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针</li><li>二级指针就是指向一个一级指针变量地址的指针</li><li>三级指针基本用不着，但考试会考</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">//一级指针</span></span><br><span class="line">*p = <span class="number">100</span>; <span class="comment">//*p就是a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **q = &amp;p;</span><br><span class="line"><span class="comment">//*q就是p</span></span><br><span class="line"><span class="comment">//**q就是a</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ***t = &amp;q;</span><br><span class="line"><span class="comment">//*t就是q</span></span><br><span class="line"><span class="comment">//**t就是p</span></span><br><span class="line"><span class="comment">//***t就是a</span></span><br></pre></td></tr></table></figure><h3 id="7-5-指针和函数"><a href="#7-5-指针和函数" class="headerlink" title="7.5 指针和函数"></a>7.5 指针和函数</h3><h4 id="7-5-1-函数形参改变实参的值"><a href="#7-5-1-函数形参改变实参的值" class="headerlink" title="7.5.1 函数形参改变实参的值"></a>7.5.1 函数形参改变实参的值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">tmp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = tmp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap2</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">tmp = *x;</span><br><span class="line">*x = *y;</span><br><span class="line">*y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">swap1(a, b); <span class="comment">// 值传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">5</span>;</span><br><span class="line">swap2(&amp;a, &amp;b);<span class="comment">// 地址传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a2 = %d, b2=%d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/7$ ./7.5.1 </span><br><span class="line">x=5, y=3</span><br><span class="line">a = 3, b = 5</span><br><span class="line">a2 = 5, b2=3</span><br></pre></td></tr></table></figure><h4 id="7-5-2-数组名做函数参数"><a href="#7-5-2-数组名做函数参数" class="headerlink" title="7.5.2 数组名做函数参数"></a>7.5.2 数组名做函数参数</h4><blockquote><p>数组名做函数参数，函数的形参会退化为指针：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArrary</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名做函数参数</span></span><br><span class="line">printArrary(a, n); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, </span><br></pre></td></tr></table></figure><h4 id="7-5-3-指针做为函数的返回值"><a href="#7-5-3-指针做为函数的返回值" class="headerlink" title="7.5.3 指针做为函数的返回值"></a>7.5.3 指针做为函数的返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">getA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">*(getA()) = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"><span class="comment">// 输出： a = 111;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-指针和字符串"><a href="#7-6-指针和字符串" class="headerlink" title="7.6 指针和字符串"></a>7.6 指针和字符串</h3><h4 id="7-6-1-字符指针"><a href="#7-6-1-字符指针" class="headerlink" title="7.6.1 字符指针"></a>7.6.1 字符指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = str;</span><br><span class="line">*p = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">p++;</span><br><span class="line">*p=<span class="string">&#x27;i&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">p = <span class="string">&quot;mike Tao&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *q = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">7</span>$ ./<span class="number">7.6</span><span class="number">.1</span> </span><br><span class="line">millo world</span><br><span class="line">mike Tao</span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="7-6-2-字符指针做函数参数"><a href="#7-6-2-字符指针做函数参数" class="headerlink" title="7.6.2 字符指针做函数参数"></a>7.6.2 字符指针做函数参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mystract</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dest[len1])</span><br><span class="line">    &#123;</span><br><span class="line">        len1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(src[len2])</span><br><span class="line">    &#123;</span><br><span class="line">        len2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dest[len1 + i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> dst[<span class="number">100</span>] = <span class="string">&quot;hello mike&quot;</span>;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    mystract(dst,src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>, dst);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">7</span>$ ./<span class="number">7.7</span><span class="number">.3</span> </span><br><span class="line">dst = hello mike123456</span><br></pre></td></tr></table></figure><h4 id="7-6-3-const-修饰的指针变量"><a href="#7-6-3-const-修饰的指针变量" class="headerlink" title="7.6.3 const 修饰的指针变量"></a>7.6.3 const 修饰的指针变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// const 修饰一个变量为只读</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// a = 100; //error</span></span><br><span class="line">    </span><br><span class="line">    /指针变量， 指针指向的内存， <span class="number">2</span>个不同概念</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;aklgjdlsgjlkds&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从左往右看，跳过类型，看修饰哪个字符</span></span><br><span class="line"><span class="comment">//如果是*， 说明指针指向的内存不能改变</span></span><br><span class="line"><span class="comment">//如果是指针变量，说明指针的指向不能改变，指针的值不能修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = buf;</span><br><span class="line">    <span class="comment">// 等价于上同  char const *p1 = buf;</span></span><br><span class="line">    <span class="comment">//p[1] = &#x27;2&#x27;; //err</span></span><br><span class="line">    </span><br><span class="line">    p = <span class="string">&quot;agdlsjaglkdsajgl&quot;</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p2 = buf;</span><br><span class="line">    p2[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="comment">//p2 = &quot;salkjgldsjaglk&quot;; //err</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//p3为只读，指向不能变，指向的内存也不能变</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p3 = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-4-指针数组做为main函数的形参"><a href="#7-6-4-指针数组做为main函数的形参" class="headerlink" title="7.6.4 指针数组做为main函数的形参"></a>7.6.4 指针数组做为main函数的形参</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><ul><li><code>main</code>函数是操作系统调用的，第一个参数标明<code>argc</code>数组的成员数量，<code>argv</code>数组的每个成员都是<code>char *</code>类型</li><li><code>argv</code>是命令行参数的字符串数组</li><li><code>argc</code>代表命令行参数的数量，程序名字本身算一个参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//argc: 传参数的个数（包含可执行程序）</span></span><br><span class="line"><span class="comment">//argv：指针数组，指向输入的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针数组，它是数组，每个元素都是指针</span></span><br><span class="line"><span class="type">char</span> *a[] = &#123; <span class="string">&quot;aaaaaaa&quot;</span>, <span class="string">&quot;bbbbbbbbbb&quot;</span>, <span class="string">&quot;ccccccc&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-5-项目开发常用字符串应用模型"><a href="#7-6-5-项目开发常用字符串应用模型" class="headerlink" title="7.6.5 项目开发常用字符串应用模型"></a>7.6.5 项目开发常用字符串应用模型</h4><h5 id="1-strstr中的while和do-while模型"><a href="#1-strstr中的while和do-while模型" class="headerlink" title="1. strstr中的while和do-while模型"></a>1. strstr中的while和do-while模型</h5><blockquote><p>利用strstr标准库函数找出一个字符串中substr出现的个数</p></blockquote><h6 id="a-while模型"><a href="#a-while模型" class="headerlink" title="a. while模型"></a>a. while模型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((p = <span class="built_in">strstr</span>(p, <span class="string">&quot;abcd&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//能进来，肯定有匹配的子串</span></span><br><span class="line"><span class="comment">//重新设置起点位置</span></span><br><span class="line">        p = p + <span class="built_in">strlen</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        n++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="number">0</span>) <span class="comment">// 结束符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 n = 4</span></span><br></pre></td></tr></table></figure><h6 id="b-do-while"><a href="#b-do-while" class="headerlink" title="b. do-while"></a>b. do-while</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;11abcd111122abcd333abcd3322abcd3333322qqq&quot;</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">p = <span class="built_in">strstr</span>(p, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line"><span class="comment">// 重新设置查找的起点</span></span><br><span class="line">p = p + <span class="built_in">strlen</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(*p != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-两头堵模型"><a href="#5-两头堵模型" class="headerlink" title="5. 两头堵模型"></a>5. 两头堵模型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> *n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p = <span class="literal">NULL</span> || n = <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="built_in">strlen</span>(p) - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//从左边开始</span></span><br><span class="line"><span class="comment">//如果当前字符为空，而且没有结束</span></span><br><span class="line">    <span class="keyword">while</span>(p[begin] = <span class="string">&#x27;&#x27; &amp;&amp; p[begin] != 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        begin++;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //从右往左移动</span></span><br><span class="line"><span class="string">while (p[end] == &#x27;</span> <span class="string">&#x27; &amp;&amp; end &gt; 0)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">end--; //往左移动</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">if (end == 0)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return -2;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//非空元素个数</span></span><br><span class="line"><span class="string">*n = end - begin + 1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    char *p = &quot;      abcddsgadsgefg      &quot;;</span></span><br><span class="line"><span class="string">    int ret = 0;</span></span><br><span class="line"><span class="string">    int n = 0;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ret = fun(p, &amp;n);</span></span><br><span class="line"><span class="string">    if(ret != 0)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        return ret;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    printf(&quot;非空字符串元素个数：%d\n&quot;, n);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">7</span>$ ./<span class="number">7.6</span><span class="number">.5</span><span class="number">-2</span> </span><br><span class="line">非空字符串元素个数：<span class="number">14</span></span><br></pre></td></tr></table></figure><h5 id="3-字符串反转模型-逆置"><a href="#3-字符串反转模型-逆置" class="headerlink" title="3. 字符串反转模型(逆置)"></a>3. 字符串反转模型(逆置)</h5><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649028.png" alt="图片1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inverse</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *str = p;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="built_in">strlen</span>(str) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 交换元素</span></span><br><span class="line">        tmp = str[begin];</span><br><span class="line">        str[begin] = str[end];</span><br><span class="line">        str[end] = tmp;</span><br><span class="line">        </span><br><span class="line">        begin++;  <span class="comment">//往右移动位置</span></span><br><span class="line">        end--;<span class="comment">// 往左移动位置</span></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//char *str = &quot;abcdefg&quot;; //文件常量区，内容不允许修改</span></span><br><span class="line">        <span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ret = inverse(str);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">7</span>$ ./<span class="number">7.6</span><span class="number">.5</span><span class="number">-3</span> </span><br><span class="line">str = fedcba</span><br></pre></td></tr></table></figure><h4 id="7-6-6-字符串处理函数"><a href="#7-6-6-字符串处理函数" class="headerlink" title="7.6.6 字符串处理函数"></a>7.6.6 字符串处理函数</h4><h5 id="1-strcpy"><a href="#1-strcpy" class="headerlink" title="1. strcpy()"></a>1. strcpy()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：把src所指向的字符串复制到dest所指向的空间中，<font color="red">‘\0’也会拷贝过去</font></p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p></blockquote><font color="red">注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(dest, src);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);</span><br></pre></td></tr></table></figure><h5 id="2-strncpy"><a href="#2-strncpy" class="headerlink" title="2. strncpy()"></a>2. strncpy()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：把src指向字符串的前n个字符复制到dest所指向的空间中，<font color="red">是否拷贝结束符看指定的长度是否包含’\0’。</font>&gt;</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>​    n：指定需要拷贝字符串个数</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] ;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);</span><br><span class="line"></span><br><span class="line">dest[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-strcat"><a href="#3-strcat" class="headerlink" title="3. strcat()"></a>3. strcat()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将src字符串连接到dest的尾部，‘\0’也会追加过去</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> *src = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strcat</span>(str, src));</span><br></pre></td></tr></table></figure><h5 id="4-strncat"><a href="#4-strncat" class="headerlink" title="4. strncat"></a>4. strncat</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将src字符串前n个字符连接到dest的尾部，‘\0’也会追加过去</p><p>参数：</p><p>​    dest：目的字符串首地址</p><p>​    src：源字符首地址</p><p>​    n：指定需要追加字符串个数</p><p>返回值：</p><p>​    成功：返回dest字符串的首地址</p><p>​    失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> *src = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strncat</span>(str, src, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h5 id="5-strcmp"><a href="#5-strcmp" class="headerlink" title="5. strcmp"></a>5. strcmp</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：比较 s1 和 s2 的大小，<font color="red">比较的是字符ASCII码大小。</font></p><p>参数：</p><p>​    s1：字符串1首地址</p><p>​    s2：字符串2首地址</p><p>返回值：</p><p>​    相等：0</p><p>​    大于：&gt;0 在不同操作系统strcmp结果会不同  返回ASCII差值</p><p>​    小于：&lt;0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *str2 = <span class="string">&quot;hello mike&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1==str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1&gt;str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1&lt;str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="6-strncmp"><a href="#6-strncmp" class="headerlink" title="6. strncmp()"></a>6. strncmp()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：比较 s1 和 s2 前n个字符的大小，<font color="red">比较的是字符ASCII码大小。</font></p><p>参数：</p><p>​    s1：字符串1首地址</p><p>​    s2：字符串2首地址</p><p>​    n：指定比较字符串的数量</p><p>返回值：</p><p>​    相等：0</p><p>​    大于： &gt; 0</p><p>​    小于： &lt; 0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *str2 = <span class="string">&quot;hello mike&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(str1, str2, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1==str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, <span class="string">&quot;hello world&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1&gt;str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1&lt;str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-sprintf"><a href="#7-sprintf" class="headerlink" title="7. sprintf()"></a>7. sprintf()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 ‘<code>\0</code>‘ 为止。</p><p>参数：</p><p>​    str：字符串首地址</p><p>​    format：字符串格式，用法和printf()一样</p><p>返回值：</p><p>​    成功：实际格式化的字符个数</p><p>​    失败： - 1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dst[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, src = %s&quot;</span>, a, src);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len=<span class="built_in">sprintf</span>(dst, <span class="string">&quot;a = %d, src = %s&quot;</span>, a, src);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dst = \&quot; %s\&quot;\n&quot;</span>, dst);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br></pre></td></tr></table></figure><h5 id="8-sscanf"><a href="#8-sscanf" class="headerlink" title="8. sscanf()"></a>8. sscanf()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。</p><p>参数：</p><p>​    str：指定的字符串首地址</p><p>​    format：字符串格式，用法和scanf()一样</p><p>返回值：</p><p>​    成功：参数数目，成功转换的值的个数</p><p>​    失败： - 1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;a=10, b=20&quot;</span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">sscanf</span>(src, <span class="string">&quot;a=%d,  b=%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a:%d, b:%d\n&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><h5 id="9-strchr"><a href="#9-strchr" class="headerlink" title="9.strchr()"></a>9.strchr()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>功能</strong>：在字符串s中查找字母c出现的位置</p><p><strong>参数</strong>：</p><p>​    s：字符串首地址</p><p>​    c：匹配字母(字符)</p><p><strong>返回值</strong>：</p><p>​    成功：返回第一次出现的c地址</p><p>​    失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;ddda123abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">strchr</span>(src, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br></pre></td></tr></table></figure><h5 id="10-strstr"><a href="#10-strstr" class="headerlink" title="10. strstr()"></a>10. strstr()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：在字符串haystack中查找字符串needle出现的位置</p><p>参数：</p><p>​    haystack：源字符串首地址</p><p>​    needle：匹配字符串首地址</p><p>返回值：</p><p>​    成功：返回第一次出现的needle地址</p><p>​    失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;ddddabcd123abcd333abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">strstr</span>(src, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br></pre></td></tr></table></figure><h5 id="11-strtok"><a href="#11-strtok" class="headerlink" title="11. strtok()"></a>11. strtok()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：来将字符串分割成一个个片段。当<code>strtok()</code>在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。</p><p>参数：</p><p>​    str：指向欲分割的字符串</p><p>​    delim：为分割字符串中包含的所有字符</p><p>返回值：</p><p>​    成功：分割后字符串首地址</p><p>​    失败：NULL</p></blockquote><ul><li>在第一次调用时：<code>strtok()</code>必需给予参数s字符串</li><li>往后的调用则将参数s设置成NULL，每次调用成功则返回指向被分割出片段的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">100</span>] = <span class="string">&quot;adc*fvcv.ebcy*hghbdfg$casdert&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s = strtok(a, <span class="string">&quot;.*$&quot;</span>);<span class="comment">//将&quot;*&quot;分割的子串取出</span></span><br><span class="line"><span class="keyword">while</span> (s != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">s = strtok(<span class="literal">NULL</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12-atoi"><a href="#12-atoi" class="headerlink" title="12. atoi()"></a>12. atoi()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：<code>atoi()</code>会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符(‘\0’)才结束转换，并将结果返回返回值。</p><p>参数：</p><p>​    nptr：待转换的字符串</p><p>返回值：成功转换后整数</p></blockquote><p>类似的函数有：</p><ul><li><code>atof()</code>：把一个小数形式的字符串转化为一个浮点数</li><li><code>atol()</code>：将一个字符串转化为long类型</li></ul><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> str1[] = <span class="string">&quot;          -10&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = atoi(str1);</span><br><span class="line">printf(<span class="string">&quot;num1 = %d\n&quot;</span>, num1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> str2[] = <span class="string">&quot;0.123&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> num2 = atof(str2);</span><br><span class="line">printf(<span class="string">&quot;num2 = %lf\n&quot;</span>, num2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> str3[] = <span class="string">&quot;123L&quot;</span>;</span><br><span class="line"><span class="built_in">long</span> num3 = atol(str3);</span><br><span class="line">printf(<span class="string">&quot;num3 = %ld\n&quot;</span>, num3);</span><br></pre></td></tr></table></figure><h3 id="7-7-指针小结"><a href="#7-7-指针小结" class="headerlink" title="7.7 指针小结"></a>7.7 指针小结</h3><div class="table-container"><table><thead><tr><th><strong>定义</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>int i</code></td><td>定义整形变量</td></tr><tr><td><code>int *p</code></td><td>定义一个指向int的指针变量</td></tr><tr><td><code>int a[10]</code></td><td>定义一个有10个元素的数组，每个元素类型为int</td></tr><tr><td><code>int *p[10]</code></td><td>定义一个有10个元素的数组，每个元素类型为int*</td></tr><tr><td><code>int func()</code></td><td>定义一个函数，返回值为int型</td></tr><tr><td><code>int *func()</code></td><td>定义一个函数，返回值为int *型</td></tr><tr><td><code>int **p</code></td><td>定义一个指向int的指针的指针，二级指针</td></tr></tbody></table></div><h2 id="8-内存管理"><a href="#8-内存管理" class="headerlink" title="8. 内存管理"></a>8. 内存管理</h2><h3 id="8-1-作用域"><a href="#8-1-作用域" class="headerlink" title="8.1 作用域"></a>8.1 作用域</h3><p>C语言变量的作用域分为：</p><ul><li><p>代码块作用域(代码块是{}之间的一段代码)</p></li><li><p>函数作用域</p></li><li><p>文件作用域</p></li></ul><h4 id="8-1-1-局部变量"><a href="#8-1-1-局部变量" class="headerlink" title="8.1.1 局部变量"></a>8.1.1 局部变量</h4><p>局部变量也叫<code>auto自动变量</code>(auto可写可不写)，一般情况下代码块<code>&#123;&#125;</code>内部定义的变量都是自动变量，它有如下特点：</p><ul><li>在一个函数内定义，只在函数范围内有效</li><li>在复合语句中定义，只在复合语句中有效</li><li><font color="red">随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束</font></li><li>如果没有赋初值，内容为随机</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// auto 写不写是一样的</span></span><br><span class="line"><span class="comment">// auto 只能出现在&#123;&#125;内部</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// b = 100; //err 在main作用域中没有b</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在复合语句中定义，只在复合语句中有效</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = 10;//err离开if()的复合语句，a已经不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-2-静态-static-局部变量"><a href="#8-1-2-静态-static-局部变量" class="headerlink" title="8.1.2 静态(static)局部变量"></a>8.1.2 静态(static)局部变量</h4><ul><li>static局部变量的作用域也是在定义的函数内有效</li><li>static局部变量的生命周期和程序运行周期一样，<font color="red">同时staitc局部变量的值只初始化一次，但可以赋值多次</font></li><li>static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态局部变量，没有赋值，系统赋值为0，而且只会初始化一次</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    fun1();</span><br><span class="line">    fun2();</span><br><span class="line">    fun2();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-3-全局变量"><a href="#8-1-3-全局变量" class="headerlink" title="8.1.3 全局变量"></a>8.1.3 全局变量</h4><ul><li>在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量,须用<code>extern</code>声明</li><li>全局变量的生命周期和程序运行周期一样</li><li>不同文件的全局变量不可重名</li></ul><h4 id="8-1-4-静态-static-全局变量"><a href="#8-1-4-静态-static-全局变量" class="headerlink" title="8.1.4 静态(static)全局变量"></a>8.1.4 静态(static)全局变量</h4><ul><li>在函数外定义,作用范围被限制在所定义的文件中</li><li>不同文件静态全局变量可以重名,但作用域不冲突</li><li><code>static</code>全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次</li></ul><h4 id="8-1-5-extern全局变量声明"><a href="#8-1-5-extern全局变量声明" class="headerlink" title="8.1.5  extern全局变量声明"></a>8.1.5  extern全局变量声明</h4><p><code>extern int a;</code>声明一个变量，这个全局变量在别的文件中已经定义了，这里只是声明，而不是定义</p><h4 id="8-1-6-全局函数和静态函数"><a href="#8-1-6-全局函数和静态函数" class="headerlink" title="8.1.6 全局函数和静态函数"></a>8.1.6 全局函数和静态函数</h4><p>在C语言中函数默认都是全局的，使用关键字<code>static</code>可以将函数声明为静态，函数定义为<code>static</code>就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用</p><p>对于不同文件中的<code>staitc</code>函数名字可以相同</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649627.jpg" alt="2016-06-05_011701"></p><p>注意：</p><ul><li><p>允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。</p></li><li><p>同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。</p></li><li><p>所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是<code>staitc</code>函数，那么作用域是文件级的，所以不同的文件<code>static</code>函数名是可以相同的</p></li></ul><h4 id="8-1-7-总结"><a href="#8-1-7-总结" class="headerlink" title="8.1.7 总结"></a>8.1.7 总结</h4><div class="table-container"><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td></tr><tr><td>全局变量</td><td>整个程序</td><td>整个程序运行期</td></tr></tbody></table></div><h3 id="8-2-内存布局"><a href="#8-2-内存布局" class="headerlink" title="8.2 内存布局"></a>8.2 内存布局</h3><h4 id="8-2-1-内存分区"><a href="#8-2-1-内存分区" class="headerlink" title="8.2.1 内存分区"></a>8.2.1 内存分区</h4><p>C代码经过<font color="red">预处理、编译、汇编、链接</font>4步后生成一个可执行程序。</p><p>在 Windows 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649084.jpg" alt="image-20200925161021903"></p><p>通过上图可以得知，在没有运行程序前，也就是说<font color="red">程序没有加载到内存前</font>，可执行程序内部已经分好3段信息，分别为<font color="red">代码区（text）、数据区（data）和未初始化数据区（bss）</font>3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。</p><ul><li>代码区<ul><li>存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。<font color="red">代码区通常是只读的</font>，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息</li></ul></li><li>全局初始化数据区/静态数据区（data段）<ul><li>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）</li></ul></li><li>未初始化数据区（又叫 bss 区）<ul><li>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）</li><li>程序在加载到内存前，<font color="red">代码区和全局区(data和bss)的大小就是固定的</font>，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，<font color="red">除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区</font></li></ul></li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649869.jpg" alt="img"></p><ul><li><p>代码区（text segment）</p><ul><li>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</li></ul></li><li><p>未初始化数据区（BSS）</p><ul><li>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</li></ul></li><li><p>全局初始化数据区/静态数据区（data segment）</p><ul><li>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</li></ul></li><li><p>栈区（stack）</p><ul><li>栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</li></ul></li><li><p>堆区（heap）</p><ul><li>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li></ul></li></ul><h4 id="8-2-2-存储类型总结"><a href="#8-2-2-存储类型总结" class="headerlink" title="8.2.2 存储类型总结"></a>8.2.2 存储类型总结</h4><div class="table-container"><table><thead><tr><th><strong>类型</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>存储位置</strong></th></tr></thead><tbody><tr><td>auto变量</td><td>一对{}内</td><td>当前函数</td><td>栈区</td></tr><tr><td>static局部变量</td><td>一对{}内</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern变量</td><td>整个程序</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>static全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>初始化在data段，未初始化在BSS段</td></tr><tr><td>extern函数</td><td>整个程序</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>static函数</td><td>当前文件</td><td>整个程序运行期</td><td>代码区</td></tr><tr><td>register变量</td><td>一对{}内</td><td>当前函数</td><td>运行时存储在CPU寄存器</td></tr><tr><td>字符串常量</td><td>当前文件</td><td>整个程序运行期</td><td>data段</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> h = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> *i = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">char</span> *k = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a\t %p\t //局部未初始化变量\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;b\t %p\t //局部初始化变量\n&quot;</span>, &amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;c\t %p\t //静态局部未初始化变量\n&quot;</span>, &amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;d\t %p\t //静态局部初始化变量\n&quot;</span>, &amp;d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;e\t %p\t //全局未初始化变量\n&quot;</span>, &amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;f\t %p\t //全局静态未初始化变量\n&quot;</span>, &amp;f);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;g\t %p\t //全局初始化变量\n&quot;</span>, &amp;g);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;h\t %p\t //全局静态初始化变量\n&quot;</span>, &amp;h);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i\t %p\t //只读数据(文字常量区)\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">k = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;k\t %p\t //动态分配的内存\n&quot;</span>, k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tao@Taoc:~/Desktop/C/<span class="number">8</span>$ ./<span class="number">8.2</span><span class="number">.2</span> </span><br><span class="line">&amp;a <span class="number">0x7ffe96a0a7e0</span> <span class="comment">//局部未初始化变量</span></span><br><span class="line">&amp;b <span class="number">0x7ffe96a0a7e4</span> <span class="comment">//局部初始化变量</span></span><br><span class="line">&amp;c <span class="number">0x559add9ab024</span> <span class="comment">//静态局部未初始化变量</span></span><br><span class="line">&amp;d <span class="number">0x559add9ab018</span> <span class="comment">//静态局部初始化变量</span></span><br><span class="line">&amp;e <span class="number">0x559add9ab028</span> <span class="comment">//全局未初始化变量</span></span><br><span class="line">&amp;f <span class="number">0x559add9ab020</span> <span class="comment">//全局静态未初始化变量</span></span><br><span class="line">&amp;g <span class="number">0x559add9ab010</span> <span class="comment">//全局初始化变量</span></span><br><span class="line">&amp;h <span class="number">0x559add9ab014</span> <span class="comment">//全局静态初始化变量</span></span><br><span class="line">i <span class="number">0x559add9a9008</span> <span class="comment">//只读数据(文字常量区)</span></span><br><span class="line">k <span class="number">0x559adeaac670</span> <span class="comment">//动态分配的内存</span></span><br></pre></td></tr></table></figure><h4 id="8-2-3-内存操作函数"><a href="#8-2-3-内存操作函数" class="headerlink" title="8.2.3 内存操作函数"></a>8.2.3 内存操作函数</h4><h5 id="1-memset"><a href="#1-memset" class="headerlink" title="1. memset()"></a>1. memset()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将s的内存区域的前n个字节以参数c填入</p><p>参数：</p><p>​    s：需要操作内存s的首地址</p><p>​    c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255</p><p>​    n：指定需要设置的大小</p><p>返回值：s的首地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">97</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-memcpy"><a href="#2-memcpy" class="headerlink" title="2. memcpy()"></a>2. memcpy()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。</p><p>参数：</p><p>​    dest：目的内存首地址</p><p>​    src：源内存首地址，<font color='red'>注意：dest和src所指的内存空间不可重叠，可能会导致程序报错</font></p><p>​    n：需要拷贝的字节数</p><p>返回值：dest的首地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//memcpy(&amp;a[3], a, 5 * sizeof(int)); //err, 内存重叠</span></span><br></pre></td></tr></table></figure><h5 id="3-memmove"><a href="#3-memmove" class="headerlink" title="3.  memmove()"></a>3.  memmove()</h5><p>memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些</p><h5 id="4-memcmp"><a href="#4-memcmp" class="headerlink" title="4.  memcmp()"></a>4.  memcmp()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：比较s1和s2所指向内存区域的前n个字节</p><p>参数：</p><p>​    s1：内存首地址1</p><p>​    s2：内存首地址2</p><p>​    n：需比较的前n个字节</p><p>返回值：</p><p>​    相等：=0</p><p>​    大于：&gt;0</p><p>​    小于：&lt;0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">memcmp</span>(a, b, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag = %d\n&quot;</span>, flag);</span><br></pre></td></tr></table></figure><h4 id="8-2-4-堆区内存分配和释放"><a href="#8-2-4-堆区内存分配和释放" class="headerlink" title="8.2.4 堆区内存分配和释放"></a>8.2.4 堆区内存分配和释放</h4><h5 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1. malloc()"></a>1. malloc()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。</p><p>参数：</p><p>​    size：需要分配内存大小(单位：字节)</p><p>返回值：</p><p>成功：分配空间的起始地址</p><p>失败：NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count, *<span class="built_in">array</span>, n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要申请数组的个数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将申请到空间清0</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; n; count++)</span><br><span class="line">        <span class="built_in">array</span>[count] = count;</span><br><span class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; n; count++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>, <span class="built_in">array</span>[count]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">8</span>$ ./<span class="number">8.2</span><span class="number">.4</span><span class="number">-1</span> </span><br><span class="line">请输入要申请数组的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>tao@Taoc:~/Desktop/C/<span class="number">8</span>$ </span><br></pre></td></tr></table></figure><h5 id="2-free"><a href="#2-free" class="headerlink" title="2. free()"></a>2. free()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。</p><p>参数：</p><p>ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。</p><p>返回值：无</p></blockquote><h3 id="8-3-内存分区代码分析"><a href="#8-3-内存分区代码分析" class="headerlink" title="8.3 内存分区代码分析"></a>8.3 内存分区代码分析</h3><h4 id="1-返回栈区地址"><a href="#1-返回栈区地址" class="headerlink" title="1. 返回栈区地址"></a>1. 返回栈区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = fun();</span><br><span class="line">    *p = <span class="number">100</span>; <span class="comment">// 操作野指针指向的内存，err</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-返回data区地址"><a href="#2-返回data区地址" class="headerlink" title="2. 返回data区地址"></a>2. 返回data区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> &amp;a; <span class="comment">// 函数调用完毕,a不释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = func();</span><br><span class="line">    *p = <span class="number">100</span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-值传递1"><a href="#3-值传递1" class="headerlink" title="3. 值传递1"></a>3. 值传递1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argc[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">fun(p); <span class="comment">// 值传递，形参修改不会影响实参</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-值传递2"><a href="#4-值传递2" class="headerlink" title="4. 值传递2"></a>4. 值传递2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">fun(p); <span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p); <span class="comment">//ok，*p为100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-返回堆区地址"><a href="#5-返回堆区地址" class="headerlink" title="5. 返回堆区地址"></a>5. 返回堆区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">tmp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*tmp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> tmp; <span class="comment">// 返回堆区地址，函数调用完毕，不释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆区空间，使用完毕，手动释放</span></span><br><span class="line">    <span class="keyword">if</span>( p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-复合类型-自定义类型"><a href="#9-复合类型-自定义类型" class="headerlink" title="9. 复合类型(自定义类型)"></a>9. 复合类型(自定义类型)</h2><h3 id="9-1-结构体"><a href="#9-1-结构体" class="headerlink" title="9.1 结构体"></a>9.1 结构体</h3><h4 id="9-1-1-概述"><a href="#9-1-1-概述" class="headerlink" title="9.1.1 概述"></a>9.1.1 概述</h4><p>数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算</p><p>有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理</p><p>Ｃ语言中给出了另一种构造数据类型——结构体</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649998.jpg" alt="2016-06-05_152127"></p><h4 id="9-1-2-结构体变量的定义和初始化"><a href="#9-1-2-结构体变量的定义和初始化" class="headerlink" title="9.1.2 结构体变量的定义和初始化"></a>9.1.2 结构体变量的定义和初始化</h4><p>定义结构体变量的方式：</p><ul><li><p>先声明结构体类型再定义变量名</p></li><li><p>在声明类型的同时定义变量</p></li><li><p>直接定义结构体类型变量（无类型名）</p></li></ul><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649785.jpg" alt="2016-06-05_153150"></p><p>结构体类型和结构体变量关系：</p><ul><li>结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元</li><li>结构体变量：系统根据结构体类型（内部成员状况）为之分配空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义类型，再定义变量（常用）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;Taoy&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类型同时定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;s2 = &#123;<span class="string">&quot;Tao&quot;</span>, <span class="number">19</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;s3 = &#123;<span class="string">&quot;Taooo&quot;</span>, <span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-1-3-结构体成员的使用"><a href="#9-1-3-结构体成员的使用" class="headerlink" title="9.1.3  结构体成员的使用"></a>9.1.3  结构体成员的使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sring.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s1.name, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    s1.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1.name = %s, s1.age = %d\n&quot;</span>, s1.name, s1.age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line">    <span class="built_in">strcpy</span>((&amp;s1)-&gt;name, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    (&amp;s1)-&gt;age = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&amp;s1)-&gt;name = %s, (&amp;s1)-&gt;age = %d\n&quot;</span>, (&amp;s1)-&gt;name, (&amp;s1)-&gt;age);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-结构体数组"><a href="#9-1-4-结构体数组" class="headerlink" title="9.1.4 结构体数组"></a>9.1.4 结构体数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计学生成绩</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">boy</span>[5] =</span> &#123;</span><br><span class="line">&#123; <span class="number">101</span>, <span class="string">&quot;Li ping&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">45</span> &#125;,</span><br><span class="line">&#123; <span class="number">102</span>, <span class="string">&quot;Zhang ping&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">62.5</span> &#125;,</span><br><span class="line">&#123; <span class="number">103</span>, <span class="string">&quot;He fang&quot;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">92.5</span> &#125;,</span><br><span class="line">&#123; <span class="number">104</span>, <span class="string">&quot;Cheng ling&quot;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">87</span> &#125;,</span><br><span class="line">&#123; <span class="number">105</span>, <span class="string">&quot;Wang ming&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">58</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> ave,s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s += boy[i].score; <span class="comment">//计算总分</span></span><br><span class="line">        <span class="keyword">if</span>(boy[i].score &lt; <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c += <span class="number">1</span>;<span class="comment">//统计不及格人的分数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %f\n&quot;</span>, s); <span class="comment">// 打印总分数</span></span><br><span class="line">    ave = s / <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;average = %f\n count=%d\n\n&quot;</span>, ave, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name = %s, score = %f\n&quot;</span>,boy[i].name, boy[i].score);</span><br><span class="line">        <span class="comment">// printf(&quot; name=%s,  score=%f\n&quot;, (boy + i )-&gt;name, (boy + i)-&gt;score);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-5-结构体套结构体"><a href="#9-1-5-结构体套结构体" class="headerlink" title="9.1.5 结构体套结构体"></a>9.1.5 结构体套结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">info</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span>[2] =</span> &#123;<span class="number">1</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">2</span>, <span class="string">&quot;yuri&quot;</span>, <span class="string">&quot;M&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;id = %d\tinfo.name=%s\tinfo.sex=%c\n&quot;</span>, s[i].id, s[i].info.name, s[i].info.sex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-6-结构体赋值"><a href="#9-1-6-结构体赋值" class="headerlink" title="9.1.6 结构体赋值"></a>9.1.6 结构体赋值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span>;</span></span><br><span class="line">    <span class="comment">//如果是普通变量，通过点运算符操作结构体成员</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s1.name, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    s1.age = <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1.name = %s, s1.age = %d\n&quot;</span>, s1.name, s1.age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相同类型的两个结构体变量，可以相互赋值</span></span><br><span class="line"><span class="comment">//把s1成员变量的值拷贝给s2成员变量的内存</span></span><br><span class="line"><span class="comment">//s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s2</span> =</span> s1;</span><br><span class="line">    <span class="comment">//memcpy(&amp;s2, &amp;s1, sizeof(s1));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2.name = %s, s2.gae = %d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-7-结构体和指针"><a href="#9-1-7-结构体和指针" class="headerlink" title="9.1.7 结构体和指针"></a>9.1.7 结构体和指针</h4><h5 id="1-指向普通结构体变量的指针"><a href="#1-指向普通结构体变量的指针" class="headerlink" title="1. 指向普通结构体变量的指针"></a>1. 指向普通结构体变量的指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;Tao&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    <span class="comment">// 如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> =</span> &amp;s1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;name = %s, p-&gt;age=%d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(*p).name = %s, (*p).age=%d\n&quot;</span>,  (*p).name,  (*p).age);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-堆区结构体变量"><a href="#2-堆区结构体变量" class="headerlink" title="2. 堆区结构体变量"></a>2. 堆区结构体变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">struct</span> stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    <span class="comment">// 如果是指针变量，通过-&gt;操作结构体成员</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    p-&gt;age = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;name = %s, p-&gt;age=%d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(*p).name = %s, (*p).age=%d\n&quot;</span>, (*p).name,  (*p).age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-结构体套一级指针"><a href="#3-结构体套一级指针" class="headerlink" title="3. 结构体套一级指针"></a>3. 结构体套一级指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 机构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">// 一级指针</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">struct</span> stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    </span><br><span class="line">    p-&gt;name = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;test&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    p-&gt;age = <span class="number">19</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;name = %s, p-&gt;age = %d\n&quot;</span>, p-&gt;name, p-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*p).name = %s, (*p).age=%d\n&quot;</span>, (*p).name, (*p).age);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;name);</span><br><span class="line">        p-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-8-结构体做函数参数"><a href="#9-1-8-结构体做函数参数" class="headerlink" title="9.1.8 结构体做函数参数"></a>9.1.8 结构体做函数参数</h4><h5 id="1-结构体普通变量做函数参数"><a href="#1-结构体普通变量做函数参数" class="headerlink" title="1. 结构体普通变量做函数参数"></a>1. 结构体普通变量做函数参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数为结构体普通变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_stu</span><span class="params">(<span class="keyword">struct</span> stu tmp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.name, <span class="string">&quot;Tao&quot;</span>);</span><br><span class="line">    tmp.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tmp.name = %s, tmp.age = %d\n&quot;</span>, tmp.name, tmp.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    set_stu(s);<span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s.name = %s, s.age = %d\n&quot;</span>, s.name, s.age);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-结构体指针变量做函数参数"><a href="#2-结构体指针变量做函数参数" class="headerlink" title="2. 结构体指针变量做函数参数"></a>2. 结构体指针变量做函数参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_stu_pro</span><span class="params">(<span class="keyword">struct</span> stu *tmp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(tmp-&gt;name, <span class="string">&quot;Tao&quot;</span>);</span><br><span class="line">tmp-&gt;age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">set_stu_pro(&amp;s); <span class="comment">// 地址传递</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s.name = %s, s.age = %d\n&quot;</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-const修饰结构体指针形参变量"><a href="#4-const修饰结构体指针形参变量" class="headerlink" title="4. const修饰结构体指针形参变量"></a>4. const修饰结构体指针形参变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="keyword">struct</span> stu * <span class="type">const</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//p = NULL; // err</span></span><br><span class="line">    p-&gt;age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void(struct stu const* p)</span></span><br><span class="line"><span class="type">void</span>(<span class="type">const</span> <span class="keyword">struct</span> stu * p)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="literal">NULL</span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="comment">// p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun3</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> stu * <span class="type">const</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p = NULL; //err</span></span><br><span class="line"><span class="comment">//p-&gt;age = 10; //err</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-共用体-联合体"><a href="#9-2-共用体-联合体" class="headerlink" title="9.2 共用体(联合体)"></a>9.2 共用体(联合体)</h3><ul><li>联合union是一个能在同一个存储空间存储不同类型数据的类型；</li><li>联合体所占的内存长度等于其最长成员的长度倍数，也有叫做共用体；</li><li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；</li><li>共用体变量的地址和它的各成员的地址都是同一地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共用体也叫联合体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义共用体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Test</span> <span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 所有成员的首地址是一样的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p\n&quot;</span>, &amp;(tmp.a), &amp;(tmp.b), &amp;(tmp.c));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、共用体大小为最大成员类型的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Test));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、一个成员赋值，会影响另外的成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左边是高位，右边是低位</span></span><br><span class="line"><span class="comment">//低位放低地址，高位放高地址</span></span><br><span class="line">tmp.b = <span class="number">0x44332211</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, tmp.a); <span class="comment">//11</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, tmp.c); <span class="comment">//2211</span></span><br><span class="line"></span><br><span class="line">tmp.a = <span class="number">0x00</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;short: %x\n&quot;</span>, tmp.c); <span class="comment">//2200</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int: %x\n&quot;</span>, tmp.b); <span class="comment">//44332200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-枚举"><a href="#9-3-枚举" class="headerlink" title="9.3 枚举"></a>9.3 枚举</h3><p>枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><p>枚举类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>  枚举名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">枚举值表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在枚举值表中应列出所有可用值，也称为枚举元素</li><li>枚举值是常量，不能在程序中用赋值语句再对它赋值</li><li>举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">sun = <span class="number">2</span>, mon, tue, wed, thu, fri, sat</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bool</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>,<span class="title">b</span>,<span class="title">c</span>;</span></span><br><span class="line">a = sun;</span><br><span class="line">b = mon;</span><br><span class="line">c = tue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bool</span> <span class="title">flag</span>;</span></span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag为真\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Taoc:~/Desktop/C/<span class="number">9</span>$ ./<span class="number">9.3</span> </span><br><span class="line"><span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">flag为真</span><br></pre></td></tr></table></figure><h3 id="9-4-typedef"><a href="#9-4-typedef" class="headerlink" title="9.4 typedef"></a>9.4 typedef</h3><p>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，<font color="red">不能创建新类型</font></p><ul><li>与<code>#define</code>不同，<code>typedef</code>仅限于数据类型，而不是能是表达式或具体的值</li><li><code>#define</code>发生在预处理，typedef发生在编译阶段</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BYTE;</span><br><span class="line"><span class="keyword">typedef</span> BYTE T_BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> UBYTE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">unsigned</span> <span class="title">char</span> <span class="title">UBYTE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UBYTE a;</span><br><span class="line">INT b;</span><br><span class="line">T_BYTE c;</span><br><span class="line">&#125;TYPE, *PTYPE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">TYPE t;</span><br><span class="line">t.a = <span class="number">254</span>;</span><br><span class="line">t.b = <span class="number">10</span>;</span><br><span class="line">t.c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">PTYPE p = &amp;t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u, %d, %c\n&quot;</span>, p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-文件操作"><a href="#10-文件操作" class="headerlink" title="10. 文件操作"></a>10. 文件操作</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><h4 id="10-1-1磁盘文件和设备文件"><a href="#10-1-1磁盘文件和设备文件" class="headerlink" title="10.1.1磁盘文件和设备文件"></a>10.1.1磁盘文件和设备文件</h4><ul><li><p>磁盘文件</p><ul><li>指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存</li></ul></li><li>设备文件<ul><li>在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写</li></ul></li></ul><h4 id="10-1-2-磁盘文件的分类"><a href="#10-1-2-磁盘文件的分类" class="headerlink" title="10.1.2 磁盘文件的分类"></a>10.1.2 磁盘文件的分类</h4><p>计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011649358.png" alt="2016-06-06_150022"></p><p>从用户或者操作系统使用的角度（逻辑上）把文件分为：</p><ul><li><p>文本文件：基于字符编码的文件 </p></li><li><p>二进制文件：基于值编码的文件</p></li></ul><h4 id="10-1-3-文本文件和二进制文件"><a href="#10-1-3-文本文件和二进制文件" class="headerlink" title="10.1.3 文本文件和二进制文件"></a>10.1.3 文本文件和二进制文件</h4><h5 id="1-文本文件"><a href="#1-文本文件" class="headerlink" title="1. 文本文件"></a>1. 文本文件</h5><ul><li><p>基于字符编码，常见编码有ASCII、UNICODE等</p></li><li><p>一般可以使用文本编辑器直接打开</p></li><li><p>数5678的以ASCII存储形式(ASCII码)为：</p><p>00110101 00110110 00110111 00111000</p></li></ul><h5 id="2-二进制文件"><a href="#2-二进制文件" class="headerlink" title="2. 二进制文件"></a>2. 二进制文件</h5><ul><li>基于值编码,自己根据具体应用,指定某个值是什么意思</li><li>把内存中的数据按其在内存中的存储形式原样输出到磁盘上</li><li>数5678的存储形式(二进制码)为：</li><li>00010110 00101110</li></ul><h3 id="10-2-文件的打开和关闭"><a href="#10-2-文件的打开和关闭" class="headerlink" title="10.2 文件的打开和关闭"></a>10.2 文件的打开和关闭</h3><h4 id="10-2-1-文件指针"><a href="#10-2-1-文件指针" class="headerlink" title="10.2.1 文件指针"></a>10.2.1 文件指针</h4><p>在C语言中用一个指针变量指向一个文件，这个指针称为文件指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">short</span>           level;<span class="comment">//缓冲区&quot;满&quot;或者&quot;空&quot;的程度 </span></span><br><span class="line"><span class="type">unsigned</span>        flags;<span class="comment">//文件状态标志 </span></span><br><span class="line"><span class="type">char</span>            fd;<span class="comment">//文件描述符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>   hold;<span class="comment">//如无缓冲区不读取字符</span></span><br><span class="line"><span class="type">short</span>           bsize;<span class="comment">//缓冲区的大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>   *buffer;<span class="comment">//数据缓冲区的位置 </span></span><br><span class="line"><span class="type">unsigned</span>        ar; <span class="comment">//指针，当前的指向 </span></span><br><span class="line"><span class="type">unsigned</span>        istemp;<span class="comment">//临时文件，指示器</span></span><br><span class="line"><span class="type">short</span>           token;<span class="comment">//用于有效性的检查 </span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，<font color="red">结构中含有文件名、文件状态和文件当前位置等信息</font></p><p>声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011650821.jpg" alt="图片1"></p><p>C语言中有三个特殊的文件指针由系统默认打开，<font color="red">用户无需定义即可直接使用:</font></p><ul><li><code>stdin</code>：标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据</li><li><code>stdout</code>: 标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端</li><li><code>stderr</code>: 标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端</li></ul><h4 id="10-2-2-文件的打开"><a href="#10-2-2-文件的打开" class="headerlink" title="10.2.2 文件的打开"></a>10.2.2 文件的打开</h4><p>任何文件使用之前必须打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE * <span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：打开文件</p><p>参数：</p><p>​    filename：需要打开的文件名，根据需要加上路径</p><p>​    mode：打开文件的模式设置</p><p>返回值：</p><p>​    成功：文件指针</p><p>​    失败：NULL</p></blockquote><p>第一个参数的几种形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp_passwd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相对路径：</span></span><br><span class="line"><span class="comment">//打开当前目录passdw文件：源文件(源程序)所在目录</span></span><br><span class="line">FILE *fp_passwd = fopen(<span class="string">&quot;passwd.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开当前目录(test)下passwd.txt文件</span></span><br><span class="line">fp_passwd = fopen(<span class="string">&quot;. / test / passwd.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开当前目录上一级目录（相对当前目录）passwd.txt文件</span></span><br><span class="line">fp_passwd = fopen(<span class="string">&quot;.. / passwd.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绝对路径：</span></span><br><span class="line"><span class="comment">//打开C盘test目录下一个叫passwd.txt文件</span></span><br><span class="line">fp_passwd = fopen(<span class="string">&quot;c:/test/passwd.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>第二个参数的几种形式(打开文件的方式)：</p><div class="table-container"><table><thead><tr><th><strong>打开模式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>r或rb</td><td>以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td>w或wb</td><td>以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a或ab</td><td>以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td>r+或rb+</td><td>以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td>w+或wb+</td><td>以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td>a+或ab+</td><td>以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。</td></tr></tbody></table></div><p>注意：</p><ul><li>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</li><li>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</li><li>在Windows平台下，以“文本”方式打开文件，不加b：<ul><li>n 当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入</li><li><font color="red">n 以"二进制"方式打开文件，则读写都不会进行这样的转换</font></li></ul></li><li>在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// &quot;\\&quot;这样的路径形式，只能在windows使用</span></span><br><span class="line"><span class="comment">// &quot;/&quot;这样的路径形式，windows和linux平台下都可用，建议使用这种</span></span><br><span class="line"><span class="comment">// 路径可以是相对路径，也可是绝对路径</span></span><br><span class="line">fp = fopen(<span class="string">&quot;../test&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="comment">// fp = fopen(&quot;..\\test&quot;, &quot;w&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//perror()是标准出错打印函数，能打印调用库函数出错原因</span></span><br><span class="line">perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-3-文件的关闭"><a href="#10-2-3-文件的关闭" class="headerlink" title="10.2.3 文件的关闭"></a>10.2.3 文件的关闭</h4><p>任何文件在使用后应该关闭：</p><ul><li>打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存</li><li>一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用<code>fopen</code>打开文件会失败</li><li>如果没有明确的调用<code>fclose</code>关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">fp = fopen(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h3 id="10-3-文件的顺序读写"><a href="#10-3-文件的顺序读写" class="headerlink" title="10.3 文件的顺序读写"></a>10.3 文件的顺序读写</h3><h4 id="10-3-1-按照字符读写文件fgetc、fputc"><a href="#10-3-1-按照字符读写文件fgetc、fputc" class="headerlink" title="10.3.1 按照字符读写文件fgetc、fputc"></a>10.3.1 按照字符读写文件fgetc、fputc</h4><h5 id="1-写文件"><a href="#1-写文件" class="headerlink" title="1. 写文件"></a>1. 写文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将ch转换为unsigned char后写入stream指定的文件中</p><p>参数：</p><p>​    ch：需要写入文件的字符</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：成功写入文件的字符</p><p>​    失败：返回-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;My name is Tao.&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 往文件fp写入符buf[i]</span></span><br><span class="line"><span class="type">int</span> ch = fputc(buf[i], fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-文件结尾"><a href="#2-文件结尾" class="headerlink" title="2. 文件结尾"></a>2. 文件结尾</h5><p>在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，<font color="red">这种以EOF作为文件结束标志的文件，必须是文本文件。</font>在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EOF    (-1)</span></span><br></pre></td></tr></table></figure><p>当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。<font color="red">feof函数既可用以判断二进制文件又可用以判断文本文件</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：检测是否读取到了文件结尾。<font color="red">判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。</font></p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    非0值：已经到文件结尾</p><p>​    0：没有到文件结尾</p></blockquote><h5 id="3-读文件"><a href="#3-读文件" class="headerlink" title="3. 读文件"></a>3. 读文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：从stream指定的文件中读取一个字符</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：返回读取到的字符</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">while</span>((ch = fgetc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!feop(fp)) <span class="comment">//文件没有结束，则执行循环</span></span><br><span class="line">&#123;</span><br><span class="line">ch = fgetc(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="10-3-2-按照行读写文件fgets、fputs"><a href="#10-3-2-按照行读写文件fgets、fputs" class="headerlink" title="10.3.2 按照行读写文件fgets、fputs"></a>10.3.2 按照行读写文件fgets、fputs</h4><h5 id="1-写文件-1"><a href="#1-写文件-1" class="headerlink" title="1. 写文件"></a>1. 写文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 ‘<code>\0</code>‘  不写入文件。 </p><p>参数：</p><p>​    str：字符串</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf[] = &#123; <span class="string">&quot;123456\n&quot;</span>, <span class="string">&quot;bbbbbbbbbb\n&quot;</span>, <span class="string">&quot;ccccccccccc\n&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fputs</span>(buf[i], fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;len = %d\n&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2. 读文件"></a>2. 读文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> size, FILE * stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 ‘\0’ 作为字符串结束。</p><p>参数：</p><p>​    str：字符串</p><p>​    size：指定最大读取字符串的长度（size - 1）</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：成功读取的字符串</p><p>​    读到文件尾或出错： NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(!feof(fp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="type">char</span> *p = gets(buf, <span class="keyword">sizeof</span>(buf), fp);</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf = %s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-强化训练：文件版四则运算"><a href="#3-强化训练：文件版四则运算" class="headerlink" title="3. 强化训练：文件版四则运算"></a>3. 强化训练：文件版四则运算</h4><p>有个文件大小不确定，每行内容都是一个四则运算表达式，还没有算出结果，写一个程序，自动算出其结果后修改文件</p><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011650522.jpg" alt="2016-06-06_172151"></p><h4 id="10-3-3-按照格式化文件fprintf、fscanf"><a href="#10-3-3-按照格式化文件fprintf、fscanf" class="headerlink" title="10.3.3 按照格式化文件fprintf、fscanf"></a>10.3.3 按照格式化文件fprintf、fscanf</h4><h5 id="1-写文件-2"><a href="#1-写文件-2" class="headerlink" title="1. 写文件"></a>1. 写文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE * stream, <span class="type">const</span> <span class="type">char</span> * format, ...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 ‘\0’ 为止。</p><p>参数：</p><p>​    stream：已经打开的文件</p><p>​    format：字符串格式，用法和printf()一样</p><p>返回值：</p><p>​    成功：实际写入文件的字符个数</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d %d %d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="2-读文件-1"><a href="#2-读文件-1" class="headerlink" title="2. 读文件"></a>2. 读文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE * stream, <span class="type">const</span> <span class="type">char</span> * format, ...)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。</p><p>参数：</p><p>​    stream：已经打开的文件</p><p>​    format：字符串格式，用法和scanf()一样</p><p>返回值：</p><p>​    成功：参数数目，成功转换的值的个数</p><p>​    失败： - 1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d %d %d\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1318708771.cos.ap-beijing.myqcloud.com/test/202307011650941.jpg" alt="2016-06-06_173443"></p><h4 id="10-3-4-按照块读写文件fread、fwrite"><a href="#10-3-4-按照块读写文件fread、fwrite" class="headerlink" title="10.3.4 按照块读写文件fread、fwrite"></a>10.3.4 按照块读写文件fread、fwrite</h4><h5 id="1-写文件-3"><a href="#1-写文件-3" class="headerlink" title="1. 写文件"></a>1. 写文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：以数据块的方式给文件写入内容</p><p>参数：</p><p>​    ptr：准备写入文件数据的地址</p><p>​    size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小</p><p>​    nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    成功：实际成功写入文件数据的块数目，此值和 nmemb 相等</p><p>​    失败：0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> id; </span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line">Stu s[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(s[i].name, <span class="string">&quot;stu%d%d%d&quot;</span>, i, i, i);</span><br><span class="line">    s[i].id = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = fwrite(s, <span class="keyword">sizeof</span>(Stu), <span class="number">3</span>, fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br></pre></td></tr></table></figure><h5 id="2-读文件-2"><a href="#2-读文件-2" class="headerlink" title="2. 读文件"></a>2. 读文件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：以数据块的方式从文件中读取内容</p><p>参数：</p><p>​    ptr：存放读取出来数据的内存空间</p><p>​    size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小</p><p>​    nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。</p><p>​    失败：0</p><p>​    0: 表示读到文件结尾。(feof())</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line">Stu s[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> ret = fread(s, <span class="keyword">sizeof</span>(Stu), <span class="number">3</span>, fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = %s, %d\n&quot;</span>, s[i].name, s[i].id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-文件的随机读写"><a href="#10-4-文件的随机读写" class="headerlink" title="10.4 文件的随机读写"></a>10.4 文件的随机读写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：移动文件流（文件光标）的读写位置。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p> offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</p><p>​    whence：其取值如下：</p><p>​       SEEK_SET：从文件开头移动offset个字节</p><p>​       SEEK_CUR：从当前位置移动offset个字节</p><p>​       SEEK_END：从文件末尾移动offset个字节</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：获取文件流（文件光标）的读写位置。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    成功：当前文件流（文件光标）的读写位置</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：把文件流（文件光标）的读写位置移动到文件开头。</p><p>参数：</p><p>​    stream：已经打开的文件指针</p><p>返回值：</p><p>​    无返回值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如已经往文件写入3个结构体</span></span><br><span class="line"><span class="comment">//fwrite(s, sizeof(Stu), 3, fp);</span></span><br><span class="line">Stu s[<span class="number">3</span>];</span><br><span class="line">Stu tmp; </span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件光标读写位置从开头往右移动2个结构体的位置</span></span><br><span class="line">fseek(fp, <span class="number">2</span> * <span class="keyword">sizeof</span>(Stu), SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读第3个结构体</span></span><br><span class="line">ret = fread(&amp;tmp, <span class="keyword">sizeof</span>(Stu), <span class="number">1</span>, fp);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[tmp]%s, %d\n&quot;</span>, tmp.name, tmp.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把文件光标移动到文件开头</span></span><br><span class="line"><span class="comment">//fseek(fp, 0, SEEK_SET);</span></span><br><span class="line">rewind(fp);</span><br><span class="line"></span><br><span class="line">ret = fread(s, <span class="keyword">sizeof</span>(Stu), <span class="number">3</span>, fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s === %s, %d\n&quot;</span>, s[i].name, s[i].id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5-Windows和Linux文本文件区别"><a href="#10-5-Windows和Linux文本文件区别" class="headerlink" title="10.5 Windows和Linux文本文件区别"></a>10.5 Windows和Linux文本文件区别</h3><ul><li>b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的</li><li>Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾</li><li>在Windows平台下，以“文本”方式打开文件，不加b：<ul><li>n 当读取文件的时候，系统会将所有的 “\r\n” 转换成 “\n”</li><li>n 当写入文件的时候，系统会将 “\n” 转换成 “\r\n” 写入 </li><li><font color="red">n 以"二进制"方式打开文件，则读\写都不会进行这样的转换</font></li></ul></li><li>在Unix/Linux平台下，“文本”与“二进制”模式没有区别，”\r\n” 作为两个字符原样输入输出</li></ul><p>判断文本文件是Linux格式还是Windows格式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    FILE *p = fopen(args[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fgets(a, <span class="keyword">sizeof</span>(a),p);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[len])</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(a[len] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[len - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;windows file\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;linux file\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-6-获取文件状态"><a href="#10-6-获取文件状态" class="headerlink" title="10.6 获取文件状态"></a>10.6 获取文件状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>int stat(const char *path, struct stat *buf);</span></span><br></pre></td></tr></table></figure><blockquote><p>功能：获取文件状态信息</p><p>参数：</p><p>​    path：文件名</p><p>​    buf：保存文件信息的结构体</p><p>返回值：</p><p>​    成功：0</p><p>​    失败-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span>         st_dev;         <span class="comment">//文件的设备编号</span></span><br><span class="line"><span class="type">ino_t</span>         st_ino;          <span class="comment">//节点</span></span><br><span class="line"><span class="type">mode_t</span>        st_mode;   <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line"><span class="type">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line"><span class="type">uid_t</span>         st_uid;         <span class="comment">//用户ID</span></span><br><span class="line"><span class="type">gid_t</span>         st_gid;         <span class="comment">//组ID</span></span><br><span class="line"><span class="type">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line"><span class="type">off_t</span>         st_size;        <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line"><span class="type">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line"><span class="type">time_t</span>        st_mtime;    <span class="comment">//最后一次修改时间</span></span><br><span class="line"><span class="type">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">at</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    stat(args[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="type">int</span> size = st.st_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-7-删除文件、重命名文件名"><a href="#10-7-删除文件、重命名文件名" class="headerlink" title="10.7 删除文件、重命名文件名"></a>10.7 删除文件、重命名文件名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：删除文件</p><p>参数：</p><p>​    pathname：文件名</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：把oldpath的文件名改为newpath</p><p>参数：</p><p>oldpath：旧文件名</p><p>newpath：新文件名</p><p>返回值：</p><p>成功：0</p><p>失败： - 1</p></blockquote><h3 id="10-8-文件缓冲区"><a href="#10-8-文件缓冲区" class="headerlink" title="10.8 文件缓冲区"></a>10.8 文件缓冲区</h3><h4 id="10-8-1-文件缓冲区"><a href="#10-8-1-文件缓冲区" class="headerlink" title="10.8.1 文件缓冲区"></a>10.8.1 文件缓冲区</h4><p>ANSI C标准采用“缓冲文件系统”处理数据文件。</p><p>所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。</p><p>如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。</p><h4 id="10-8-2-磁盘文件的存取"><a href="#10-8-2-磁盘文件的存取" class="headerlink" title="10.8.2 磁盘文件的存取"></a>10.8.2 磁盘文件的存取</h4><p><img src="image/clip_image002-1601186383431.jpg" alt="2016-06-06_182106"></p><ul><li>磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存</li><li>在内存中对文件进行编辑处理后，保存到磁盘中</li><li>程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率</li></ul><h4 id="10-8-3更新缓冲区"><a href="#10-8-3更新缓冲区" class="headerlink" title="10.8.3更新缓冲区"></a>10.8.3更新缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>功能：更新缓冲区，让缓冲区的数据立马写到文件中。</p><p>参数：</p><p>​    stream：文件指针</p><p>返回值：</p><p>​    成功：0</p><p>​    失败：-1</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C语言笔记&quot;&gt;&lt;a href=&quot;#C语言笔记&quot; class=&quot;headerlink&quot; title=&quot;C语言笔记&quot;&gt;&lt;/a&gt;C语言笔记&lt;/h1&gt;&lt;h2 id=&quot;1-C语言概述&quot;&gt;&lt;a href=&quot;#1-C语言概述&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.haodene.love/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="基础知识" scheme="https://blog.haodene.love/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="C语言" scheme="https://blog.haodene.love/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://blog.haodene.love/2023/06/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://blog.haodene.love/2023/06/09/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2023-06-09T10:19:03.000Z</published>
    <updated>2023-10-17T03:34:08.388Z</updated>
    
    <content type="html"><![CDATA[<p>-</p><h1 id="1-Markdown语法自带格式"><a href="#1-Markdown语法自带格式" class="headerlink" title="1.Markdown语法自带格式"></a>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块"><a href="#1-1-代码块" class="headerlink" title="1.1 代码块"></a>1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-2-多级标题"><a href="#1-2-多级标题" class="headerlink" title="1.2 多级标题"></a>1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-3-文字样式"><a href="#1-3-文字样式" class="headerlink" title="1.3 文字样式"></a>1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<del>删除</del>线演示</p><font size = 5>5号字</font><font face="黑体">黑体</font><font color=blue>蓝色</font><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用"><a href="#1-4-引用" class="headerlink" title="1.4 引用"></a>1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><blockquote><p> Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>….</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><hr><hr></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-6-列表-跟空格都可以"><a href="#1-6-列表-跟空格都可以" class="headerlink" title="1.6 列表(*,+,-跟空格都可以)"></a>1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表"><a href="#1-6-1-无序列表" class="headerlink" title="1.6.1 无序列表"></a>1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h3 id="1-6-2-有序列表"><a href="#1-6-2-有序列表" class="headerlink" title="1.6.2 有序列表"></a>1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-7-图片"><a href="#1-7-图片" class="headerlink" title="1.7 图片"></a>1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-8-表格"><a href="#1-8-表格" class="headerlink" title="1.8 表格"></a>1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><div class="table-container"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="1-9-公式"><a href="#1-9-公式" class="headerlink" title="1.9 公式"></a>1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><script type="math/tex; mode=display">\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.</script></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h1 id="2-Butterfly外挂标签"><a href="#2-Butterfly外挂标签" class="headerlink" title="2.Butterfly外挂标签"></a>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text"><a href="#2-1-行内文本样式-text" class="headerlink" title="2.1 行内文本样式 text"></a>2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">示例源码</button><button type="button" class="tab " data-href="分栏-3">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-2-行内文本-span"><a href="#2-2-行内文本-span" class="headerlink" title="2.2 行内文本 span"></a>2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-3-段落文本-p"><a href="#2-3-段落文本-p" class="headerlink" title="2.3 段落文本 p"></a>2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-4-引用note"><a href="#2-4-引用note" class="headerlink" title="2.4 引用note"></a>2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">通用配置</button><button type="button" class="tab " data-href="分栏-2">语法格式</button><button type="button" class="tab " data-href="分栏-3">参数配置</button><button type="button" class="tab " data-href="分栏-4">示例源码</button><button type="button" class="tab " data-href="分栏-5">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div><p>2.外部icon</p><div class="table-container"><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><br>2.<code>modern</code>样式<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了….</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-5-上标标签-tip"><a href="#2-5-上标标签-tip" class="headerlink" title="2.5 上标标签 tip"></a>2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-6-动态标签-anima"><a href="#2-6-动态标签-anima" class="headerlink" title="2.6 动态标签 anima"></a>2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div></div><div class="tab-item-content" id="分栏-3"><p>   1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><br>3.On hover（当鼠标悬停时显示动画）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><br>4.On parent hover（当鼠标悬停在父级元素时显示动画）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></p></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-7-复选列表-checkbox"><a href="#2-7-复选列表-checkbox" class="headerlink" title="2.7 复选列表 checkbox"></a>2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><h2 id="2-8-单选列表-radio"><a href="#2-8-单选列表-radio" class="headerlink" title="2.8 单选列表 radio"></a>2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div>]]></content>
    
    
    <summary type="html">本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://blog.haodene.love/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Markdown" scheme="https://blog.haodene.love/tags/Markdown/"/>
    
    <category term="外挂标签" scheme="https://blog.haodene.love/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
